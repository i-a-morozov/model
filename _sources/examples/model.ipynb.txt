{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "556562f3-8ece-4517-8c93-ee5e2fc29131",
   "metadata": {},
   "source": [
    "# Example-01: Optimizaion (import/export API)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "baa39129-4d73-44c2-bf1e-88996ea48c84",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Loading API facilitates (suboptimal) interface with different optimization libraries\n",
    "# In this example, quadrupole gradients are used to fit beta functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7aa2bbf6-cfe5-49c1-b9a7-de7cce585bbe",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "\n",
    "from model.external import load_sdds\n",
    "from model.external import load_lattice\n",
    "from model.external import text_lattice\n",
    "\n",
    "import numpy\n",
    "from numpy import ndarray as Array\n",
    "\n",
    "from scipy.optimize import minimize"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "540bbb11-ef4b-4f97-9d9a-179af31e0de8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set quadrupole gradient and compute and return twiss parameters\n",
    "\n",
    "def evaluate(knobs:Array) -> Array:\n",
    "    kf, kd = knobs\n",
    "    path:Path = Path('optimize.lte')\n",
    "    lattice:dict[str, dict[str, str | int | float | dict]] = load_lattice(path)\n",
    "    lattice['QF']['K1'] = float(kf)\n",
    "    lattice['QD']['K1'] = float(kd)\n",
    "    with path.open('w') as stream:\n",
    "        stream.write(text_lattice('LTE', lattice))\n",
    "    !elegant 'optimize.ele' > /dev/null\n",
    "    !sddsconvert -ascii 'binary.twiss' 'optimize.twiss'\n",
    "    path:Path = Path('optimize.twiss')\n",
    "    _, columns = load_sdds(path)\n",
    "    return numpy.asarray([[data['betax'], data['betay']] for location, data in columns.items()]).T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f7c9dc5a-7d3e-4b74-a219-82cf714abf3c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set target beta functions\n",
    "\n",
    "target:Array = numpy.asarray([+0.21, -0.19])\n",
    "result:Array = evaluate(target)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "ffdb81b2-1cde-4b44-8133-f442d9c3065c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Set objetive function to minimize\n",
    "\n",
    "def objective(knobs:Array) -> Array:\n",
    "    return numpy.sum((evaluate(knobs) - result)**2)\n",
    "\n",
    "objective(target)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "3dda343b-b675-45c5-9ba3-e2b4f408c0b1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "       message: Optimization terminated successfully.\n",
       "       success: True\n",
       "        status: 0\n",
       "           fun: 1.3489521479279302e-28\n",
       "             x: [ 2.100e-01 -1.900e-01]\n",
       "           nit: 20\n",
       "          nfev: 40\n",
       " final_simplex: (array([[ 2.100e-01, -1.900e-01],\n",
       "                       [ 2.100e-01, -1.900e-01],\n",
       "                       [ 2.100e-01, -1.900e-01]]), array([ 1.349e-28,  2.891e-05,  6.010e-05]))"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Optimize \n",
    "\n",
    "knobs:Array = numpy.asarray([+0.20, -0.20])\n",
    "\n",
    "minimize(objective, knobs, method='Nelder-Mead')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a641003a-ec1b-4ea1-8a46-fcde2f2d52aa",
   "metadata": {},
   "source": [
    "# Example-02: Workflow (MADX)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0496604d-6bd4-4d4c-a840-ece3c4172509",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "\n",
    "from model.external import load_lattice\n",
    "from model.external import rift_lattice\n",
    "from model.external import text_lattice\n",
    "from model.external import load_tfs\n",
    "from model.external import convert\n",
    "from model.external import add_rc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7133deed-c534-49c0-8d0f-af1f4c8eae5a",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR: DRIFT, L=2.0;\n",
      "BM: SBEND, L=1.0, ANGLE=0.17453292519943295;\n",
      "QF: QUADRUPOLE, L=1.0, K1=+0.2;\n",
      "QD: QUADRUPOLE, L=0.5, K1=-0.2;\n",
      "\n",
      "M: MONITOR,;\n",
      "\n",
      "HEAD: MARKER,; ! TEST: DRIFT,\n",
      "TAIL: MARKER,; ! TEST: DRIFT,\n",
      "\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL) ;\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Given some initial MADX lattice file (FODO)\n",
    "\n",
    "file = Path('initial.madx')\n",
    "\n",
    "with file.open('r') as stream:\n",
    "    print(stream.read())\n",
    "\n",
    "# Several regular elements are defined\n",
    "# HEAD and TAIL should appear as the first and the last elements\n",
    "# All elements should be defined on a single line with numerical parameters\n",
    "# Lattice should be defined using lines\n",
    "# Comma after element type is mandatory\n",
    "# Comments appearing after definitions should also represent an element definition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "532260b3-b100-4f18-807b-751bca5d3671",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR {'KIND': 'DRIFT', 'RC': '', 'L': 2.0}\n",
      "BM {'KIND': 'SBEND', 'RC': '', 'L': 1.0, 'ANGLE': 0.17453292519943295}\n",
      "QF {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 1.0, 'K1': 0.2}\n",
      "QD {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 0.5, 'K1': -0.2}\n",
      "M {'KIND': 'MONITOR', 'RC': ''}\n",
      "HEAD {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "TAIL {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# If element and beamline definitions comply with the above requirements\n",
    "# The lattice file can be loaded as a python dictionary\n",
    "\n",
    "lattice = load_lattice(file)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)\n",
    "\n",
    "# For each element and beamline, a key-value pair in created\n",
    "# Value is itself a dictionary containing all information about the original elements\n",
    "# Each element parameter is casted from string to int, float or string\n",
    "# Comment after element definition is saved into RC (it has a special use case, see below)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "fd93d303-6a15-4462-ad1a-520c7b706e58",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONITOR', 'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]}\n",
      "H_DR {'KIND': 'DRIFT', 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARKER', 'RC': ['BM', {'KIND': 'SBEND', 'L': 1.0, 'ANGLE': 0.17453292519943295}]}\n",
      "H_BM {'KIND': 'SBEND', 'L': 0.5, 'ANGLE': 0.08726646259971647}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "V_QF {'KIND': 'MARKER', 'RC': ['QF', {'KIND': 'QUADRUPOLE', 'L': 1.0, 'K1': 0.2}]}\n",
      "H_QF {'KIND': 'QUADRUPOLE', 'L': 0.5, 'K1': 0.2}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "QD {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 0.5, 'K1': -0.2}\n",
      "M {'KIND': 'MONITOR', 'RC': ''}\n",
      "HEAD {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "TAIL {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Error lattice is defined by a set of linear transformations between selected locations\n",
    "# Each locations can be a MONITOR (beam observation) or a VIRTUAL (error)\n",
    "# Two special locatons (HEAD and TAIL) should present in the lattice\n",
    "# Using the above dictionary representation, new observation locations can be inserted\n",
    "# Locations are inserted at the middle of selected elements (selected by type or name)\n",
    "# Selected elements are splitted in half and renamed, old names are binded to beamlines\n",
    "# Original element definitions are added to created location RC\n",
    "# Typicaly, monitor locations correspond to MONITOR elements, but new monitor elements can be also inserted\n",
    "# Virtual locations can be inserted into quadrupole or other elements to represent errors\n",
    "\n",
    "lattice = rift_lattice(lattice, \n",
    "                       'MONITOR', \n",
    "                       'MARKER', \n",
    "                       ['DRIFT'], \n",
    "                       ['SBEND', 'QUADRUPOLE'], \n",
    "                       exclude_virtual=['QD'])\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "eac1cbc9-90b3-420e-84ce-c328fdc48b43",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR: MONITOR,; ! DR: DRIFT, L=2.0,;\n",
      "H_DR: DRIFT, L=1.0,;\n",
      "DR: LINE=(H_DR, M_DR, H_DR);\n",
      "V_BM: MARKER,; ! BM: SBEND, L=1.0, ANGLE=0.17453292519943295,;\n",
      "H_BM: SBEND, L=0.5, ANGLE=0.08726646259971647,;\n",
      "BM: LINE=(H_BM, V_BM, H_BM);\n",
      "V_QF: MARKER,; ! QF: QUADRUPOLE, L=1.0, K1=0.2,;\n",
      "H_QF: QUADRUPOLE, L=0.5, K1=0.2,;\n",
      "QF: LINE=(H_QF, V_QF, H_QF);\n",
      "QD: QUADRUPOLE, L=0.5, K1=-0.2,;\n",
      "M: MONITOR,;\n",
      "HEAD: MARKER,; ! TEST: DRIFT,\n",
      "TAIL: MARKER,; ! TEST: DRIFT,\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL);\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Modified lattice can be converted to text\n",
    "# Comments are added to locations while original comments are preserved\n",
    "\n",
    "text = text_lattice('MADX', lattice, rc=True)\n",
    "\n",
    "print(text)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "0c98bea9-c894-4aed-8d62-97270eb048b2",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Compute TWISS parameters using MADX\n",
    "# TWISS command is appended to modified lattice\n",
    "\n",
    "task = \"\"\"\n",
    "BEAM;\n",
    "USE, PERIOD=FODO;\n",
    "SET,FORMAT=\"20.20f\",\"-20s\";\n",
    "TWISS;\n",
    "WRITE,TABLE=TWISS,FILE=\"final.tfs\";\n",
    "RETURN;\n",
    "\"\"\" ;\n",
    "\n",
    "with Path('final.madx').open('w') as stream:\n",
    "    stream.write(text)\n",
    "    stream.write(task)\n",
    "\n",
    "!madx final.madx > /dev/null"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "3b46c59b-7001-4e0c-aa22-840f3a7302a8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONITOR', 'RC': ['DR', {'KIND': 'DRIFT', 'RC': '', 'L': 2.0}]}\n",
      "H_DR {'KIND': 'DRIFT', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARKER', 'RC': ['BM', {'KIND': 'SBEND', 'RC': '', 'L': 1.0, 'ANGLE': 0.17453292519943295}]}\n",
      "H_BM {'KIND': 'SBEND', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 0.5, 'ANGLE': 0.08726646259971647}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "V_QF {'KIND': 'MARKER', 'RC': ['QF', {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 1.0, 'K1': 0.2}]}\n",
      "H_QF {'KIND': 'QUADRUPOLE', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 0.5, 'K1': 0.2}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "QD {'KIND': 'QUADRUPOLE', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 0.5, 'K1': -0.2}\n",
      "M {'KIND': 'MONITOR', 'RC': ['', {'KIND': '', 'RC': ''}]}\n",
      "HEAD {'KIND': 'MARKER', 'RC': ['TEST', {'KIND': 'DRIFT', 'RC': ''}]}\n",
      "TAIL {'KIND': 'MARKER', 'RC': ['TEST', {'KIND': 'DRIFT', 'RC': ''}]}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Load lattice can be also loaded from file\n",
    "# Original comments will be parsed as elements (look at HEAD and TAIL)\n",
    "# Empty RC will be nested in this case\n",
    "\n",
    "file = Path('final.madx')\n",
    "\n",
    "with file.open('w') as stream:\n",
    "    stream.write(text)\n",
    "\n",
    "lattice = load_lattice(file, rc=True)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "dab4b669-0bfe-47ce-873d-51f064d98ec6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# TWISS results can be loaded into python dictionaries\n",
    "\n",
    "data = Path('final.tfs')\n",
    "parameters, columns = load_tfs(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "2ad82e92-25fe-4f44-bdb1-8709c3cf2570",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'TYPE': 'VIRTUAL',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M': {'TYPE': 'MONITOR',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M_DR': {'TYPE': 'MONITOR',\n",
       "  'S': 1.5,\n",
       "  'BX': 5.980356480296974,\n",
       "  'AX': -0.8524040348462865,\n",
       "  'FX': 0.3068185833848285,\n",
       "  'BY': 15.315159900296642,\n",
       "  'AY': 1.6491678474974667,\n",
       "  'FY': 0.08453149247893033,\n",
       "  'DQX': 1.744126900814982,\n",
       "  'DPX': 0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'V_BM': {'TYPE': 'VIRTUAL',\n",
       "  'S': 3.0,\n",
       "  'BX': 9.120629409698159,\n",
       "  'AX': -1.1465687400023221,\n",
       "  'FX': 0.5107301354647854,\n",
       "  'BY': 10.914137614299745,\n",
       "  'AY': 1.2848470098337954,\n",
       "  'FY': 0.20081415045191314,\n",
       "  'DQX': 1.992896582518225,\n",
       "  'DPX': 0.21385269164968151,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'M_DR_1': {'TYPE': 'MONITOR',\n",
       "  'S': 4.5,\n",
       "  'BX': 12.70896979457465,\n",
       "  'AX': -1.3363966727488819,\n",
       "  'FX': 0.6500917125372264,\n",
       "  'BY': 7.606077841293864,\n",
       "  'AY': 0.9205261721701236,\n",
       "  'FY': 0.3661997931359615,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': 0.26987963222618605,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'V_QF': {'TYPE': 'VIRTUAL',\n",
       "  'S': 6.0,\n",
       "  'BX': 16.392007194825762,\n",
       "  'AX': -8.0415e-16,\n",
       "  'FX': 0.7521811118347426,\n",
       "  'BY': 5.674619594695141,\n",
       "  'AY': -2.5871e-16,\n",
       "  'FY': 0.601131166393595,\n",
       "  'DQX': 2.7214181783177667,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'M_DR_2': {'TYPE': 'MONITOR',\n",
       "  'S': 7.5,\n",
       "  'BX': 12.708969794574653,\n",
       "  'AX': 1.336396672748881,\n",
       "  'FX': 0.8542705111322586,\n",
       "  'BY': 7.606077841293868,\n",
       "  'AY': -0.9205261721701244,\n",
       "  'FY': 0.8360625396512283,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': -0.26987963222618594,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'V_BM_1': {'TYPE': 'VIRTUAL',\n",
       "  'S': 9.0,\n",
       "  'BX': 9.120629409698164,\n",
       "  'AX': 1.146568740002322,\n",
       "  'FX': 0.9936320882046995,\n",
       "  'BY': 10.914137614299747,\n",
       "  'AY': -1.2848470098337954,\n",
       "  'FY': 1.0014481823352765,\n",
       "  'DQX': 1.9928965825182252,\n",
       "  'DPX': -0.21385269164968146,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'M_DR_3': {'TYPE': 'MONITOR',\n",
       "  'S': 10.5,\n",
       "  'BX': 5.980356480296976,\n",
       "  'AX': 0.8524040348462865,\n",
       "  'FX': 1.1975436402846564,\n",
       "  'BY': 15.315159900296639,\n",
       "  'AY': -1.6491678474974665,\n",
       "  'FY': 1.1177308403082595,\n",
       "  'DQX': 1.7441269008149822,\n",
       "  'DPX': -0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'TAIL': {'TYPE': 'VIRTUAL',\n",
       "  'S': 12.0,\n",
       "  'BX': 4.287017735718939,\n",
       "  'AX': 3.6486e-16,\n",
       "  'FX': 1.5043622236694847,\n",
       "  'BY': 19.81848928204488,\n",
       "  'AY': -5.5051e-16,\n",
       "  'FY': 1.2022623327871897,\n",
       "  'DQX': 1.54904104413488,\n",
       "  'DPX': -2.776e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Optics data can be converted into model table\n",
    "# Note, all locations have different name\n",
    "# If an element appear several times in a line, locations are renamed\n",
    "\n",
    "table = convert(columns, 'TFS', ['MONITOR'], ['MARKER'], rc=True)\n",
    "table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "1fefa5f3-e614-4e22-91ff-b21e28e4aeeb",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'TYPE': 'VIRTUAL',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M': {'TYPE': 'MONITOR',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M_DR': {'TYPE': 'MONITOR',\n",
       "  'S': 1.5,\n",
       "  'BX': 5.980356480296974,\n",
       "  'AX': -0.8524040348462865,\n",
       "  'FX': 0.3068185833848285,\n",
       "  'BY': 15.315159900296642,\n",
       "  'AY': 1.6491678474974667,\n",
       "  'FY': 0.08453149247893033,\n",
       "  'DQX': 1.744126900814982,\n",
       "  'DPX': 0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'V_BM': {'TYPE': 'VIRTUAL',\n",
       "  'S': 3.0,\n",
       "  'BX': 9.120629409698159,\n",
       "  'AX': -1.1465687400023221,\n",
       "  'FX': 0.5107301354647854,\n",
       "  'BY': 10.914137614299745,\n",
       "  'AY': 1.2848470098337954,\n",
       "  'FY': 0.20081415045191314,\n",
       "  'DQX': 1.992896582518225,\n",
       "  'DPX': 0.21385269164968151,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['BM', {'KIND': 'SBEND', 'L': 1.0, 'ANGLE': 0.17453292519943295}]},\n",
       " 'M_DR_1': {'TYPE': 'MONITOR',\n",
       "  'S': 4.5,\n",
       "  'BX': 12.70896979457465,\n",
       "  'AX': -1.3363966727488819,\n",
       "  'FX': 0.6500917125372264,\n",
       "  'BY': 7.606077841293864,\n",
       "  'AY': 0.9205261721701236,\n",
       "  'FY': 0.3661997931359615,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': 0.26987963222618605,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'V_QF': {'TYPE': 'VIRTUAL',\n",
       "  'S': 6.0,\n",
       "  'BX': 16.392007194825762,\n",
       "  'AX': -8.0415e-16,\n",
       "  'FX': 0.7521811118347426,\n",
       "  'BY': 5.674619594695141,\n",
       "  'AY': -2.5871e-16,\n",
       "  'FY': 0.601131166393595,\n",
       "  'DQX': 2.7214181783177667,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['QF', {'KIND': 'QUADRUPOLE', 'L': 1.0, 'K1': 0.2}]},\n",
       " 'M_DR_2': {'TYPE': 'MONITOR',\n",
       "  'S': 7.5,\n",
       "  'BX': 12.708969794574653,\n",
       "  'AX': 1.336396672748881,\n",
       "  'FX': 0.8542705111322586,\n",
       "  'BY': 7.606077841293868,\n",
       "  'AY': -0.9205261721701244,\n",
       "  'FY': 0.8360625396512283,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': -0.26987963222618594,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'V_BM_1': {'TYPE': 'VIRTUAL',\n",
       "  'S': 9.0,\n",
       "  'BX': 9.120629409698164,\n",
       "  'AX': 1.146568740002322,\n",
       "  'FX': 0.9936320882046995,\n",
       "  'BY': 10.914137614299747,\n",
       "  'AY': -1.2848470098337954,\n",
       "  'FY': 1.0014481823352765,\n",
       "  'DQX': 1.9928965825182252,\n",
       "  'DPX': -0.21385269164968146,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['BM', {'KIND': 'SBEND', 'L': 1.0, 'ANGLE': 0.17453292519943295}]},\n",
       " 'M_DR_3': {'TYPE': 'MONITOR',\n",
       "  'S': 10.5,\n",
       "  'BX': 5.980356480296976,\n",
       "  'AX': 0.8524040348462865,\n",
       "  'FX': 1.1975436402846564,\n",
       "  'BY': 15.315159900296639,\n",
       "  'AY': -1.6491678474974665,\n",
       "  'FY': 1.1177308403082595,\n",
       "  'DQX': 1.7441269008149822,\n",
       "  'DPX': -0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'TAIL': {'TYPE': 'VIRTUAL',\n",
       "  'S': 12.0,\n",
       "  'BX': 4.287017735718939,\n",
       "  'AX': 3.6486e-16,\n",
       "  'FX': 1.5043622236694847,\n",
       "  'BY': 19.81848928204488,\n",
       "  'AY': -5.5051e-16,\n",
       "  'FY': 1.2022623327871897,\n",
       "  'DQX': 1.54904104413488,\n",
       "  'DPX': -2.776e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# RC parameter from lattice data can be added to model table\n",
    "# Configuration table can be saved using util.save\n",
    "\n",
    "table = add_rc(table, lattice)\n",
    "table"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "70706793-5a95-4598-8d45-2208eb0a54fd",
   "metadata": {},
   "source": [
    "# Example-03: Workflow (ELEGANT)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "c7155f5d-e16a-4374-979a-b3477eee7a55",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "\n",
    "from model.external import load_lattice\n",
    "from model.external import rift_lattice\n",
    "from model.external import text_lattice\n",
    "from model.external import load_sdds\n",
    "from model.external import convert\n",
    "from model.external import add_rc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7f0167ee-1eb5-4a03-a06e-c6256c2f08a2",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR: DRIF,l=2\n",
      "\n",
      "BM: CSBEND,angle=0.17453292519943295,fint=0,l=1.0\n",
      "QD: QUAD,k1=-0.2,l=0.5\n",
      "QF: QUAD,k1=0.2,l=1.0\n",
      "\n",
      "M: MONI,\n",
      "\n",
      "HEAD: MARK, ! TEST: DRIF,\n",
      "TAIL: MARK, ! TEST: DRIF,\n",
      "\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL)\n"
     ]
    }
   ],
   "source": [
    "# Given some initial ELEGANT lattice file (FODO)\n",
    "\n",
    "file = Path('initial.lte')\n",
    "\n",
    "with file.open('r') as stream:\n",
    "    print(stream.read())\n",
    "\n",
    "# Several regular elements are defined\n",
    "# HEAD and TAIL should appear as the first and the last elements\n",
    "# All elements should be defined on a single line with numerical parameters\n",
    "# Lattice should be defined using lines\n",
    "# Comma after element type is mandatory\n",
    "# Comments appearing after definitions should also represent an element definition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "39ce25e6-47b7-4ec8-960c-b21b60fd99d6",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR {'KIND': 'DRIF', 'RC': '', 'L': 2}\n",
      "BM {'KIND': 'CSBEND', 'RC': '', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}\n",
      "QD {'KIND': 'QUAD', 'RC': '', 'K1': -0.2, 'L': 0.5}\n",
      "QF {'KIND': 'QUAD', 'RC': '', 'K1': 0.2, 'L': 1.0}\n",
      "M {'KIND': 'MONI', 'RC': ''}\n",
      "HEAD {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "TAIL {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# If element and beamline definitions comply with the above requirements\n",
    "# The lattice file can be loaded as a python dictionary\n",
    "\n",
    "lattice = load_lattice(file)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)\n",
    "\n",
    "# For each element and beamline, a key-value pair in created\n",
    "# Value is itself a dictionary containing all information about the original elements\n",
    "# Each element parameter is casted from string to int, float or string\n",
    "# Comment after element definition is saved into RC (it has a special use case, see below)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e0b8b369-29dc-4dc8-859b-658a0a17545e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONI', 'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]}\n",
      "H_DR {'KIND': 'DRIF', 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARK', 'RC': ['BM', {'KIND': 'CSBEND', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]}\n",
      "H_BM {'KIND': 'CSBEND', 'ANGLE': 0.08726646259971647, 'FINT': 0, 'L': 0.5}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "QD {'KIND': 'QUAD', 'RC': '', 'K1': -0.2, 'L': 0.5}\n",
      "V_QF {'KIND': 'MARK', 'RC': ['QF', {'KIND': 'QUAD', 'K1': 0.2, 'L': 1.0}]}\n",
      "H_QF {'KIND': 'QUAD', 'K1': 0.2, 'L': 0.5}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "M {'KIND': 'MONI', 'RC': ''}\n",
      "HEAD {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "TAIL {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Error lattice is defined by a set of linear transformations between selected locations\n",
    "# Each locations can be a MONITOR (beam observation) or a VIRTUAL (error)\n",
    "# Two special locatons (HEAD and TAIL) should present in the lattice\n",
    "# Using the above dictionary representation, new observation locations can be inserted\n",
    "# Locations are inserted at the middle of selected elements (selected by type or name)\n",
    "# Selected elements are splitted in half and renamed, old names are binded to beamlines\n",
    "# Original element definitions are added to created location RC\n",
    "# Typicaly, monitor locations correspond to MONITOR elements, but new monitor elements can be also inserted\n",
    "# Virtual locations can be inserted into quadrupole or other elements to represent errors\n",
    "\n",
    "lattice = rift_lattice(lattice, \n",
    "                       'MONI', \n",
    "                       'MARK', \n",
    "                       ['DRIF'], \n",
    "                       ['CSBEND', 'QUAD'], \n",
    "                       exclude_virtual=['QD'])\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e7f72d66-2ac0-4a6f-b12d-45410acd13f5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR: MONI, ! DR: DRIF, L=2,\n",
      "H_DR: DRIF, L=1.0,\n",
      "DR: LINE=(H_DR, M_DR, H_DR)\n",
      "V_BM: MARK, ! BM: CSBEND, ANGLE=0.17453292519943295, FINT=0, L=1.0,\n",
      "H_BM: CSBEND, ANGLE=0.08726646259971647, FINT=0, L=0.5,\n",
      "BM: LINE=(H_BM, V_BM, H_BM)\n",
      "QD: QUAD, K1=-0.2, L=0.5,\n",
      "V_QF: MARK, ! QF: QUAD, K1=0.2, L=1.0,\n",
      "H_QF: QUAD, K1=0.2, L=0.5,\n",
      "QF: LINE=(H_QF, V_QF, H_QF)\n",
      "M: MONI,\n",
      "HEAD: MARK, ! TEST: DRIF,\n",
      "TAIL: MARK, ! TEST: DRIF,\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Modified lattice can be converted to text\n",
    "# Comments are added to locations while original comments are preserved\n",
    "\n",
    "text = text_lattice('LTE', lattice, rc=True)\n",
    "\n",
    "print(text)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "4ec13d02-ae33-4d58-ade9-125c00fcc90a",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Compute TWISS parameters using ELEGANT\n",
    "# Separate command file is created\n",
    "\n",
    "with Path('final.lte').open('w') as stream:\n",
    "    stream.write(text)\n",
    "\n",
    "task = \"\"\"\n",
    "&run_setup\n",
    "  use_beamline=\"FODO\",\n",
    "  lattice = \"final.lte\",\n",
    "  p_central_mev = 1000\n",
    "&end\n",
    "\n",
    "&run_control\n",
    "&end\n",
    "\n",
    "&twiss_output\n",
    "  filename = \"binary.twiss\",\n",
    "  output_at_each_step = 1\n",
    "&end\n",
    "\n",
    "&bunched_beam\n",
    "&end\n",
    "\n",
    "&track\n",
    "&end\n",
    "\"\"\" ;\n",
    "\n",
    "with Path('final.ele').open('w') as stream:\n",
    "    stream.write(task)\n",
    "\n",
    "!elegant final.ele > /dev/null\n",
    "!sddsconvert -ascii binary.twiss final.twiss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "86013097-d261-486b-b2af-35f9604b6351",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONI', 'RC': ['DR', {'KIND': 'DRIF', 'RC': '', 'L': 2}]}\n",
      "H_DR {'KIND': 'DRIF', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARK', 'RC': ['BM', {'KIND': 'CSBEND', 'RC': '', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]}\n",
      "H_BM {'KIND': 'CSBEND', 'RC': ['', {'KIND': '', 'RC': ''}], 'ANGLE': 0.08726646259971647, 'FINT': 0, 'L': 0.5}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "QD {'KIND': 'QUAD', 'RC': ['', {'KIND': '', 'RC': ''}], 'K1': -0.2, 'L': 0.5}\n",
      "V_QF {'KIND': 'MARK', 'RC': ['QF', {'KIND': 'QUAD', 'RC': '', 'K1': 0.2, 'L': 1.0}]}\n",
      "H_QF {'KIND': 'QUAD', 'RC': ['', {'KIND': '', 'RC': ''}], 'K1': 0.2, 'L': 0.5}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "M {'KIND': 'MONI', 'RC': ['', {'KIND': '', 'RC': ''}]}\n",
      "HEAD {'KIND': 'MARK', 'RC': ['TEST', {'KIND': 'DRIF', 'RC': ''}]}\n",
      "TAIL {'KIND': 'MARK', 'RC': ['TEST', {'KIND': 'DRIF', 'RC': ''}]}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Load lattice can be also loaded from file\n",
    "# Original comments will be parsed as elements (look at HEAD and TAIL)\n",
    "# Empty RC will be nested in this case\n",
    "\n",
    "file = Path('final.lte')\n",
    "\n",
    "with file.open('w') as stream:\n",
    "    stream.write(text)\n",
    "\n",
    "lattice = load_lattice(file, rc=True)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "e299a720-b7ad-4cbb-b281-014ad87322fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# TWISS results can be loaded into python dictionaries\n",
    "\n",
    "data = Path('final.twiss')\n",
    "parameters, columns = load_sdds(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "8cd4345e-effb-48f1-ad46-c824e242d55f",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'M_DR': {'S': 1.5,\n",
       "  'BX': 5.980356479284525,\n",
       "  'AX': -0.8524040348212205,\n",
       "  'FX': 0.3068185834444499,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': 0.1561981825607101,\n",
       "  'BY': 15.31515988971357,\n",
       "  'AY': 1.649167846239909,\n",
       "  'FY': 0.08453149253790615,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'V_BM': {'S': 3.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': -1.146568740048648,\n",
       "  'FX': 0.5107301355818847,\n",
       "  'DQX': 1.99289632225274,\n",
       "  'DPX': 0.2138526637243729,\n",
       "  'BY': 10.91413760701325,\n",
       "  'AY': 1.284847009200138,\n",
       "  'FY': 0.2008141505892614,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M_DR_1': {'S': 4.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': -1.336396672789745,\n",
       "  'FX': 0.6500917126795847,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': 0.2698795969893243,\n",
       "  'BY': 7.606077834992553,\n",
       "  'AY': 0.9205261718281931,\n",
       "  'FY': 0.3661997933967667,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'V_QF': {'S': 6.0,\n",
       "  'BX': 16.39200719526896,\n",
       "  'AX': 3.608224830031759e-16,\n",
       "  'FX': 0.7521811119743597,\n",
       "  'DQX': 2.721417822995524,\n",
       "  'DPX': -5.551115123125783e-17,\n",
       "  'BY': 5.674619589422572,\n",
       "  'AY': 8.326672684688672e-16,\n",
       "  'FY': 0.6011311668647427,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M_DR_2': {'S': 7.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': 1.336396672789746,\n",
       "  'FX': 0.8542705112691347,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': -0.2698795969893243,\n",
       "  'BY': 7.606077834992548,\n",
       "  'AY': -0.920526171828191,\n",
       "  'FY': 0.8360625403327188,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'V_BM_1': {'S': 9.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': 1.146568740048649,\n",
       "  'FX': 0.9936320883668346,\n",
       "  'DQX': 1.992896322252739,\n",
       "  'DPX': -0.2138526637243729,\n",
       "  'BY': 10.91413760701323,\n",
       "  'AY': -1.284847009200136,\n",
       "  'FY': 1.001448183140224,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M_DR_3': {'S': 10.5,\n",
       "  'BX': 5.980356479284523,\n",
       "  'AX': 0.852404034821221,\n",
       "  'FX': 1.197543640504269,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': -0.1561981825607101,\n",
       "  'BY': 15.31515988971355,\n",
       "  'AY': -1.649167846239906,\n",
       "  'FY': 1.11773084119158,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'TAIL': {'S': 12.0,\n",
       "  'BX': 4.287017734831201,\n",
       "  'AX': 5.273559366969493e-16,\n",
       "  'FX': 1.50436222394872,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': -1.110223024625157e-16,\n",
       "  'BY': 19.81848926815184,\n",
       "  'AY': 1.387778780781446e-16,\n",
       "  'FY': 1.202262333729486,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Optics data can be converted into model table\n",
    "# Note, all locations have different name\n",
    "# If an element appear several times in a line, locations are renamed\n",
    "\n",
    "table = convert(columns, 'SDDS', ['MONI'], ['MARK'], rc=True)\n",
    "table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "f6d4a121-8d34-4db1-8c09-dbb1fd13317a",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'M_DR': {'S': 1.5,\n",
       "  'BX': 5.980356479284525,\n",
       "  'AX': -0.8524040348212205,\n",
       "  'FX': 0.3068185834444499,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': 0.1561981825607101,\n",
       "  'BY': 15.31515988971357,\n",
       "  'AY': 1.649167846239909,\n",
       "  'FY': 0.08453149253790615,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'V_BM': {'S': 3.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': -1.146568740048648,\n",
       "  'FX': 0.5107301355818847,\n",
       "  'DQX': 1.99289632225274,\n",
       "  'DPX': 0.2138526637243729,\n",
       "  'BY': 10.91413760701325,\n",
       "  'AY': 1.284847009200138,\n",
       "  'FY': 0.2008141505892614,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': ['BM',\n",
       "   {'KIND': 'CSBEND', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]},\n",
       " 'M_DR_1': {'S': 4.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': -1.336396672789745,\n",
       "  'FX': 0.6500917126795847,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': 0.2698795969893243,\n",
       "  'BY': 7.606077834992553,\n",
       "  'AY': 0.9205261718281931,\n",
       "  'FY': 0.3661997933967667,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'V_QF': {'S': 6.0,\n",
       "  'BX': 16.39200719526896,\n",
       "  'AX': 3.608224830031759e-16,\n",
       "  'FX': 0.7521811119743597,\n",
       "  'DQX': 2.721417822995524,\n",
       "  'DPX': -5.551115123125783e-17,\n",
       "  'BY': 5.674619589422572,\n",
       "  'AY': 8.326672684688672e-16,\n",
       "  'FY': 0.6011311668647427,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': ['QF', {'KIND': 'QUAD', 'K1': 0.2, 'L': 1.0}]},\n",
       " 'M_DR_2': {'S': 7.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': 1.336396672789746,\n",
       "  'FX': 0.8542705112691347,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': -0.2698795969893243,\n",
       "  'BY': 7.606077834992548,\n",
       "  'AY': -0.920526171828191,\n",
       "  'FY': 0.8360625403327188,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'V_BM_1': {'S': 9.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': 1.146568740048649,\n",
       "  'FX': 0.9936320883668346,\n",
       "  'DQX': 1.992896322252739,\n",
       "  'DPX': -0.2138526637243729,\n",
       "  'BY': 10.91413760701323,\n",
       "  'AY': -1.284847009200136,\n",
       "  'FY': 1.001448183140224,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': ['BM',\n",
       "   {'KIND': 'CSBEND', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]},\n",
       " 'M_DR_3': {'S': 10.5,\n",
       "  'BX': 5.980356479284523,\n",
       "  'AX': 0.852404034821221,\n",
       "  'FX': 1.197543640504269,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': -0.1561981825607101,\n",
       "  'BY': 15.31515988971355,\n",
       "  'AY': -1.649167846239906,\n",
       "  'FY': 1.11773084119158,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'TAIL': {'S': 12.0,\n",
       "  'BX': 4.287017734831201,\n",
       "  'AX': 5.273559366969493e-16,\n",
       "  'FX': 1.50436222394872,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': -1.110223024625157e-16,\n",
       "  'BY': 19.81848926815184,\n",
       "  'AY': 1.387778780781446e-16,\n",
       "  'FY': 1.202262333729486,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# RC parameter from lattice data can be added to model table\n",
    "# Configuration table can be saved using util.save\n",
    "\n",
    "table = add_rc(table, lattice)\n",
    "table"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4604a99e-2f05-4693-85f2-f0ea61312fd6",
   "metadata": {},
   "source": [
    "# Example-04: Transformations benchmark (PTC)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "080a6c07-fab4-4a55-96dd-6276bb36237a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# In this example various symplectic transformations are compared with corresponding MADX-PTC transformations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "bdb8e52a-634f-42c3-9628-603df039e0e5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.005, -0.01, 0.005]\n",
      "[0.010000000000000002, -0.005, -0.010000000000000002, 0.005]\n",
      "[-1.734723475976807e-18, 0.0, 1.734723475976807e-18, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# calibration\n",
    "\n",
    "import torch\n",
    "\n",
    "from model.library.transformations import calibration_forward\n",
    "from model.library.transformations import calibration_inverse\n",
    "\n",
    "gxx = torch.tensor(1.005, dtype=torch.float64)\n",
    "gxy = torch.tensor(0.001, dtype=torch.float64)\n",
    "gyx = torch.tensor(0.005, dtype=torch.float64)\n",
    "gyy = torch.tensor(0.955, dtype=torch.float64)\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "res = calibration_forward(state, gxx, gxy, gyx, gyy)\n",
    "res = calibration_inverse(res, gxx, gxy, gyx, gyy)\n",
    "\n",
    "print(state.tolist()) \n",
    "print(res.tolist())\n",
    "print((state - res).tolist()) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "4d5b5046-cafc-45b0-824d-4ab2d787ac68",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005024875621890547, -0.005, -0.005024875621890547, 0.005]\n",
      "[0.005024875621890547, -0.005, -0.005024875621890547, 0.005]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# drift\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import drift\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length.item()} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = drift(state, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "9b7001fe-8e1e-49e1-9eae-31ab093ca099",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005024752473723395, -0.005, -0.005024752473723395, 0.005]\n",
      "[0.005024752473723394, -0.005, -0.005024752473723394, 0.005]\n",
      "[8.673617379884035e-19, 0.0, -8.673617379884035e-19, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# drift (with kinematic)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import drift\n",
    "from model.library.transformations import kinematic\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length.item()} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "state = drift(state, dp, length)\n",
    "state = kinematic(state, dp, length)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "91fd9e07-7966-4ca9-8c0f-2da9b966c091",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, -0.1, 0.0, 0.1]\n",
      "[0.0, -0.1, 0.0, 0.1]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# corrector\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import corrector\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "kx = -torch.tensor(0.1, dtype=torch.float64)\n",
    "ky = +torch.tensor(0.1, dtype=torch.float64)\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "magx:hkicker,l=0.0,kick={kx.item()};\n",
    "magy:vkicker,l=0.0,kick={ky.item()};\n",
    "map:line=(magx, magy) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = corrector(state, kx, ky)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "70c04db2-1d10-4d61-b82c-0a0c7e294ef9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0012338134845463512, -0.011134185772061586, -0.009559363509475737, -0.004042070986490389]\n",
      "[0.0012338134845463642, -0.01113418577206157, -0.009559363509475702, -0.0040420709864903495]\n",
      "[-1.3010426069826053e-17, -1.5612511283791264e-17, -3.469446951953614e-17, -3.9898639947466563e-17]\n"
     ]
    }
   ],
   "source": [
    "# focusing quadrupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import fquad\n",
    "\n",
    "kn = torch.tensor(1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length.item()}, k1={kn.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = fquad(state, kn.abs(), dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b2856de4-d7ff-4b08-9a71-2ff691c14770",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009559363509475737, 0.004042070986490389, -0.0012338134845463512, 0.011134185772061586]\n",
      "[0.009559363509475702, 0.0040420709864903495, -0.0012338134845463642, 0.01113418577206157]\n",
      "[3.469446951953614e-17, 3.9898639947466563e-17, 1.3010426069826053e-17, 1.5612511283791264e-17]\n"
     ]
    }
   ],
   "source": [
    "# defocusing quadrupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import dquad\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length.item()}, k1={kn.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = dquad(state, kn.abs(), dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "79f546f6-73cc-4e29-88d8-28571c7ab15c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00576876084434182, -0.0020884471766207963, 0.002582224887596925, 0.017416187766128223]\n",
      "[0.005768760844341825, -0.0020884471766207725, 0.0025822248875969544, 0.0174161877661282]\n",
      "[-5.204170427930421e-18, -2.3852447794681098e-17, -2.949029909160572e-17, 2.42861286636753e-17]\n"
     ]
    }
   ],
   "source": [
    "# generic quadrupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import quadrupole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(+1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: quadrupole, l={length.item()},k1={kn.item()},k1s={ks.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = quadrupole(state, kn, ks, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "7d079fa0-3bf2-4b11-b44e-e7cc7abb4b6b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005768760844341825, -0.0020884471766207725, 0.0025822248875969544, 0.0174161877661282]\n",
      "[0.005768760844341825, -0.0020884471766207725, 0.0025822248875969544, 0.0174161877661282]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# generic linear transformation\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import quadrupole\n",
    "from model.library.transformations import linear\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(+1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "vector = torch.zeros_like(state)\n",
    "matrix = torch.func.jacrev(quadrupole)(0.0*state, kn, ks, dp, length)\n",
    "\n",
    "ref = quadrupole(state, kn, ks, dp, length)\n",
    "res = linear(state, vector, matrix)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "3a088826-da54-4bd5-9df5-f7a88d4b0c1e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.07, -0.05, -0.06400000000000002]\n",
      "[0.01, -0.07, -0.05, -0.06400000000000002]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# quadrupole kick\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import gradient\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(1.5, dtype=torch.float64)\n",
    "ks = torch.tensor(1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.05, 0.001], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,{(kn*length).item()}}},ksl={{0.0,{(ks*length).item()}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = gradient(state, kn, ks, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "5295eaba-09a7-45b8-9a89-b821b837c760",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.0044, -0.05, 0.00075]\n",
      "[0.01, -0.0044, -0.05, 0.00075]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# sextupole kick\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sextupole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.05, 0.001], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,0.0,{(ks*length).item()}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = sextupole(state, ks, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "be76c431-62ec-4d08-b33f-dcc3840ae08a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.004938333333333334, -0.05, 0.0010916666666666668]\n",
      "[0.01, -0.004938333333333334, -0.05, 0.0010916666666666668]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# octupole kick\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import octupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "ko = torch.tensor(5.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.05, 0.001], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,0.0,0.0,{(ko*length).item()}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = octupole(state, ko, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "f5b562d5-b7ca-4fea-b3ab-0103a626c69c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005231962156363519, -0.004575808017791941, -0.005024875621890682, 0.005]\n",
      "[0.005231962156363559, -0.004575808017791928, -0.005024875621890547, 0.005]\n",
      "[-3.9898639947466563e-17, -1.3010426069826053e-17, -1.3530843112619095e-16, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# pure dipole (no edge effects if e1 = e2 = 0)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import dipole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64 )\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sbend, l={length.item()}, angle={angle.item()},k1=0.0,k1s=0.0,e1=0.0,e2=0.0,kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = dipole(state, length/angle, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "98063db1-6987-4852-9732-3e4983fae16b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.007795176039169286, 0.0011097346020520168, 0.0007677684542948365, 0.01462661777023533]\n",
      "[0.0077951760391692755, 0.0011097346020520064, 0.0007677684542948021, 0.014626617770235346]\n",
      "[1.0408340855860843e-17, 1.0408340855860843e-17, 3.436920886779049e-17, -1.5612511283791264e-17]\n"
     ]
    }
   ],
   "source": [
    "# combined function dipole (no edge effects if e1 = e2 = 0)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import bend\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64 )\n",
    "ks = torch.tensor(0.5, dtype=torch.float64 )\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sbend, l={length.item()}, angle={angle.item()},k1={kn.item()},k1s={ks.item()},e1=0.0,e2=0.0,kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = bend(state, length/angle, kn, ks, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "d3d88c90-405b-45b9-b21b-3bb9cac4fec7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.02505664248885726, 0.02888471799554683, 0.01948347950480536, 0.007752605073815676]\n",
      "[0.025056642488857035, 0.028884717995546608, 0.019483479504805307, 0.007752605073815616]\n",
      "[2.255140518769849e-16, 2.220446049250313e-16, 5.204170427930421e-17, 5.984795992119984e-17]\n"
     ]
    }
   ],
   "source": [
    "# combined function dipole with edge effects\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import bend\n",
    "from model.library.transformations import wedge\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "e1 = torch.tensor(0.02, dtype=torch.float64)\n",
    "e2 = torch.tensor(-0.03, dtype=torch.float64)\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sbend, l={length.item()}, angle={angle.item()},k1={kn.item()},k1s={ks.item()},e1={e1.item()},e2={e2.item()},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = wedge(state, e1, length/angle)\n",
    "state = bend(state, length/angle, kn + 1.0E-16, ks + 1.0E-16, dp, length)\n",
    "res = wedge(state, e2, length/angle)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "fd03af43-7b65-45a6-bea1-8306c1338494",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.08749190399027759, -0.05149961687573391, -0.05640828383591964, -0.019912883990595223]\n",
      "[-0.08749190399027745, -0.05149961687573378, -0.05640828383591953, -0.01991288399059518]\n",
      "[-1.3877787807814457e-16, -1.249000902703301e-16, -1.1102230246251565e-16, -4.163336342344337e-17]\n"
     ]
    }
   ],
   "source": [
    "# translations (exact alignment, straight layout, act on a thin representation at the entrance frame)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import drift\n",
    "from model.library.transformations import quadrupole\n",
    "from model.library.transformations import tx, ty, tz\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.015, 0.0025], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "dr: drift, l=1.0;\n",
    "mag: quadrupole, l={length.item()},k1={kn.item()},k1s={ks.item()};\n",
    "map:line=(dr, mag, dr) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "select,flag=error,pattern=\"mag\";\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()};\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = drift(state, dp, 1.0)\n",
    "state = tx(state, +dx)\n",
    "state = ty(state, +dy)\n",
    "state = tz(state, +dz, dp)\n",
    "state = quadrupole(state, kn, ks, dp, length)\n",
    "state = tz(state, -dz, dp)\n",
    "state = ty(state, -dy)\n",
    "state = tx(state, -dx)\n",
    "state = drift(state, dp, 1.0)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "46617dad-22ce-413d-8c8e-cad2bbe267a0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.19014967849021078, -0.2611883141418841, -0.10367399923762718, -0.09101974096085057]\n",
      "[-0.19014967849022751, -0.2611883141418846, -0.10367399923763249, -0.09101974096085078]\n",
      "[1.6736612096224235e-14, 4.996003610813204e-16, 5.3013149425851225e-15, 2.0816681711721685e-16]\n"
     ]
    }
   ],
   "source": [
    "# translations + rotations (exact alignment, straight layout, act on a thin representation at the entrance frame)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import quadrupole\n",
    "from model.library.transformations import tx, ty, tz\n",
    "from model.library.transformations import rx, ry, rz\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.015, 0.0025], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length.item()},k1={kn.item()},k1s={ks.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "select,flag=error,pattern=\"mag\";\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()};\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = tx(state, +dx)\n",
    "state = ty(state, +dy)\n",
    "state = tz(state, +dz, dp)\n",
    "\n",
    "state = rx(state, +wx, dp)\n",
    "state = ry(state, +wy, dp)\n",
    "state = rz(state, +wz)\n",
    "\n",
    "state = quadrupole(state, kn + 1.0E-16, ks + 1.0E-16, dp, length)\n",
    "\n",
    "state = tz(state, -length, dp)\n",
    "\n",
    "state = rz(state, -wz)\n",
    "state = ry(state, -wy, dp)\n",
    "state = rx(state, -wx, dp)\n",
    "\n",
    "state = tz(state, -dz, dp)\n",
    "state = ty(state, -dy)\n",
    "state = tx(state, -dx)\n",
    "\n",
    "state = tz(state, +length, dp)\n",
    "\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "5a207d27-c76f-4739-b615-8644cc8b9a4f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.20185873553633701, -0.27629369448112884, -0.08354566211146026, -0.06880534321809641]\n",
      "[-0.20185873553633754, -0.2762936944811289, -0.08354566211146025, -0.06880534321809621]\n",
      "[5.273559366969494e-16, 5.551115123125783e-17, -1.3877787807814457e-17, -1.942890293094024e-16]\n"
     ]
    }
   ],
   "source": [
    "# translations + rotations (exact alignment, curved layout, act on a thin representation at the entrance frame)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import bend\n",
    "from model.library.transformations import wedge\n",
    "from model.library.transformations import tx, ty, tz\n",
    "from model.library.transformations import rx, ry, rz\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "e1 = torch.tensor(0.005, dtype=torch.float64)\n",
    "e2 = torch.tensor(0.005, dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.015, 0.0025], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length.item()},angle={angle.item()},k1={kn.item()},k1s={ks.item()},e1={e1.item()},e2={e2.item()},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "select,flag=error,pattern=\"mag\";\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()};\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = tx(state, +dx)\n",
    "state = ty(state, +dy)\n",
    "state = tz(state, +dz, dp)\n",
    "\n",
    "state = rx(state, +wx, dp)\n",
    "state = ry(state, +wy, dp)\n",
    "state = rz(state, +wz)\n",
    "\n",
    "state = wedge(state, e1, length/angle)\n",
    "state = bend(state, length/angle, kn + 1.0E-16, ks + 1.0E-16, dp, length)\n",
    "state = wedge(state, e2, length/angle)\n",
    "\n",
    "state = ry(state, +angle/2, dp)\n",
    "state = tz(state, -2.0*length/angle*(angle/2.0).sin(), dp)\n",
    "state = ry(state, +angle/2, dp)\n",
    "\n",
    "state = rz(state, -wz)\n",
    "state = ry(state, -wy, dp)\n",
    "state = rx(state, -wx, dp)\n",
    "\n",
    "state = tz(state, -dz, dp)\n",
    "state = ty(state, -dy)\n",
    "state = tx(state, -dx)\n",
    "\n",
    "state = ry(state, -angle/2, dp)\n",
    "state = tz(state, +2.0*length/angle*(angle/2.0).sin(), dp)\n",
    "state = ry(state, -angle/2, dp)\n",
    "\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "554e17dc-f44b-4934-9d37-9960a1d13ba2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00932966343120269, -3.829320024990772e-05, -0.008755742622854638, 0.0005]\n",
      "[0.009329663431209667, -3.829320024994158e-05, -0.008755742622854576, 0.0005]\n",
      "[-6.977057820378718e-15, 3.386098909943791e-17, -6.245004513516506e-17, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# exact sector bend (without fringe)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sector_bend\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.01, -0.0005, -0.01, 0.0005], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},kill_ent_fringe=true,kill_exi_fringe=true;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "state = sector_bend(state, length/angle, dp, length)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "0aac734b-90ea-4f8c-a0bf-8e49979b4999",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00933011773950498, -3.830113730822001e-05, -0.008756237750526722, 0.0004998143432367524]\n",
      "[0.009330117739498277, -3.8301137308233764e-05, -0.008756237750526754, 0.0004998143432367524]\n",
      "[6.702971511174383e-15, 1.3755815063409838e-17, 3.122502256758253e-17, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# exact sector bend (with fringe)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sector_bend\n",
    "from model.library.transformations import sector_bend_fringe\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.01, -0.0005, -0.01, 0.0005], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "state = sector_bend_fringe(state, +length/angle, dp)\n",
    "state = sector_bend(state, length/angle, dp, length)\n",
    "state = sector_bend_fringe(state, -length/angle, dp)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "e50aff00-749c-440d-b1c4-ead947d7e271",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009340060895391944, -3.805697197357787e-05, -0.00874628326389246, 0.0005003157283896672]\n",
      "[0.009340060895401722, -3.805697197360909e-05, -0.00874628326389242, 0.0005003157283896674]\n",
      "[-9.778636234081262e-15, 3.1218246304004493e-17, -3.9898639947466563e-17, -1.0842021724855044e-19]\n"
     ]
    }
   ],
   "source": [
    "# exact sector bend (with fringe and wedges)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sector_bend\n",
    "from model.library.transformations import sector_bend_fringe\n",
    "from model.library.transformations import sector_bend_wedge\n",
    "from model.library.transformations import polar\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.01\n",
    "e2 = -0.01\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.01, -0.0005, -0.01, 0.0005], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "state = polar(state, e1, dp)\n",
    "state = sector_bend_fringe(state, +length/angle, dp)\n",
    "state = sector_bend_wedge(state, -e1, length/angle, dp)\n",
    "state = sector_bend(state, length/angle, dp, length)\n",
    "state = sector_bend_wedge(state, -e2, length/angle, dp)\n",
    "state = sector_bend_fringe(state, -length/angle, dp)\n",
    "state = polar(state, e2, dp)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "718f06d9-f5af-4c43-a377-cd6e08afc8c7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 1.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00, -4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "tensor([[ 1.0000e+00,  5.5508e-17,  0.0000e+00,  0.0000e+00],\n",
      "        [ 4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00, -4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([[ 1.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [-4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "tensor([[ 1.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [-4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  5.5234e-17],\n",
      "        [ 0.0000e+00,  0.0000e+00,  4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# linear wedge matrix\n",
    "\n",
    "from model.library.transformations import wedge\n",
    "from model.library.transformations import polar\n",
    "from model.library.transformations import sector_bend_fringe\n",
    "from model.library.transformations import sector_bend_wedge\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.01\n",
    "e2 = -0.01\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "def wedge_entrance(state):\n",
    "    state = polar(state, e1, dp)\n",
    "    state = sector_bend_fringe(state, +length/angle, dp)\n",
    "    state = sector_bend_wedge(state, -e1, length/angle, dp)\n",
    "    return state\n",
    "\n",
    "def wedge_exit(state):\n",
    "    state = sector_bend_wedge(state, -e2, length/angle, dp)\n",
    "    state = sector_bend_fringe(state, -length/angle, dp)\n",
    "    state = polar(state, e2, dp)\n",
    "    return state\n",
    "\n",
    "print(torch.func.jacrev(wedge)(state, e1, length/angle))\n",
    "print(torch.func.jacrev(wedge_entrance)(state))\n",
    "print()\n",
    "\n",
    "print(torch.func.jacrev(wedge)(state, e2, length/angle))\n",
    "print(torch.func.jacrev(wedge_exit)(state))\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "85d6656d-13d2-4cb4-8404-d1fdf6af354e",
   "metadata": {},
   "source": [
    "# Example-05: Drift (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "942d635e-4ba0-4b82-89f3-a55e423f5f10",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of drift element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "94da4e4d-ea80-4f6d-8b7c-d541629a3c23",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "5c39499a-c10e-4dfb-99f7-abd58e326dcc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0025373134328358204, -0.005, -0.003507462686567164, 0.001]\n",
      "[0.0025373134328358204, -0.005, -0.0035074626865671645, 0.001]\n",
      "[0.0, 0.0, 4.336808689942018e-19, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Drift('D', length=length, dp=dp, exact=exact)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "5ae0a652-05ba-4f39-b7ae-009373ddfa3f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.002537217378977325, -0.005, -0.003507443475795465, 0.001]\n",
      "[0.002537217378977325, -0.005, -0.0035074434757954654, 0.001]\n",
      "[0.0, 0.0, 4.336808689942018e-19, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Drift('D', length=length, dp=dp, exact=exact)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e0bba0d5-03e3-43ad-9955-05aa21a0b360",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0025372170792497145, -0.0049999999999999975, -0.003507395297032926, 0.0010000000000000009]\n",
      "[0.0025372170792497166, -0.004999999999999999, -0.0035073952970329247, 0.0010000000000000018]\n",
      "[-2.168404344971009e-18, 1.734723475976807e-18, -1.3010426069826053e-18, -8.673617379884035e-19]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Drift('D', length=length, dp=dp, exact=exact)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()\n",
    "\n",
    "# Note, for some reason drift is not invariant under WX ans WY rotations in MADX"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "c3422dd0-926f-4f3b-9150-a2e7c2042351",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0025, -0.0050, -0.0035,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0025, -0.0050, -0.0035,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(D(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dl': torch.tensor(-length, dtype=D.dtype)}}))\n",
    "print()\n",
    "\n",
    "# In the above D.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**D.table(), **{'dl': torch.tensor(-length, dtype=DR.dtype)}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(D(state, data={**D.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "DA = Drift('DA', length, dp)\n",
    "DB = Drift('DB', length - 0.1, dp)\n",
    "\n",
    "print(DA(state) - DB(state, data={**DB.table(), **{'dl': torch.tensor(+0.1, dtype=DB.dtype)}}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "3850f79d-c1b7-40c5-8407-1802852021cb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([-0.0005,  0.0000,  0.0001,  0.0000], dtype=torch.float64)\n",
      "tensor([-9.7502e-08,  0.0000e+00,  1.9500e-08,  0.0000e+00],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=False, insertion=True)\n",
    "\n",
    "# Identity transformation without errors\n",
    "\n",
    "print(D(state) - state)\n",
    "\n",
    "# Represents effect of an error\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "D = Drift('D', length, dp, exact=True, insertion=True)\n",
    "\n",
    "print(D(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "b5146cc0-6f5b-47b9-9317-939ca62bbc9b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(D)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return D(state, data={**D.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "3020a87b-b812-4657-a53f-f163959d9d67",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[1.0000, 1.5000, 0.0000, 0.0000],\n",
      "        [0.0000, 1.0000, 0.0000, 0.0000],\n",
      "        [0.0000, 0.0000, 1.0000, 1.5000],\n",
      "        [0.0000, 0.0000, 0.0000, 1.0000]], dtype=torch.float64)\n",
      "\n",
      "tensor([-0.0050,  0.0000,  0.0010,  0.0000], dtype=torch.float64)\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "tensor(-0., dtype=torch.float64)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(D)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "dl = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, dl):\n",
    "    return D(state, data={**D.table(), **{'dl': dl}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, dl))\n",
    "print()\n",
    "\n",
    "# Compositional derivative (compute derivative of jacobian trace with respect momentum deviation)\n",
    "\n",
    "dp = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def trace(state, dp):\n",
    "    return (torch.func.jacrev(lambda state: D(state, data={**D.table(), **{'dp': dp}}))(state)).trace()\n",
    "\n",
    "torch.func.jacrev(trace, 1)(state, dp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "c906a277-85a1-451c-9d08-79505a16a072",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0025, -0.0050, -0.0035,  0.0010], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(D(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "D.ns = 100\n",
    "\n",
    "D(state)\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "4c9992c3-1047-43ae-8be5-c90bb10c9123",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.002499902498098708, -0.005, -0.003499980499619743, 0.001]\n",
      "[0.002499902498098709, -0.005, -0.0034999804996197477, 0.001]\n",
      "[-8.673617379884035e-19, 0.0, 4.7704895589362195e-18, 0.0]\n",
      "\n",
      "[0, 1, 0, 1, 0, 1, 0]\n",
      "[0.6756035959798289, 1.3512071919596578, -0.17560359597982877, -1.7024143839193153, -0.17560359597982877, 1.3512071919596578, 0.6756035959798289]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, order=1, exact=True)\n",
    "\n",
    "# For drift integration is performed only with exact flag\n",
    "# In this case, kinematic term error is added\n",
    "# This term actually commutes with paraxial drift map\n",
    "# But integration is still performed for consistency with matrix-kick-matrix split\n",
    "# Only one integration step is required to get exact result\n",
    "\n",
    "D.ns = 1\n",
    "ref = D(state)\n",
    "\n",
    "D.ns = 10\n",
    "res = D(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = D._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fbb64279-2e1f-4d77-9911-7d59b1e362b9",
   "metadata": {},
   "source": [
    "# Example-06: Quadrupole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d08456c6-d48d-4b01-9849-b640ffadf17a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of quadrupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "4b06f234-9f8d-4966-a6be-199f4bb672b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "bf455483-aa9d-4809-a8db-7616d51ad488",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.012268608165994052, 0.012991610983278109, 0.005825218798687177, 0.01752224400608683]\n",
      "[0.012268608165994057, 0.012991610983278092, 0.005825218798687172, 0.017522244006086807]\n",
      "[-5.204170427930421e-18, 1.734723475976807e-17, 5.204170427930421e-18, 2.0816681711721685e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},k1={kn},k1s={ks} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "Q = Quadrupole('Q', length=length, kn=kn, ks=ks, dp=dp, exact=exact)\n",
    "res = Q(state, alignment=align, data={**Q.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "2edcbd11-789a-4848-b024-1b692eabf59a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.012269208914523159, 0.012992157908766264, 0.005826335256074007, 0.017521822791072554]\n",
      "[0.01226920891452326, 0.012992157908766374, 0.005826335256074149, 0.017521822791072988]\n",
      "[-1.0061396160665481e-16, -1.0928757898653885e-16, -1.4224732503009818e-16, -4.3368086899420177e-16]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},k1={kn},k1s={ks} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "Q = Quadrupole('Q', length=length, kn=kn, ks=ks, dp=dp, exact=exact, order=5, ns=5)\n",
    "res = Q(state, alignment=align, data={**Q.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "f2bb9def-d872-4db2-9eee-ef866761d0ca",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.022075488016794924, -0.09165584224601611, -0.04570124622656498, -0.08629975808408008]\n",
      "[-0.02207548801679439, -0.09165584224601665, -0.04570124622656456, -0.08629975808408233]\n",
      "[-5.342948306008566e-16, 5.412337245047638e-16, -4.2327252813834093e-16, 2.248201624865942e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},k1={kn},k1s={ks} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "Q = Quadrupole('Q', length=length, kn=kn, ks=ks, dp=dp, exact=exact, order=5, ns=5)\n",
    "res = Q(state, alignment=align, data={**Q.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "1cccb51d-c1a3-4dcc-9098-5ac0d1162dfe",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.0242, 0.0380, 0.0152, 0.0200], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([-0.0908, -0.2335, -0.0963, -0.1316], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(Q(state))\n",
    "print()\n",
    "\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(Q(state, data={**Q.table(), **{'dl': -Q.length}}))\n",
    "print()\n",
    "\n",
    "# In the above Q.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**Q.table(), **{'dl': -Q.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(Q(state, data={**Q.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "QA = Quadrupole('QA', length, kn, ks, dp)\n",
    "QB = Quadrupole('QB', length - 0.1, kn, ks, dp)\n",
    "\n",
    "print(QA(state) - QB(state, data={**QB.table(), **{'dl': torch.tensor(+0.1, dtype=QB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "6e1f5eda-f9ba-45bc-8e82-61020d7b69f8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-5.5511e-17,  7.4593e-17, -1.4745e-17,  2.7756e-17],\n",
      "       dtype=torch.float64)\n",
      "tensor([-0.0002,  0.0037,  0.0003,  0.0031], dtype=torch.float64)\n",
      "tensor([-2.2924e-06, -3.9787e-06, -9.4215e-07,  2.1943e-07],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=False, insertion=True)\n",
    "\n",
    "# Identity transformation without errors\n",
    "\n",
    "print(Q(state) - state)\n",
    "\n",
    "# Represents effect of an error\n",
    "\n",
    "print(Q(state, data={**Q.table(), **{'dl': 0.1, 'kn': -0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=True, insertion=True, ns=100, order=1)\n",
    "\n",
    "print(Q(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "57e4fdb0-8f0c-475d-9baf-4e40d8255505",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=Q.dtype, device=Q.device)\n",
    "\n",
    "print(torch.vmap(Q)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return Q(state, data={**Q.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=Q.dtype, device=Q.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "48189c8b-bc04-41d3-bb8e-c4c03e9ca5e1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 4.7923,  3.0672,  1.8367,  0.8757],\n",
      "        [ 7.4479,  4.7923,  2.8495,  1.8367],\n",
      "        [ 1.8367,  0.8757, -0.1057,  0.7321],\n",
      "        [ 2.8495,  1.8367, -0.1507, -0.1057]], dtype=torch.float64)\n",
      "\n",
      "tensor([-0.0175, -0.0354, -0.0029, -0.0029], dtype=torch.float64)\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "tensor([-12.7901,  12.7901], dtype=torch.float64)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(Q)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "kn = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, kn):\n",
    "    return Q(state, data={**Q.table(), **{'kn': kn}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, kn))\n",
    "print()\n",
    "\n",
    "# Compositional derivative (compute derivative of jacobian trace with respect quadrupole strength)\n",
    "\n",
    "length = 0.5\n",
    "knf = +0.2\n",
    "knd = -0.2\n",
    "\n",
    "QF = Quadrupole('QF', length, knf)\n",
    "QD = Quadrupole('QD', length, knd)\n",
    "DR = Drift('DR', 5.0)\n",
    "\n",
    "dknf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dknd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dkn = torch.stack([dknf, dknd])\n",
    "\n",
    "def fodo(state, dkn):\n",
    "    dknf, dknd = dkn\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    state = DR(state)\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = DR(state)\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    return state\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def trace(dkn):\n",
    "    return (torch.func.jacrev(fodo)(state, dkn)).trace()\n",
    "\n",
    "torch.func.jacrev(trace)(dkn)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "93593b02-875e-4f2b-a7f9-8db8d855a4fd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.0243, 0.0381, 0.0153, 0.0200], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(Q(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(Q.container_output.shape)\n",
    "print(Q.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "Q.ns = 100\n",
    "\n",
    "Q(state)\n",
    "print(Q.container_output.shape)\n",
    "print(Q.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "0ba48709-87f5-4be9-bb70-9a43022178ce",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.02428427109202266, 0.038113543192801885, 0.015254854998694011, 0.019958320804526662]\n",
      "[0.02428676414378537, 0.038112599406681553, 0.015255420211007745, 0.019958093271800193]\n",
      "[-2.493051762711418e-06, 9.437861203318021e-07, -5.652123137335485e-07, 2.275327264690541e-07]\n",
      "\n",
      "[0, 1, 0, 1, 0, 1, 0]\n",
      "[0.6756035959798289, 1.3512071919596578, -0.17560359597982877, -1.7024143839193153, -0.17560359597982877, 1.3512071919596578, 0.6756035959798289]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, order=1, exact=True)\n",
    "\n",
    "# For quadrupole integration is performed only with exact flag\n",
    "# In this case, kinematic term error is added\n",
    "\n",
    "Q.ns = 1\n",
    "ref = Q(state)\n",
    "\n",
    "Q.ns = 10\n",
    "res = Q(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = Q._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "e0773bea-af9f-4c5e-b2e2-12bf9d626e61",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.2107, 0.1703], dtype=torch.float64)\n",
      "tensor([0.2126, 0.1681], dtype=torch.float64)\n",
      "tensor([0.2126, 0.1681], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Derivatives of twiss parameters\n",
    "\n",
    "# pip install git+https://github.com/i-a-morozov/twiss.git@main\n",
    "\n",
    "from twiss import twiss\n",
    "\n",
    "length = 0.5\n",
    "knf = +0.21\n",
    "knd = -0.19\n",
    "\n",
    "QF = Quadrupole('QF', length, knf)\n",
    "QD = Quadrupole('QD', length, knd)\n",
    "DR = Drift('DR', 5.0)\n",
    "\n",
    "dknf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dknd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dkn = torch.stack([dknf, dknd])\n",
    "\n",
    "def fodo(state, dkn):\n",
    "    dknf, dknd = dkn\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    state = DR(state)\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = DR(state)\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    return state\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def tune(dkn):\n",
    "    matrix = torch.func.jacrev(fodo)(state, dkn)\n",
    "    tune, *_ = twiss(matrix)\n",
    "    return tune\n",
    "\n",
    "# Compute tunes and jacobian\n",
    "\n",
    "values = tune(dkn)\n",
    "jacobian = torch.func.jacrev(tune)(dkn)\n",
    "\n",
    "# Test jacobiant\n",
    "\n",
    "print(values)\n",
    "print(tune(dkn + 1.0E-3))\n",
    "print(values + jacobian @ (dkn + 1.0E-3))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ed1c26f4-6b1f-4333-8a47-e8964fb9b279",
   "metadata": {},
   "source": [
    "# Example-07: Sextupole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a25b4b6d-3b76-47d9-9d60-7b1af9ddc472",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of sextupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "6052fb02-2899-4172-8f96-69cb2d0255bb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.sextupole import Sextupole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "60472c44-909a-4c44-89a0-8bd61ed645b0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.008745689261382875, -0.005080234821325765, -0.00476590910682766, 0.0008855562050471031]\n",
      "[0.008745689261382871, -0.00508023482132578, -0.00476590910682768, 0.0008855562050471008]\n",
      "[3.469446951953614e-18, 1.5612511283791264e-17, 1.9949319973733282e-17, 2.2768245622195593e-18]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sextupole, l={length},k2={ms} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "S = Sextupole('S', length=length, ms=ms, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = S(state, alignment=align, data={**S.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "30051f5c-9427-4fb2-88f4-b1bf7cef4562",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.008745672936611987, -0.005080234654232574, -0.004765906047078759, 0.000885556338827788]\n",
      "[0.00874567293661202, -0.0050802346542325495, -0.0047659060470788064, 0.0008855563388277869]\n",
      "[-3.2959746043559335e-17, -2.42861286636753e-17, 4.7704895589362195e-17, 1.0842021724855044e-18]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sextupole, l={length},k2={ms} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "S = Sextupole('S', length=length, ms=ms, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = S(state, alignment=align, data={**S.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "060aa4d8-2586-49ba-8cd3-389c4e8a9157",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.008663885569968804, -0.006258052120536049, -0.004896687680053297, -0.000915022709372755]\n",
      "[0.008663885569968922, -0.006258052120536033, -0.004896687680053253, -0.000915022709372733]\n",
      "[-1.1796119636642288e-16, -1.6479873021779667e-17, -4.423544863740858e-17, -2.200930410145574e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sextupole, l={length},k2={ms} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "S = Sextupole('S', length=length, ms=ms, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = S(state, alignment=align, data={**S.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "06fc7a7d-7c34-4842-93f2-9910d90e6b1a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0087, -0.0051, -0.0048,  0.0009], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0087, -0.0062, -0.0049, -0.0009], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(S(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(S(state, data={**S.table(), **{'dl': -S.length}}))\n",
    "print()\n",
    "\n",
    "# In the above S.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**S.table(), **{'dl': -S.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(S(state, data={**S.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "SA = Sextupole('SA', length, ms, dp)\n",
    "SB = Sextupole('SB', length - 0.1, ms, dp)\n",
    "\n",
    "print(SA(state) - SB(state, data={**SB.table(), **{'dl': torch.tensor(+0.1, dtype=SB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "02270c3a-c3bb-42ac-85ca-ce6c33eb1cd1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0000, -0.0006,  0.0000, -0.0008], dtype=torch.float64)\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([-5.2560e-04, -5.6465e-04,  6.1078e-05, -7.7234e-04],\n",
      "       dtype=torch.float64)\n",
      "tensor([-1.3875e-04, -5.5306e-04, -9.3764e-05, -7.7778e-04],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=False, insertion=True)\n",
    "\n",
    "# Since sextupole is a nonlinear element, insertion is an identity transformation only for zero strenght\n",
    "\n",
    "print(S(state) - state)\n",
    "print(S(state, data={**S.table(), **{'ms': -ms}}) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(S(state, data={**S.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=True, insertion=True, ns=100, order=1)\n",
    "\n",
    "print(S(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "51f9375a-61d8-4ea2-9dc7-882543b4e0fb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=S.dtype, device=S.device)\n",
    "\n",
    "print(torch.vmap(S)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return S(state, data={**S.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=S.dtype, device=S.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "9d084357-0817-4268-8f58-2ab8e0e46233",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 0.9297,  1.4473, -0.0478, -0.0359],\n",
      "        [-0.0938,  0.9297, -0.0638, -0.0478],\n",
      "        [-0.0478, -0.0359,  1.0703,  1.5527],\n",
      "        [-0.0638, -0.0478,  0.0938,  1.0703]], dtype=torch.float64)\n",
      "\n",
      "tensor([-1.1813e-05, -1.5750e-05, -2.9883e-05, -3.9844e-05],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(S)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "ms = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, ms):\n",
    "    return S(state, data={**S.table(), **{'ms': ms}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, ms))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "ae5bc2c2-07f9-4edc-bfab-b696f0a56307",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0023, -0.0052, -0.0039,  0.0006], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(S(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(S.container_output.shape)\n",
    "print(S.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "S.ns = 100\n",
    "\n",
    "S(state)\n",
    "print(S.container_output.shape)\n",
    "print(S.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "fb10197c-e304-49ed-997a-1d0283f5814f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0022880403040043407, -0.005176627884407675, -0.0038882248469424585, 0.0005834231060909752]\n",
      "[0.0022871610802911667, -0.005176794799148338, -0.0038891562083014203, 0.0005832353574511327]\n",
      "[8.792237131739246e-07, 1.6691474066278522e-07, 9.313613589618727e-07, 1.877486398425181e-07]\n",
      "\n",
      "[0, 1, 2, 1, 0]\n",
      "[0.5, 0.5, 1.0, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, order=0, exact=True)\n",
    "\n",
    "# For sextupole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "S.ns = 10\n",
    "ref = S(state)\n",
    "\n",
    "S.ns = 100\n",
    "res = S(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = S._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "bc85fb39-b5a8-4719-984c-14d55808607b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.2107, 0.1703], dtype=torch.float64)\n",
      "tensor([-0.2279, -0.2107], dtype=torch.float64)\n",
      "tensor([[0., 0.],\n",
      "        [0., 0.]], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Derivatives of twiss parameters (chromaticity)\n",
    "\n",
    "# pip install git+https://github.com/i-a-morozov/twiss.git@main\n",
    "\n",
    "from twiss import twiss\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.21)\n",
    "QD = Quadrupole('QD', 0.5, -0.19)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DA = Drift('DR', 0.25)\n",
    "DB = Drift('DR', 4.00)\n",
    "\n",
    "def fodo(state, dp, dms):\n",
    "    dmsf, dmsd = dms\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DB(state, data={**DB.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DB(state, data={**DB.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    return state\n",
    "\n",
    "dp = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "dmsf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dmsd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dms = torch.stack([dmsf, dmsd])\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def tune(dp, dms):\n",
    "    matrix = torch.func.jacrev(fodo)(state, dp, dms)\n",
    "    tune, *_ = twiss(matrix)\n",
    "    return tune\n",
    "\n",
    "def chromaticity(dms):\n",
    "    return torch.func.jacrev(tune)(dp, dms)\n",
    "\n",
    "# Compute tunes\n",
    "\n",
    "tunes = tune(dp, dms)\n",
    "print(tunes)\n",
    "\n",
    "# Compute chromaticity\n",
    "\n",
    "chromaticities = chromaticity(dms)\n",
    "print(chromaticities)\n",
    "\n",
    "# Compute derivative of chromaticities \n",
    "# The result is zero, since there is no dispersion to feed sextupoles down\n",
    "\n",
    "print(torch.func.jacrev(chromaticity)(dms))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9a5af188-3962-4346-b9e7-69c0fd7913ab",
   "metadata": {},
   "source": [
    "# Example-08: Octupole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7ded21b8-b066-4836-8135-bd50a23310ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of octupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "c4585155-0b09-4e84-91b2-0daa0d89459c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.octupole import Octupole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "af5acd11-30d5-4fbb-9850-670a00aa6025",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009004942132987458, -0.005000291994759593, -0.004801204788639501, 0.0009979801079392878]\n",
      "[0.009004942132987486, -0.005000291994759635, -0.004801204788639504, 0.0009979801079392843]\n",
      "[-2.7755575615628914e-17, 4.2500725161431774e-17, 3.469446951953614e-18, 3.469446951953614e-18]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "mo = + 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: octupole, l={length},k3={mo};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "O = Octupole('O', length=length, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = O(state, alignment=align, data={**O.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "652c325d-00b6-47b8-b901-9594a2cfc135",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00900492932570409, -0.005000291993307186, -0.004801202229721349, 0.0009979801112567327]\n",
      "[0.009004929325704207, -0.0050002919933071705, -0.004801202229721335, 0.00099798011125672]\n",
      "[-1.1622647289044608e-16, -1.5612511283791264e-17, -1.3877787807814457e-17, 1.2576745200831851e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "mo = + 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: octupole, l={length},k3={mo};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "O = Octupole('O', length=length, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = O(state, alignment=align, data={**O.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "19d0f11c-e3dc-40be-b934-d107f292ea77",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009005660276793346, -0.004983923494470567, -0.004794436076349048, 0.0011299481578555504]\n",
      "[0.009005660276792638, -0.004983923494470562, -0.004794436076348805, 0.0011299481578555233]\n",
      "[7.077671781985373e-16, -5.204170427930421e-18, -2.42861286636753e-16, 2.710505431213761e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "mo = + 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: octupole, l={length},k3={mo};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "O = Octupole('O', length=length, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = O(state, alignment=align, data={**O.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "c6135d37-9763-4e07-9a74-12c45f182578",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0090, -0.0050, -0.0048,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0090, -0.0050, -0.0048,  0.0011], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(O(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(O(state, data={**O.table(), **{'dl': -O.length}}))\n",
    "print()\n",
    "\n",
    "# In the above O.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**O.table(), **{'dl': -O.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(O(state, data={**O.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "OA = Octupole('OA', length, mo, dp)\n",
    "OB = Octupole('OB', length - 0.1, mo, dp)\n",
    "\n",
    "print(OA(state) - OB(state, data={**OB.table(), **{'dl': torch.tensor(+0.1, dtype=OB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "737144d9-ff08-4d7b-8ccd-d30719a59150",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0000e+00, -4.1667e-07,  0.0000e+00, -2.2917e-06],\n",
      "       dtype=torch.float64)\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([-4.9754e-04, -5.2588e-07,  9.9342e-05, -3.2270e-06],\n",
      "       dtype=torch.float64)\n",
      "tensor([-1.7351e-08, -4.1976e-07, -6.9314e-09, -2.2953e-06],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=False, insertion=True)\n",
    "\n",
    "# Since octupole is a nonlinear element, insertion is an identity transformation only for zero strenght\n",
    "\n",
    "print(O(state) - state)\n",
    "print(O(state, data={**O.table(), **{'mo': -mo}}) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(O(state, data={**O.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=True, insertion=True, ns=100, order=1)\n",
    "\n",
    "print(O(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "677094a5-23a2-45cd-981f-40a7197ea6a2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=O.dtype, device=O.device)\n",
    "\n",
    "print(torch.vmap(O)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return O(state, data={**O.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=O.dtype, device=O.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "3b261fda-33d5-4c6b-8b81-a202a8e1f393",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 9.9997e-01,  1.9900e-01, -4.6335e-05, -4.6105e-06],\n",
      "        [-3.3141e-04,  9.9997e-01, -4.6567e-04, -4.6335e-05],\n",
      "        [-4.6335e-05, -4.6105e-06,  1.0000e+00,  1.9901e-01],\n",
      "        [-4.6567e-04, -4.6335e-05,  3.3141e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([-5.7528e-10, -5.7815e-09, -4.0127e-09, -4.0327e-08],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(O)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "mo = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, mo):\n",
    "    return O(state, data={**O.table(), **{'mo': mo}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, mo))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "b1b01a89-88dc-41ae-b6fd-bab27e90eb5c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0090, -0.0050, -0.0048,  0.0010], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(O(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(O.container_output.shape)\n",
    "print(O.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "O.ns = 100\n",
    "\n",
    "O(state)\n",
    "print(O.container_output.shape)\n",
    "print(O.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "1aa2f3ff-9a61-45d3-a73e-c10a02b47ce5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00900492936806216, -0.005000291964120008, -0.004801202138358545, 0.0009979801465156844]\n",
      "[0.00900492932612774, -0.005000291993015304, -0.004801202228807697, 0.0009979801116093128]\n",
      "[4.193442121325219e-11, 2.889529587823958e-11, 9.044915164069245e-11, 3.4906371629978006e-11]\n",
      "\n",
      "[0, 1, 2, 1, 0]\n",
      "[0.5, 0.5, 1.0, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, order=0, exact=True)\n",
    "\n",
    "# For octupole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "O.ns = 10\n",
    "ref = O(state)\n",
    "\n",
    "O.ns = 100\n",
    "res = O(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = O._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4d8ff990-9a7c-49d1-8fe7-a1d56543240a",
   "metadata": {},
   "source": [
    "# Example-09: Multipole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "576ab5fc-23cd-4f73-91c9-3f2390ab66a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of sextupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "9bd9ca75-a543-4d18-a08a-4caec0510a03",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.multipole import Multipole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "1ea961e2-8b60-490b-b1cc-974ebee5ad31",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00892946929535585, 0.0009165531774213284, -0.0017930189940976037, 0.01128986832436645]\n",
      "[0.008929469295357165, 0.0009165531774215092, -0.001793018994097765, 0.011289868324367684]\n",
      "[-1.3149203947904198e-15, -1.8084492237058214e-16, 1.6132928326584306e-16, -1.2333883914195098e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "dp = 0.005\n",
    "length = 0.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "M = Multipole('M', length=length, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = M(state, alignment=align, data={**M.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0b1ce0b6-0c4a-4796-be88-38ccf35281cf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00892945162589142, 0.0009165626425029898, -0.0017929090323601758, 0.011289834389170184]\n",
      "[0.008929451625892749, 0.0009165626425031966, -0.0017929090323603035, 0.011289834389171444]\n",
      "[-1.3287981825982342e-15, -2.067573542929857e-16, 1.2771901591879242e-16, -1.259409243559162e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "dp = 0.005\n",
    "length = 0.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "M = Multipole('M', length=length, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = M(state, alignment=align, data={**M.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "62bd9fb6-e013-469f-ae20-fec3ac487c93",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.001664975746516068, -0.04016261215593401, -0.015906155451718536, -0.05363979979736713]\n",
      "[0.001664975746510186, -0.040162612155939637, -0.015906155451718453, -0.053639799797374155]\n",
      "[5.882013626168359e-15, 5.627442956068762e-15, -8.326672684688674e-17, 7.022160630754115e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "dp = 0.005\n",
    "length = 0.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "M = Multipole('M', length=length, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = M(state, alignment=align, data={**M.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "878fb0a8-a137-4295-a232-8b4526fda4a1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0092, -0.0028, -0.0043,  0.0055], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0085, -0.0159, -0.0060, -0.0224], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(M(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(M(state, data={**M.table(), **{'dl': -M.length}}))\n",
    "print()\n",
    "\n",
    "# In the above M.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**M.table(), **{'dl': -M.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(M(state, data={**M.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "MA = Multipole('MA', length, kn, ks, ms, mo, dp)\n",
    "MB = Multipole('MB', length - 0.1, kn, ks, ms, mo, dp)\n",
    "\n",
    "print(MA(state) - MB(state, data={**MB.table(), **{'dl': torch.tensor(+0.1, dtype=MB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "2a65d2c6-623b-4732-bc00-4d39b5f38b34",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 6.9389e-18, -1.8792e-04, -8.6736e-19, -2.5229e-04],\n",
      "       dtype=torch.float64)\n",
      "tensor([ 6.9389e-18, -1.7347e-18, -8.6736e-19, -4.3368e-19],\n",
      "       dtype=torch.float64)\n",
      "tensor([-0.0004,  0.0009,  0.0002,  0.0021], dtype=torch.float64)\n",
      "tensor([-7.9785e-07, -1.9093e-04, -5.6642e-07, -2.5071e-04],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=False, insertion=True)\n",
    "\n",
    "# Since multipole is a nonlinear element (non-zero sextupole or octupole)\n",
    "# Insertion is an identity transformation only for zero strenght\n",
    "\n",
    "print(M(state) - state)\n",
    "print(M(state, data={**M.table(), **{'ms': -ms, 'mo': -mo}}) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(M(state, data={**M.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=True, insertion=True, ns=20, order=1)\n",
    "\n",
    "print(M(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "64156722-a31b-46e4-b9a9-28d4bba7333b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=M.dtype, device=M.device)\n",
    "\n",
    "print(torch.vmap(M)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return M(state, data={**M.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=M.dtype, device=M.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "f4aa669b-d048-4e9c-a9cf-2d86e7a7d6f5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 1.0353,  0.2012,  0.0274,  0.0017],\n",
      "        [ 0.3588,  1.0353,  0.2757,  0.0274],\n",
      "        [ 0.0274,  0.0017,  0.9653,  0.1969],\n",
      "        [ 0.2757,  0.0274, -0.3449,  0.9653]], dtype=torch.float64)\n",
      "\n",
      "tensor([-1.9468e-04, -1.9487e-03, -9.6920e-05, -9.5528e-04],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(M)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "kn = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, kn):\n",
    "    return M(state, data={**M.table(), **{'kn': kn}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, kn))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "2f7a7c2a-5f81-4cbf-b86d-05c754f556e4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0092, -0.0028, -0.0043,  0.0055], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(M(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(M.container_output.shape)\n",
    "print(M.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "M.ns = 100\n",
    "\n",
    "M(state)\n",
    "print(M.container_output.shape)\n",
    "print(M.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "5e8e13be-6c21-4ec3-b54d-b1ac92b29d89",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009228705737231328, -0.0027662827194168435, -0.0043416399485996455, 0.0055422008499342295]\n",
      "[0.009228699312521689, -0.0027663108074714327, -0.0043416467924913375, 0.0055422142138782556]\n",
      "[6.424709639296644e-09, 2.808805458923494e-08, 6.843891692080717e-09, -1.336394402605412e-08]\n",
      "\n",
      "[0, 1, 2, 1, 0]\n",
      "[0.5, 0.5, 1.0, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, order=0, exact=True)\n",
    "\n",
    "# For multipole with non-zero sextupole and/or octupole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "M.ns = 10\n",
    "ref = M(state)\n",
    "\n",
    "M.ns = 100\n",
    "res = M(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = M._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "96686a69-20a6-4bf4-ae7e-8725c634ec1c",
   "metadata": {},
   "source": [
    "# Example-10: Dipole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7396d90f-93dc-4087-b2db-8a8e044e4d5b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of dipole element with MADX-PTC and other features\n",
    "\n",
    "# Note, cylindrical multipole is included upto octupole order\n",
    "# Potential is not truncated in paraxial case, only sqrt is expanded \n",
    "# In exact case effects of multipoles are not accounted in wedges (cases with e1 or e2 not equal to zero)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "8331a8a0-0761-42fb-ac91-5c9490717526",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.sextupole import Sextupole\n",
    "from model.library.dipole import Dipole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "207dea76-8d75-418a-8e5d-a4fbd3110a11",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[5.160257777686003e-05, -0.004956273150572646, -0.0030019980019983517, 0.001]\n",
      "[5.160257777670049e-05, -0.004956273150572624, -0.003001998001997979, 0.001]\n",
      "[1.5954034968124198e-16, -2.2551405187698492e-17, -3.725318664660193e-16, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0113463c-b1dc-499b-bbf6-ea4b65a35d33",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[6.408749411377232e-05, -0.00494998958983017, -0.002995752944647053, 0.0010049983869644134]\n",
      "[6.408749411361558e-05, -0.0049499895898301935, -0.002995752944646423, 0.001004998386964413]\n",
      "[1.5673497655993573e-16, 2.3418766925686896e-17, -6.29704621779581e-16, 4.336808689942018e-19]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, e1 & e2)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "dcd83a30-099d-45f2-8500-20e175ed1f07",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0027250502286323983, -0.004697460778410744, -0.007781317874336121, -0.004015687563474919]\n",
      "[0.0027250502286329382, -0.004697460778410177, -0.007781317874339214, -0.004015687563475917]\n",
      "[-5.399326818977812e-16, -5.672545766444159e-16, 3.093011957666647e-15, 9.983333604246525e-16]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, e1 & e2, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "914e2fda-da37-414d-a083-9e8c49518162",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.002043638956596164, -0.006566087436123452, -0.00259447159458907, 0.0010855376916213359]\n",
      "[-0.002044085292481253, -0.006566346702412594, -0.0025944404024843, 0.0010855252766681649]\n",
      "[4.4633588508913996e-07, 2.5926628914162836e-07, -3.11921047697547e-08, 1.2414953170971493e-08]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, kn & ks)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "d881da15-8f29-4801-8864-ca03a21005fa",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013167193439103305, 0.005511119368028012, -0.010781508233295324, -0.007329921037793256]\n",
      "[0.013155910631909329, 0.005501237219297177, -0.01077978061323904, -0.007328193049690298]\n",
      "[1.1282807193976202e-05, 9.88214873083506e-06, -1.7276200562840738e-06, -1.7279881029579405e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, kn & ks, alignment)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "bd452fc9-ae8e-4e24-88c7-bb9930c5f33b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013072849472264409, 0.005416718324594963, -0.010908836090706359, -0.007452351251381879]\n",
      "[0.013061618858280511, 0.005406876286035405, -0.010906993838412468, -0.007450515116391215]\n",
      "[1.1230613983897672e-05, 9.842038559557814e-06, -1.8422522938908031e-06, -1.8361349906643315e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "02298fb0-7cc7-41a1-9efe-dc79991c115d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013030972087034147, 0.005379072261796265, -0.010940636831296861, -0.007479587493733525]\n",
      "[0.013019736470994862, 0.005369216085022898, -0.010938788726490435, -0.007477745021701217]\n",
      "[1.123561603928562e-05, 9.856176773366705e-06, -1.8481048064261651e-06, -1.8424720323075017e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, e1 & e2, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "# Note, model dipole doesn't account for multipoles in wedges\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "48ce99f8-57cd-433a-98c4-13842cc9aea6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.002770798305588665, -0.004651371270674763, -0.007745680488823617, -0.0039921009984161026]\n",
      "[0.002770798305497435, -0.004651371270673967, -0.007745680488833819, -0.003992100998417079]\n",
      "[9.122997496335827e-14, -7.953707137353661e-16, 1.0202776123957591e-14, 9.766493169749424e-16]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "f345bcf6-1393-46d3-9947-1acf84b5a281",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013055723507830729, 0.005405610520344896, -0.01089583005089035, -0.007447552679263773]\n",
      "[0.013055723646615967, 0.005405610850033719, -0.010895828250285258, -0.007447551055281059]\n",
      "[-1.3878523850985314e-10, -3.296888231169026e-10, -1.8006050921115513e-09, -1.623982713930272e-09]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in model dipole cylindrical potential is truncated at octupole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "75764464-2ec0-48e0-8a96-ef0bfb6d3268",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013018589129527029, 0.005372361621197678, -0.010919187705983761, -0.007468383469439608]\n",
      "[0.013013881710655763, 0.005367955807036615, -0.010927596957623284, -0.007474796553900096]\n",
      "[4.707418871265426e-06, 4.4058141610630805e-06, 8.409251639522608e-06, 6.413084460487467e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, e1 & e2, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in model dipole cylindrical potential is truncated at octupole\n",
    "# Note, model dipole doesn't account for multipoles in wedges\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "28115334-e395-41d8-871a-9849beefd329",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-0.0020, -0.0066, -0.0026,  0.0011], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0044, -0.0061, -0.0038,  0.0013], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0130,  0.0054, -0.0109, -0.0075], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(D(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dl': -0.5*D.length}}))\n",
    "print()\n",
    "\n",
    "# In the above D.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**D.table(), **{'dl': -D.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(D(state, data={**D.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "DA = Dipole('DA', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "DB = Dipole('DB', length - 0.1, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "print(DA(state) - DB(state, data={**DB.table(), **{'dl': torch.tensor(+0.1, dtype=DB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "d50366fa-d74c-4749-a4f0-1d6a525122c4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-1.7347e-18,  8.6736e-19,  8.6736e-19, -2.1684e-19],\n",
      "       dtype=torch.float64)\n",
      "tensor([ 9.9380e-06,  4.9995e-05, -1.9980e-06, -2.1684e-19],\n",
      "       dtype=torch.float64)\n",
      "tensor([-2.3859e-06, -5.8600e-06, -7.2738e-07, -2.4947e-07],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "import torch\n",
    "from model.library.dipole import Dipole\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=False, insertion=True)\n",
    "\n",
    "# For dipole insertion is an identity transformation in the following is true\n",
    "# dp = 0 (chomatic orbit change)\n",
    "# kn & ks and ms & mo are all equal to zero (nonlinearity of cylindrical potential)\n",
    "\n",
    "print(D(state) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dp': 0.001}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=True, insertion=True)\n",
    "\n",
    "print(D(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "f3db79ab-c1e6-4b72-b424-4bb50cf75380",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(D)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return D(state, data={**D.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "bedf0bb0-593f-4f90-9353-9a7bd59d99bc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 0.3083,  1.4545,  1.0125,  0.6652],\n",
      "        [-0.3993,  0.3083,  1.0602,  1.0168],\n",
      "        [ 1.0168,  0.6652,  2.3568,  2.8065],\n",
      "        [ 1.0602,  1.0125,  1.7383,  2.3568]], dtype=torch.float64)\n",
      "\n",
      "tensor([0.0004, 0.0002, 0.0005, 0.0005], dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(D)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "e1 = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, e1):\n",
    "    return D(state, data={**D.table(), **{'e1': e1}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, e1))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "108c29b5-70db-4226-b30c-5e231bf5bd5e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-0.0086, -0.0098, -0.0022, -0.0008], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(D(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "D.ns = 100\n",
    "\n",
    "D(state)\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "a728d14d-f46d-47b8-96ff-5b1528a81353",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.008587515809774631, -0.00981976009190801, -0.0021662845096666753, -0.0008078063877268332]\n",
      "[-0.008587660168877737, -0.009820004323629564, -0.002166780652684309, -0.0008081645802833107]\n",
      "[1.4435910310542366e-07, 2.442317215550771e-07, 4.961430176337635e-07, 3.581925564774893e-07]\n",
      "\n",
      "[0, 1, 2, 3, 4, 3, 2, 1, 0]\n",
      "[0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=True, ns=10)\n",
    "\n",
    "# For dipole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "D.ns = 10\n",
    "ref = D(state)\n",
    "\n",
    "D.ns = 100\n",
    "res = D(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = D._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "06d311c6-8138-433b-9ab1-c854eaf0e3e8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.2210, 0.1703], dtype=torch.float64)\n",
      "tensor([-0.2310, -0.2107], dtype=torch.float64)\n",
      "tensor([[ 0.6149,  0.1072],\n",
      "        [-0.2916, -0.3693]], dtype=torch.float64)\n",
      "tensor([ 4.0159e-16, -1.2143e-16], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Derivatives of twiss parameters (chromaticity)\n",
    "\n",
    "# pip install git+https://github.com/i-a-morozov/twiss.git@main\n",
    "\n",
    "from twiss import twiss\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.21)\n",
    "QD = Quadrupole('QD', 0.5, -0.19)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Dipole('DR', 3.50, 0.15)\n",
    "\n",
    "def fodo(state, dp, dms):\n",
    "    dmsf, dmsd = dms\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = BM(state, data={**BM.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = BM(state, data={**BM.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    return state\n",
    "\n",
    "dp = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "dmsf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dmsd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dms = torch.stack([dmsf, dmsd])\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def tune(dp, dms):\n",
    "    matrix = torch.func.jacrev(fodo)(state, dp, dms)\n",
    "    tune, *_ = twiss(matrix)\n",
    "    return tune\n",
    "\n",
    "def chromaticity(dms):\n",
    "    return torch.func.jacrev(tune)(dp, dms)\n",
    "\n",
    "# Compute tunes\n",
    "\n",
    "tunes = tune(dp, dms)\n",
    "print(tunes)\n",
    "\n",
    "# Compute chromaticity\n",
    "\n",
    "chromaticities = chromaticity(dms)\n",
    "print(chromaticities)\n",
    "\n",
    "# Compute derivative of chromaticities \n",
    "\n",
    "jacobian = torch.func.jacrev(chromaticity)(dms)\n",
    "print(jacobian)\n",
    "\n",
    "# Correct chomaticity\n",
    "\n",
    "print(chromaticity(dms - torch.linalg.pinv(jacobian) @ chromaticities))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "02f34857-7739-4c9f-a7b2-194afe494250",
   "metadata": {},
   "source": [
    "# Example-11: Corrector (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "6cf3434e-ef9b-4abb-80a0-161ed75e11b7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of corrector element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "8cf9243c-0141-48d0-939f-ed1727e53d0f",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.corrector import Corrector"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "56f915fc-864f-4777-b8d8-9940b5361896",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.001, 0.0, -0.005]\n",
      "[0.0, 0.001, 0.0, -0.005]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "cx:hkicker,l=0.0,kick={cx};\n",
    "cy:vkicker,l=0.0,kick={cy};\n",
    "map:line=(cx, cy) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "C = Corrector('C', cx=cx, cy=cy, dp=dp)\n",
    "res = C(state, alignment=align, data={**C.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "154f0b88-3fd8-4a93-8bad-7f8649426d99",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.0014941712485121669, 0.0, -0.004875187409743301]\n",
      "[-6.938893903907228e-18, 0.0014941712485121667, 0.0, -0.004875187409743301]\n",
      "[6.938893903907228e-18, 2.168404344971009e-19, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (alignment)\n",
    "\n",
    "# Only dx and dy alignment errors seems to work as expected in MADX \n",
    "# Also, wz rotation can be assosiated with tilt\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = align*torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "cx:hkicker,l=0.0,kick={cx},tilt={wz.item()};\n",
    "cy:vkicker,l=0.0,kick={cy},tilt={wz.item()};\n",
    "map:line=(cx, cy) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "C = Corrector('C', cx=cx, cy=cy, dp=dp)\n",
    "res = C(state, alignment=align, data={**C.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "1f2b1b47-8f6c-4190-ba23-dfc8496b8caf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0000,  0.0010,  0.0000, -0.0050], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0000, -0.0010,  0.0000,  0.0050], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "C = Corrector('C', cx, cy, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(C(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(C(state, data={**C.table(), **{'cx': -cx, 'cy': -cy}}))\n",
    "print()\n",
    "\n",
    "# In the above C.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**C.table(), **{'cx': -cx, 'cy': -cy}} replaces the 'cx' and 'cy' key values \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(C(state, data={**C.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "CA = Corrector('CA', cx, cy, dp)\n",
    "CB = Corrector('CB', cx - 0.001, cy, dp)\n",
    "\n",
    "print(CA(state) - CB(state, data={**CB.table(), **{'cx': + 0.001}}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "bb87ec24-04cc-45e6-a77c-ae8376ab7ea3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "C = Corrector('C', cx, cy, dp)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=C.dtype, device=C.device)\n",
    "\n",
    "print(torch.vmap(C)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, cx, cy):\n",
    "    return C(state, data={**C.table(), **{'cx': cx, 'cy': cy}})\n",
    "\n",
    "cx = 1.0E-3*torch.randn(512, dtype=C.dtype, device=C.device)\n",
    "cy = 1.0E-3*torch.randn(512, dtype=C.dtype, device=C.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, cx, cy).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ce4d05a0-9f36-4ba5-b82f-79052615687b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[1., 0., 0., 0.],\n",
      "        [0., 1., 0., 0.],\n",
      "        [0., 0., 1., 0.],\n",
      "        [0., 0., 0., 1.]], dtype=torch.float64)\n",
      "\n",
      "tensor([[0., 0.],\n",
      "        [1., 0.],\n",
      "        [0., 0.],\n",
      "        [0., 1.]], dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "C = Corrector('C', cx, cy, dp)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(C)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "dcx = torch.tensor(0.0, dtype=torch.float64)\n",
    "dcy = torch.tensor(0.0, dtype=torch.float64)\n",
    "dc = torch.stack([dcx, dcy])\n",
    "\n",
    "def wrapper(state, dc):\n",
    "    dcx, dcy = dc\n",
    "    return C(state, data={**C.table(), **{'cx': dcx, 'cy': dcy}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, dc))\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd58df7d-32e6-4019-8bb5-44ae51af421b",
   "metadata": {},
   "source": [
    "# Example-12: Gradient (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "57c86b2d-a0ea-41b1-934f-7f159937bd3e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of gradient element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "21f5ddf4-257d-475d-a246-14ac7c8b42cb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.gradient import Gradient"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "0fd74c26-8051-4021-a8b9-d1869b628f87",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.001, 7.5e-06, -0.005, -2.75e-05]\n",
      "[0.001, 7.5e-06, -0.005, -2.75e-05]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,{kn}}},ksl={{0.0,{ks}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "G = Gradient('G', kn=kn, ks=ks, dp=dp)\n",
    "res = G(state, alignment=align, data={**G.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "d7bc6085-448a-4ad9-9d57-57cfd750f72a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.000991887042015914, 0.00016412084104346932, -0.005011606734840507, 0.00023479809553215934]\n",
      "[0.0009918870420159223, 0.00016412084104346948, -0.005011606734840506, 0.00023479809553215904]\n",
      "[-8.239936510889834e-18, -1.6263032587282567e-19, -8.673617379884035e-19, 2.981555974335137e-19]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,{kn}}},ksl={{0.0,{ks}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "G = Gradient('G', kn=kn, ks=ks, dp=dp)\n",
    "res = G(state, alignment=align, data={**G.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "2cd7bc99-9036-4513-bc86-988b6ca18592",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 1.0000e-03,  7.5000e-06, -5.0000e-03, -2.7500e-05],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0010,  0.0000, -0.0050,  0.0000], dtype=torch.float64)\n",
      "\n",
      "tensor([ 1.0000e-03,  3.2500e-05, -5.0000e-03,  4.7500e-05],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "G = Gradient('G', kn, ks, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(G(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(G(state, data={**G.table(), **{'kn': -kn, 'ks': -ks}}))\n",
    "print()\n",
    "\n",
    "# In the above G.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**G.table(), **{'kn': -kn, 'ks': -ks}} replaces the 'kn' and 'ks' key values \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(G(state, data={**G.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "GA = Gradient('GA', kn, ks, dp)\n",
    "GB = Gradient('GB', kn - 0.001, ks, dp)\n",
    "\n",
    "print(GA(state) - GB(state, data={**GB.table(), **{'kn': + 0.001}}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "5ddbeefa-aebe-4d0f-878e-32e8fd24a294",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "dp = 0.005\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "G = Gradient('G', kn, ks, dp)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=G.dtype, device=G.device)\n",
    "\n",
    "print(torch.vmap(G)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, kn, ks):\n",
    "    return G(state, data={**G.table(), **{'kn': kn, 'ks': ks}})\n",
    "\n",
    "kn = 1.0E-3*torch.randn(512, dtype=G.dtype, device=G.device)\n",
    "ks = 1.0E-3*torch.randn(512, dtype=G.dtype, device=G.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, kn, ks).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "4a66a9ac-180a-4c5e-8e49-88cf53b78fd0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 1.0000,  0.0000,  0.0000,  0.0000],\n",
      "        [-0.0050,  1.0000, -0.0025,  0.0000],\n",
      "        [ 0.0000,  0.0000,  1.0000,  0.0000],\n",
      "        [-0.0025,  0.0000,  0.0050,  1.0000]], dtype=torch.float64)\n",
      "\n",
      "tensor([[-0.0000,  0.0000],\n",
      "        [-0.0010, -0.0050],\n",
      "        [-0.0000,  0.0000],\n",
      "        [-0.0050,  0.0010]], dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "G = Gradient('G', kn, ks, dp)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(G)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "dkn = torch.tensor(0.0, dtype=torch.float64)\n",
    "dks = torch.tensor(0.0, dtype=torch.float64)\n",
    "dk = torch.stack([dkn, dks])\n",
    "\n",
    "def wrapper(state, dk):\n",
    "    dkn, dks = dk\n",
    "    return G(state, data={**G.table(), **{'kn': dkn, 'ks': dks}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, dk))\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2d39e1ec-6a49-49f0-be16-7d87e66b4b33",
   "metadata": {},
   "source": [
    "# Example-13: Linear (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "e3774f55-fcb6-4b32-855f-640856f2abc7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Can be used to model elements as linear transformations\n",
    "# Constant offset can be used to model first order dispersion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "614d15e9-7236-454b-a328-3129e100a722",
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.dipole import Dipole\n",
    "from model.library.linear import Linear"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "4f736fd9-de5b-4f98-9493-9d414d802936",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.012284014325104016, 0.013015328226371463, 0.005866573649483532, 0.01748719571870364]\n",
      "[0.012284330668424102, 0.013015814342968814, 0.005867420763768485, 0.01748647747810468]\n",
      "[-3.163433200861071e-07, -4.861165973507608e-07, -8.471142849530294e-07, 7.182405989576701e-07]\n"
     ]
    }
   ],
   "source": [
    "# Linear quadrupole\n",
    "\n",
    "length = 1.0\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "Q = Quadrupole('Q', length, kn, ks, dp)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "matrix = torch.func.jacrev(lambda state, dp: Q(state, data={**Q.table(), **{'dp': dp}}), 0)(state, Q.dp)\n",
    "vector = torch.func.jacrev(lambda state, dp: Q(state, data={**Q.table(), **{'dp': dp}}), 1)(state, Q.dp)\n",
    "\n",
    "length = 1.0\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0001\n",
    "Q = Quadrupole('Q', length, kn, ks, dp)\n",
    "\n",
    "L = Linear('L', (dp*vector).tolist(), matrix.tolist())\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "print(Q(state).tolist())\n",
    "print(L(state).tolist())\n",
    "print((Q(state) - L(state)).tolist())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "c9d05c2e-a6f0-4dc0-a62a-a62c2c647850",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2.8326139356223135e-06, -0.005001000818821848, -0.002994615078158236, 0.001004198140800915]\n",
      "[9.165104284458664e-06, -0.004994998958072864, -0.002993748697591074, 0.001004997134048961]\n",
      "[-6.33249034883635e-06, -6.001860748984511e-06, -8.663805671619597e-07, -7.989932480460815e-07]\n"
     ]
    }
   ],
   "source": [
    "# Linear dipole\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "dp = 0.0\n",
    "D = Dipole('D', length, angle, e1, e2, dp)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "matrix = torch.func.jacrev(lambda state, dp: D(state, data={**D.table(), **{'dp': dp}}), 0)(state, D.dp)\n",
    "vector = torch.func.jacrev(lambda state, dp: D(state, data={**D.table(), **{'dp': dp}}), 1)(state, D.dp)\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "dp = 0.0001\n",
    "D = Dipole('D', length, angle, e1, e2, dp)\n",
    "\n",
    "L = Linear('L', (dp*vector).tolist(), matrix.tolist())\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "print(D(state).tolist())\n",
    "print(L(state).tolist())\n",
    "print((D(state) - L(state)).tolist())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ea354b5c-a05a-4e63-80e8-72432ddbc71a",
   "metadata": {},
   "source": [
    "# Example-14: BPM (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "3094cba7-8994-490d-9a9c-cf7c8ea73fbb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.bpm import BPM"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "2875e9f6-0128-4332-b88d-4a876a6495d0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# BPM acts as identity transformation with calibration error\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "B(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "fff40a60-4558-40af-8cc1-aa4b7a20a044",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'xx': tensor(0., dtype=torch.float64),\n",
       " 'xy': tensor(0., dtype=torch.float64),\n",
       " 'yx': tensor(0., dtype=torch.float64),\n",
       " 'yy': tensor(0., dtype=torch.float64),\n",
       " 'dx': tensor(0., dtype=torch.float64),\n",
       " 'dy': tensor(0., dtype=torch.float64),\n",
       " 'dz': tensor(0., dtype=torch.float64),\n",
       " 'wx': tensor(0., dtype=torch.float64),\n",
       " 'wy': tensor(0., dtype=torch.float64),\n",
       " 'wz': tensor(0., dtype=torch.float64)}"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Calibration errors can be passed as deviation variables\n",
    "\n",
    "# qx -> xx qx + xy qy\n",
    "# qy -> yx qx + yy qy\n",
    "\n",
    "B.table()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "96342c98-66a8-4828-919c-d6de4148847e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "tensor([ 0.0105, -0.0048, -0.0042,  0.0011], dtype=torch.float64)\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Transform to BPM frame and back to beam frame\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "print(state)\n",
    "\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)\n",
    "\n",
    "B.direction = 'inverse'\n",
    "\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "5075d077-bfa4-4065-a765-0dce03220938",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "tensor([ 0.0105, -0.0048, -0.0042,  0.0011], dtype=torch.float64)\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Transform to BPM frame and back to beam frame using a pair of BPMS\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "BA = BPM('B', direction='forward')\n",
    "BB = BPM('B', direction='inverse')\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "print(state)\n",
    "\n",
    "state = BA(state, data={**BA.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)\n",
    "\n",
    "state = BB(state, data={**BB.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ef7f9850-585c-4e64-a9d9-309f7fc517c3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 5.0000e-03, -4.0000e-03,  0.0000e+00,  0.0000e+00],\n",
      "        [ 4.5880e-03, -2.4404e-04, -1.0625e-03,  5.6516e-05],\n",
      "        [ 0.0000e+00,  0.0000e+00,  5.0000e-03, -4.0000e-03],\n",
      "        [-4.8809e-05,  5.1249e-03,  1.1303e-05, -1.1868e-03]],\n",
      "       dtype=torch.float64)\n",
      "tensor([[ 0.0000e+00,  8.6736e-19,  0.0000e+00, -5.4888e-19],\n",
      "        [ 0.0000e+00,  0.0000e+00,  3.3881e-20,  0.0000e+00],\n",
      "        [-2.7105e-19,  0.0000e+00,  8.6736e-19,  0.0000e+00],\n",
      "        [ 2.1684e-19,  3.9302e-19, -3.3881e-21,  2.1684e-19]],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "D = Drift('D', 1.0)\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "error = torch.stack([xx, xy, yx, yy])\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "def line(state, error):\n",
    "    xx, xy, yx, yy = error\n",
    "    state = D(state)\n",
    "    state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "    return state\n",
    "    \n",
    "print(torch.func.jacrev(line, 1)(state, error))\n",
    "\n",
    "def line(state, error):\n",
    "    xx, xy, yx, yy = error\n",
    "    state = D(state)\n",
    "    B.direction = 'forward'\n",
    "    state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "    B.direction = 'inverse'\n",
    "    state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "    return state\n",
    "    \n",
    "print(torch.func.jacrev(line, 1)(state, error))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "38d5bf9c-03dd-4ae9-949f-5024913df66f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0105, -0.0048, -0.0042,  0.0011], dtype=torch.float64)\n",
      "tensor([ 0.0086, -0.0048, -0.0082,  0.0008], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Alignment support\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}, **error})\n",
    "print(state)\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}, **error}, alignment=True)\n",
    "print(state)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37e17f59-4312-4476-86b1-090baf77b82a",
   "metadata": {},
   "source": [
    "# Example-15: Line (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "99804e4c-198f-4b74-b35d-4da7d066c585",
   "metadata": {},
   "outputs": [],
   "source": [
    "# In this example line usage is illustrated"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "72ddc9bb-790a-4505-9855-c812ab3c8367",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import matplotlib\n",
    "from matplotlib import pyplot as plt\n",
    "matplotlib.rcParams['text.usetex'] = True\n",
    "\n",
    "import torch\n",
    "\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.sextupole import Sextupole\n",
    "from model.library.dipole import Dipole\n",
    "from model.library.line import Line"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8779d6c6-dd7b-4def-be01-f1c4de04b196",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define unique elements\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.25)\n",
    "QD = Quadrupole('QD', 0.5, -0.20)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Dipole('BM', 3.50, torch.pi/8.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0ab37b81-2203-439f-ad56-a9844b69a4f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define a line\n",
    "# With propagate flag, values for other flags will be propagated to all root elements (but not to lines!)\n",
    "\n",
    "FODO = Line('FODO', \n",
    "            [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], \n",
    "            propagate=True, \n",
    "            dp=0.0, \n",
    "            exact=False, \n",
    "            output=False,\n",
    "            matrix = False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "9373e0b2-186a-4a9e-a5be-d462d80d3478",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Similar to elements, lines have to variants of call method\n",
    "\n",
    "# 1) without deviation variables\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "print(FODO(state))\n",
    "\n",
    "# 2) without deviation variables (defaut dictionary)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "print(FODO(state, data=FODO.table()))\n",
    "\n",
    "# In both cases, it is possible to apply alignments errors using alignment flag\n",
    "# Alignment errors can be applied to elements and to line as a whole (see examples below)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "48b097f3-083e-486f-a05c-bcf5c531e793",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'QF': {'kn': tensor(0., dtype=torch.float64),\n",
       "  'ks': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'DR': {'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'SF': {'ms': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'BM': {'dw': tensor(0., dtype=torch.float64),\n",
       "  'e1': tensor(0., dtype=torch.float64),\n",
       "  'e2': tensor(0., dtype=torch.float64),\n",
       "  'kn': tensor(0., dtype=torch.float64),\n",
       "  'ks': tensor(0., dtype=torch.float64),\n",
       "  'ms': tensor(0., dtype=torch.float64),\n",
       "  'mo': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'SD': {'ms': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'QD': {'kn': tensor(0., dtype=torch.float64),\n",
       "  'ks': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)}}"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Values of deviation variables can be passed only to unique elements\n",
    "\n",
    "FODO.table(alignment=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "82570947-6828-4512-b786-1403ae4871ff",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=FODO.dtype, device=FODO.device)\n",
    "print(torch.vmap(FODO)(state).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "47fc6727-a7c8-4aea-a070-ce451cdda266",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions and parameters\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=FODO.dtype, device=FODO.device)\n",
    "dknqf = 1.0E-3*torch.randn(512, dtype=FODO.dtype, device=FODO.device)\n",
    "\n",
    "def wrapper(state, dknqf):\n",
    "    data = FODO.table()\n",
    "    data['QF']['kn'] = dknqf\n",
    "    return FODO(state, data=data)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dknqf).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "91693306-3aa5-443c-8936-f70d778dac5d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[-0.4395, 15.4433,  0.0000,  0.0000],\n",
      "        [-0.0522, -0.4395,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  0.4963,  5.3596],\n",
      "        [ 0.0000,  0.0000, -0.1406,  0.4963]], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability (state)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "print(torch.func.jacrev(FODO)(state))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "cfdd131a-2aad-4429-a04e-9d911da90d26",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability (parameter)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "dknqf = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(dknqf):\n",
    "    data = FODO.table()\n",
    "    data['QF']['kn'] = dknqf\n",
    "    return FODO(state, data=data)\n",
    "\n",
    "print(torch.func.jacrev(wrapper)(dknqf))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "8d7eb47f-b2c6-41b7-99ac-3f4d9bc56b63",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[-0.4395, 15.4433,  0.0000,  0.0000],\n",
      "        [-0.0522, -0.4395,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  0.4963,  5.3596],\n",
      "        [ 0.0000,  0.0000, -0.1406,  0.4963]], dtype=torch.float64)\n",
      "tensor([[-7.5649, -3.8172,  0.0000,  0.0000],\n",
      "        [ 0.4176, -7.5649,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  2.7423,  1.3262],\n",
      "        [ 0.0000,  0.0000,  0.5426,  2.7423]], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability (composed)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "dknqf = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(dknqf):\n",
    "    data = FODO.table()\n",
    "    data['QF']['kn'] = dknqf\n",
    "    return torch.func.jacrev(lambda state, data: FODO(state, data=data))(state, data)\n",
    "\n",
    "print(wrapper(dknqf))\n",
    "print(torch.func.jacrev(wrapper)(dknqf))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "87afaf52-e7aa-4219-93e5-d271c7f15b90",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7.24 s, sys: 4.76 ms, total: 7.25 s\n",
      "Wall time: 7.25 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "# Tracking\n",
    "\n",
    "# Note, in general tracking is slow\n",
    "# This is especially the case for exact integration of elements with large number of slices\n",
    "\n",
    "qx = torch.linspace(0.0, 0.01, 16, dtype=torch.float64)\n",
    "px = torch.zeros_like(qx)\n",
    "qy = torch.zeros_like(qx)\n",
    "py = torch.zeros_like(qx)\n",
    "\n",
    "state = torch.stack([qx, px, qy, py]).T\n",
    "orbit = []\n",
    "\n",
    "for _ in range(2**10):\n",
    "    state = torch.vmap(FODO)(state)\n",
    "    orbit.append(state)\n",
    "\n",
    "qx, px, *_ = torch.stack(orbit).swapaxes(0, -1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "a2cf3720-6952-434f-8f21-01beda3bb8d7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 400x400 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Plot trajectories\n",
    "\n",
    "plt.figure(figsize=(4, 4))\n",
    "plt.scatter(qx.cpu().numpy(), px.cpu().numpy(), s=1, color='black')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4dbe0c31-2a03-4dd0-9230-d6663bf8c426",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "\n",
    "# Output can be collected at each integration step\n",
    "# Note, container is overwritten at each call\n",
    "\n",
    "FODO.ns = 0.01\n",
    "FODO.output = True\n",
    "\n",
    "state = torch.tensor([+0.01, 0.0, -0.01, 0.0], dtype=torch.float64)\n",
    "orbit = []\n",
    "for _ in range(16):\n",
    "    state = FODO(state)\n",
    "    orbit.append(FODO.container_output)\n",
    "qx, _, qy, _  = torch.vstack(orbit).T\n",
    "\n",
    "plt.figure(figsize=(8, 2))\n",
    "plt.scatter(range(len(qx)), qx.cpu().numpy(), s=1, color='blue')\n",
    "plt.scatter(range(len(qy)), qy.cpu().numpy(), s=1, color='red')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fc1160cc-c4f4-406e-8731-18629f03c9e3",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "\n",
    "# Functions can be compiled, but note that dynamo unrolls loops completely (torch 2.4)\n",
    "# This leads to very long compilation times\n",
    "\n",
    "FODO.ns = 1\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "table = 1.0E-3*torch.randn((512, 4), dtype=FODO.dtype, device=FODO.device)\n",
    "\n",
    "fodo = torch.compile(FODO)\n",
    "fodo(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9accb757-afef-43ea-b322-18e1707a3954",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%timeit\n",
    "\n",
    "FODO(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "33ded75c-6342-470f-972b-b883f6295d34",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%timeit\n",
    "\n",
    "fodo(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9323a3b7-0e75-42f3-a283-46816242eb64",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%timeit\n",
    "\n",
    "_ = torch.vmap(FODO)(table)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0fe47bba-3e74-48ff-bff6-37c1f3980ef9",
   "metadata": {},
   "outputs": [],
   "source": [
    "%%timeit\n",
    "\n",
    "_ = torch.vmap(fodo)(table)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62632473-9c09-4fb4-a02a-181bd2863eb8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Note, compositional operations (map or jacobian seems to break/ignore compiled version)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3e38cba7-7fbf-46b5-bb62-6b953578d8a9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# name (property)\n",
    "# This property can be used to get/set line name\n",
    "\n",
    "FODO.name"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b6d2fc70-f6d1-412c-8ea9-b545de461d26",
   "metadata": {},
   "outputs": [],
   "source": [
    "# sequence (property)\n",
    "# Contains ordered sequence of elements\n",
    "# Elements can be added or removed from it\n",
    "\n",
    "len(FODO.sequence)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9427bf24-8f57-40db-89de-1ae2873760c9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# unique (property)\n",
    "# name: (type, length, angle) data for all unique elements\n",
    "\n",
    "FODO.unique"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b93ee2c5-855c-433c-87e9-072a6dcc7e2a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# length (property)\n",
    "\n",
    "FODO.length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bae73748-f864-4687-b81b-9eb89a8e0f2f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# angle (property)\n",
    "\n",
    "FODO.angle"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0469183e-dac9-4792-a190-98b1081eb216",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ns (property)\n",
    "# This property can be used to get/set number of integration steps to unique elements\n",
    "\n",
    "# Set value integration steps to all elements\n",
    "\n",
    "FODO.ns = 10\n",
    "print(FODO.ns)\n",
    "\n",
    "# Set ceil(element.length/value) integration steps to each element\n",
    "\n",
    "FODO.ns = 0.1\n",
    "print(FODO.ns)\n",
    "\n",
    "# Set by name or type\n",
    "\n",
    "FODO.ns = (('DR', 1), ('Sextupole', 0.01))\n",
    "print(FODO.ns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "635af0f5-1cbb-474c-8dff-5e4ad55e2fb3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# order (property)\n",
    "# This property can be used to get/set integration order to unique elements\n",
    "\n",
    "# Set value integration steps to all elements\n",
    "\n",
    "FODO.order = 0\n",
    "print(FODO.order)\n",
    "\n",
    "# Set by name or type\n",
    "\n",
    "FODO.order = (('BM', 1), ('Sextupole', 1))\n",
    "print(FODO.order)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5fc306a4-8dd9-41e4-acfd-4f31d469f80f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Nested lines\n",
    "# Note, flags for lines are not propagated\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "RING = Line('RING', 8*[FODO], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "RING.ns = 1\n",
    "print(RING.ns)\n",
    "\n",
    "RING.order = 0\n",
    "print(RING.order)\n",
    "\n",
    "# Note, sublines are not flattened\n",
    "\n",
    "print(len(RING.sequence))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dd4c2418-8baf-460d-9fcb-ef989a65c630",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Tracking, mapping and differentiation is similar to flat lines\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "RING(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d41ef33e-c41b-4072-b59c-7a632a7f2ff2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Deviation table contains unique lines with unique elements (unique by names)\n",
    "\n",
    "RING.table(alignment=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ca15becf-4999-487d-8155-1fc37bde9563",
   "metadata": {},
   "outputs": [],
   "source": [
    "# If this can be used to pass different values of deviation variables to unique elements\n",
    "# But values should match for consistent differentiation\n",
    "\n",
    "LA = Line('LA', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "LB = Line('LB', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "RING = Line('RING', [LA, LB], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "state = torch.tensor([0.01, 0.0, 0.01, 0.0], dtype=torch.float64)\n",
    "\n",
    "kn = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "data = RING.table()\n",
    "\n",
    "data['LA']['QF']['kn'] = kn\n",
    "data['LB']['QF']['kn'] = kn\n",
    "\n",
    "print(RING(state, data=data))\n",
    "\n",
    "kna = torch.tensor(+0.01, dtype=torch.float64)\n",
    "knb = torch.tensor(-0.01, dtype=torch.float64)\n",
    "\n",
    "data['LA']['QF']['kn'] = kna\n",
    "data['LB']['QF']['kn'] = knb\n",
    "\n",
    "print(RING(state, data=data))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aae17708-cf03-4326-abf3-a8a921b01341",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Modulation\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "dkf = 1.0E-3*torch.randn(2**10, dtype=torch.float64)\n",
    "dkd = 1.0E-3*torch.randn(2**10, dtype=torch.float64)\n",
    "\n",
    "qx = torch.linspace(0.0, 0.01, 8, dtype=torch.float64)\n",
    "px = torch.zeros_like(qx)\n",
    "qy = torch.zeros_like(qx)\n",
    "py = torch.zeros_like(qx)\n",
    "\n",
    "state = torch.stack([qx, px, qy, py]).T\n",
    "orbit = []\n",
    "\n",
    "data = FODO.table()\n",
    "\n",
    "for i in range(2**10):\n",
    "    data['QF']['kn'] = dkf[i]\n",
    "    data['QD']['kn'] = dkd[i]\n",
    "    state = torch.vmap(lambda state: FODO(state, data=data))(state)\n",
    "    orbit.append(state)\n",
    "\n",
    "qx, px, *_ = torch.stack(orbit).swapaxes(0, -1)\n",
    "\n",
    "plt.figure(figsize=(4, 4))\n",
    "plt.scatter(qx.cpu().numpy(), px.cpu().numpy(), s=1, color='black')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0aa4bfef-875b-4316-90cc-5da11fcf852b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Nested alignment (test without bending)\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.25)\n",
    "QD = Quadrupole('QD', 0.5, -0.20)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Drift('BM', 3.50)\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "state = torch.tensor([+0.01, 0.0, -0.01, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "dx_qf = torch.tensor(0.01, dtype=torch.float64)\n",
    "dx_qd = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "# 2x quadrupoles\n",
    "\n",
    "data = FODO.table()\n",
    "data['dx'] = 0*dx\n",
    "data['QF']['dx'] = 2*dx_qf\n",
    "data['QD']['dx'] = 2*dx_qd\n",
    "\n",
    "print(FODO(state, data=data, alignment=True).tolist())\n",
    "\n",
    "# 1x quadrupoles and 1x fodo\n",
    "\n",
    "data['dx'] = 1*dx\n",
    "data['QF']['dx'] = 1*dx_qf\n",
    "data['QD']['dx'] = 1*dx_qd\n",
    "\n",
    "print(FODO(state, data=data, alignment=True).tolist())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9c931b81-529c-4140-974a-443b155015d4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Matrix output and twiss parameters\n",
    "\n",
    "from twiss import twiss\n",
    "from twiss import propagate\n",
    "from twiss import wolski_to_cs\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.25)\n",
    "QD = Quadrupole('QD', 0.5, -0.20)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Dipole('BM', 3.50, torch.pi/8.0)\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, matrix=True)\n",
    "FODO.ns = 0.01\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "print(torch.func.jacrev(FODO)(state))\n",
    "print()\n",
    "\n",
    "out, *ms = FODO.container_matrix\n",
    "for m in ms:\n",
    "   out = m @ out\n",
    "print(out)\n",
    "print()\n",
    "\n",
    "*_, w = twiss(out)\n",
    "ws = [w]\n",
    "\n",
    "for m in FODO.container_matrix:\n",
    "    w = propagate(w, m)\n",
    "    ws.append(w)\n",
    "\n",
    "ws = torch.stack(ws)\n",
    "\n",
    "_, bx, _, by = torch.vmap(wolski_to_cs)(ws).T\n",
    "\n",
    "s = torch.linspace(0.0, 12.0, len(bx), dtype=torch.float64)\n",
    "\n",
    "plt.figure(figsize=(8, 4))\n",
    "plt.scatter(s.cpu().numpy(), bx.cpu().numpy(), s=1, color='blue')\n",
    "plt.scatter(s.cpu().numpy(), by.cpu().numpy(), s=1, color='red')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f49b651-b89b-45e7-b198-19ea182d4bab",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [
    "myt0_gMIOq7b",
    "5d97819c"
   ],
   "name": "03_frequency.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.1"
  },
  "latex_envs": {
   "LaTeX_envs_menu_present": true,
   "autoclose": false,
   "autocomplete": true,
   "bibliofile": "biblio.bib",
   "cite_by": "apalike",
   "current_citInitial": 1,
   "eqLabelWithNumbers": true,
   "eqNumInitial": 1,
   "hotkeys": {
    "equation": "Ctrl-E",
    "itemize": "Ctrl-I"
   },
   "labels_anchors": false,
   "latex_user_defs": false,
   "report_style_numbering": false,
   "user_envs_cfg": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
