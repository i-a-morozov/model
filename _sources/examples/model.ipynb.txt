{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "556562f3-8ece-4517-8c93-ee5e2fc29131",
   "metadata": {},
   "source": [
    "# Example-01: Optimizaion (import/export API)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "baa39129-4d73-44c2-bf1e-88996ea48c84",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Loading API facilitates (suboptimal) interface with different optimization libraries\n",
    "# In this example, quadrupole gradients are used to fit beta functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7aa2bbf6-cfe5-49c1-b9a7-de7cce585bbe",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "\n",
    "from model.external import load_sdds\n",
    "from model.external import load_lattice\n",
    "from model.external import text_lattice\n",
    "\n",
    "import numpy\n",
    "from numpy import ndarray as Array\n",
    "\n",
    "from scipy.optimize import minimize"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "540bbb11-ef4b-4f97-9d9a-179af31e0de8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set quadrupole gradient and compute and return twiss parameters\n",
    "\n",
    "def evaluate(knobs:Array) -> Array:\n",
    "    kf, kd = knobs\n",
    "    path:Path = Path('optimize.lte')\n",
    "    lattice:dict[str, dict[str, str | int | float | dict]] = load_lattice(path)\n",
    "    lattice['QF']['K1'] = float(kf)\n",
    "    lattice['QD']['K1'] = float(kd)\n",
    "    with path.open('w') as stream:\n",
    "        stream.write(text_lattice('LTE', lattice))\n",
    "    !elegant 'optimize.ele' > /dev/null\n",
    "    !sddsconvert -ascii 'binary.twiss' 'optimize.twiss'\n",
    "    path:Path = Path('optimize.twiss')\n",
    "    _, columns = load_sdds(path)\n",
    "    return numpy.asarray([[data['betax'], data['betay']] for location, data in columns.items()]).T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f7c9dc5a-7d3e-4b74-a219-82cf714abf3c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set target beta functions\n",
    "\n",
    "target:Array = numpy.asarray([+0.21, -0.19])\n",
    "result:Array = evaluate(target)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "ffdb81b2-1cde-4b44-8133-f442d9c3065c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Set objetive function to minimize\n",
    "\n",
    "def objective(knobs:Array) -> Array:\n",
    "    return numpy.sum((evaluate(knobs) - result)**2)\n",
    "\n",
    "objective(target)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "3dda343b-b675-45c5-9ba3-e2b4f408c0b1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "       message: Optimization terminated successfully.\n",
       "       success: True\n",
       "        status: 0\n",
       "           fun: 1.3489521479279302e-28\n",
       "             x: [ 2.100e-01 -1.900e-01]\n",
       "           nit: 20\n",
       "          nfev: 40\n",
       " final_simplex: (array([[ 2.100e-01, -1.900e-01],\n",
       "                       [ 2.100e-01, -1.900e-01],\n",
       "                       [ 2.100e-01, -1.900e-01]]), array([ 1.349e-28,  2.891e-05,  6.010e-05]))"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Optimize \n",
    "\n",
    "knobs:Array = numpy.asarray([+0.20, -0.20])\n",
    "\n",
    "minimize(objective, knobs, method='Nelder-Mead')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a641003a-ec1b-4ea1-8a46-fcde2f2d52aa",
   "metadata": {},
   "source": [
    "# Example-02: Workflow (MADX)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "0496604d-6bd4-4d4c-a840-ece3c4172509",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "\n",
    "from model.external import load_lattice\n",
    "from model.external import rift_lattice\n",
    "from model.external import text_lattice\n",
    "from model.external import load_tfs\n",
    "from model.external import convert\n",
    "from model.external import add_rc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7133deed-c534-49c0-8d0f-af1f4c8eae5a",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR: DRIFT, L=2.0;\n",
      "BM: SBEND, L=1.0, ANGLE=0.17453292519943295;\n",
      "QF: QUADRUPOLE, L=1.0, K1=+0.2;\n",
      "QD: QUADRUPOLE, L=0.5, K1=-0.2;\n",
      "\n",
      "M: MONITOR,;\n",
      "\n",
      "HEAD: MARKER,; ! TEST: DRIFT,\n",
      "TAIL: MARKER,; ! TEST: DRIFT,\n",
      "\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL) ;\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Given some initial MADX lattice file (FODO)\n",
    "\n",
    "file = Path('initial.madx')\n",
    "\n",
    "with file.open('r') as stream:\n",
    "    print(stream.read())\n",
    "\n",
    "# Several regular elements are defined\n",
    "# HEAD and TAIL should appear as the first and the last elements\n",
    "# All elements should be defined on a single line with numerical parameters\n",
    "# Lattice should be defined using lines\n",
    "# Comma after element type is mandatory\n",
    "# Comments appearing after definitions should also represent an element definition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "532260b3-b100-4f18-807b-751bca5d3671",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR {'KIND': 'DRIFT', 'RC': '', 'L': 2.0}\n",
      "BM {'KIND': 'SBEND', 'RC': '', 'L': 1.0, 'ANGLE': 0.17453292519943295}\n",
      "QF {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 1.0, 'K1': 0.2}\n",
      "QD {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 0.5, 'K1': -0.2}\n",
      "M {'KIND': 'MONITOR', 'RC': ''}\n",
      "HEAD {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "TAIL {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# If element and beamline definitions comply with the above requirements\n",
    "# The lattice file can be loaded as a python dictionary\n",
    "\n",
    "lattice = load_lattice(file)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)\n",
    "\n",
    "# For each element and beamline, a key-value pair in created\n",
    "# Value is itself a dictionary containing all information about the original elements\n",
    "# Each element parameter is casted from string to int, float or string\n",
    "# Comment after element definition is saved into RC (it has a special use case, see below)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "fd93d303-6a15-4462-ad1a-520c7b706e58",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONITOR', 'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]}\n",
      "H_DR {'KIND': 'DRIFT', 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARKER', 'RC': ['BM', {'KIND': 'SBEND', 'L': 1.0, 'ANGLE': 0.17453292519943295}]}\n",
      "H_BM {'KIND': 'SBEND', 'L': 0.5, 'ANGLE': 0.08726646259971647}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "V_QF {'KIND': 'MARKER', 'RC': ['QF', {'KIND': 'QUADRUPOLE', 'L': 1.0, 'K1': 0.2}]}\n",
      "H_QF {'KIND': 'QUADRUPOLE', 'L': 0.5, 'K1': 0.2}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "QD {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 0.5, 'K1': -0.2}\n",
      "M {'KIND': 'MONITOR', 'RC': ''}\n",
      "HEAD {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "TAIL {'KIND': 'MARKER', 'RC': 'TEST: DRIFT,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Error lattice is defined by a set of linear transformations between selected locations\n",
    "# Each locations can be a MONITOR (beam observation) or a VIRTUAL (error)\n",
    "# Two special locatons (HEAD and TAIL) should present in the lattice\n",
    "# Using the above dictionary representation, new observation locations can be inserted\n",
    "# Locations are inserted at the middle of selected elements (selected by type or name)\n",
    "# Selected elements are splitted in half and renamed, old names are binded to beamlines\n",
    "# Original element definitions are added to created location RC\n",
    "# Typicaly, monitor locations correspond to MONITOR elements, but new monitor elements can be also inserted\n",
    "# Virtual locations can be inserted into quadrupole or other elements to represent errors\n",
    "\n",
    "lattice = rift_lattice(lattice, \n",
    "                       'MONITOR', \n",
    "                       'MARKER', \n",
    "                       ['DRIFT'], \n",
    "                       ['SBEND', 'QUADRUPOLE'], \n",
    "                       exclude_virtual=['QD'])\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "eac1cbc9-90b3-420e-84ce-c328fdc48b43",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR: MONITOR,; ! DR: DRIFT, L=2.0,;\n",
      "H_DR: DRIFT, L=1.0,;\n",
      "DR: LINE=(H_DR, M_DR, H_DR);\n",
      "V_BM: MARKER,; ! BM: SBEND, L=1.0, ANGLE=0.17453292519943295,;\n",
      "H_BM: SBEND, L=0.5, ANGLE=0.08726646259971647,;\n",
      "BM: LINE=(H_BM, V_BM, H_BM);\n",
      "V_QF: MARKER,; ! QF: QUADRUPOLE, L=1.0, K1=0.2,;\n",
      "H_QF: QUADRUPOLE, L=0.5, K1=0.2,;\n",
      "QF: LINE=(H_QF, V_QF, H_QF);\n",
      "QD: QUADRUPOLE, L=0.5, K1=-0.2,;\n",
      "M: MONITOR,;\n",
      "HEAD: MARKER,; ! TEST: DRIFT,\n",
      "TAIL: MARKER,; ! TEST: DRIFT,\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL);\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Modified lattice can be converted to text\n",
    "# Comments are added to locations while original comments are preserved\n",
    "\n",
    "text = text_lattice('MADX', lattice, rc=True)\n",
    "\n",
    "print(text)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "0c98bea9-c894-4aed-8d62-97270eb048b2",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Compute TWISS parameters using MADX\n",
    "# TWISS command is appended to modified lattice\n",
    "\n",
    "task = \"\"\"\n",
    "BEAM;\n",
    "USE, PERIOD=FODO;\n",
    "SET,FORMAT=\"20.20f\",\"-20s\";\n",
    "TWISS;\n",
    "WRITE,TABLE=TWISS,FILE=\"final.tfs\";\n",
    "RETURN;\n",
    "\"\"\" ;\n",
    "\n",
    "with Path('final.madx').open('w') as stream:\n",
    "    stream.write(text)\n",
    "    stream.write(task)\n",
    "\n",
    "!madx final.madx > /dev/null"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "3b46c59b-7001-4e0c-aa22-840f3a7302a8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONITOR', 'RC': ['DR', {'KIND': 'DRIFT', 'RC': '', 'L': 2.0}]}\n",
      "H_DR {'KIND': 'DRIFT', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARKER', 'RC': ['BM', {'KIND': 'SBEND', 'RC': '', 'L': 1.0, 'ANGLE': 0.17453292519943295}]}\n",
      "H_BM {'KIND': 'SBEND', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 0.5, 'ANGLE': 0.08726646259971647}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "V_QF {'KIND': 'MARKER', 'RC': ['QF', {'KIND': 'QUADRUPOLE', 'RC': '', 'L': 1.0, 'K1': 0.2}]}\n",
      "H_QF {'KIND': 'QUADRUPOLE', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 0.5, 'K1': 0.2}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "QD {'KIND': 'QUADRUPOLE', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 0.5, 'K1': -0.2}\n",
      "M {'KIND': 'MONITOR', 'RC': ['', {'KIND': '', 'RC': ''}]}\n",
      "HEAD {'KIND': 'MARKER', 'RC': ['TEST', {'KIND': 'DRIFT', 'RC': ''}]}\n",
      "TAIL {'KIND': 'MARKER', 'RC': ['TEST', {'KIND': 'DRIFT', 'RC': ''}]}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Load lattice can be also loaded from file\n",
    "# Original comments will be parsed as elements (look at HEAD and TAIL)\n",
    "# Empty RC will be nested in this case\n",
    "\n",
    "file = Path('final.madx')\n",
    "\n",
    "with file.open('w') as stream:\n",
    "    stream.write(text)\n",
    "\n",
    "lattice = load_lattice(file, rc=True)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "dab4b669-0bfe-47ce-873d-51f064d98ec6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# TWISS results can be loaded into python dictionaries\n",
    "\n",
    "data = Path('final.tfs')\n",
    "parameters, columns = load_tfs(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "2ad82e92-25fe-4f44-bdb1-8709c3cf2570",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'TYPE': 'VIRTUAL',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M': {'TYPE': 'MONITOR',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M_DR': {'TYPE': 'MONITOR',\n",
       "  'S': 1.5,\n",
       "  'BX': 5.980356480296974,\n",
       "  'AX': -0.8524040348462865,\n",
       "  'FX': 0.3068185833848285,\n",
       "  'BY': 15.315159900296642,\n",
       "  'AY': 1.6491678474974667,\n",
       "  'FY': 0.08453149247893033,\n",
       "  'DQX': 1.744126900814982,\n",
       "  'DPX': 0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'V_BM': {'TYPE': 'VIRTUAL',\n",
       "  'S': 3.0,\n",
       "  'BX': 9.120629409698159,\n",
       "  'AX': -1.1465687400023221,\n",
       "  'FX': 0.5107301354647854,\n",
       "  'BY': 10.914137614299745,\n",
       "  'AY': 1.2848470098337954,\n",
       "  'FY': 0.20081415045191314,\n",
       "  'DQX': 1.992896582518225,\n",
       "  'DPX': 0.21385269164968151,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'M_DR_1': {'TYPE': 'MONITOR',\n",
       "  'S': 4.5,\n",
       "  'BX': 12.70896979457465,\n",
       "  'AX': -1.3363966727488819,\n",
       "  'FX': 0.6500917125372264,\n",
       "  'BY': 7.606077841293864,\n",
       "  'AY': 0.9205261721701236,\n",
       "  'FY': 0.3661997931359615,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': 0.26987963222618605,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'V_QF': {'TYPE': 'VIRTUAL',\n",
       "  'S': 6.0,\n",
       "  'BX': 16.392007194825762,\n",
       "  'AX': -8.0415e-16,\n",
       "  'FX': 0.7521811118347426,\n",
       "  'BY': 5.674619594695141,\n",
       "  'AY': -2.5871e-16,\n",
       "  'FY': 0.601131166393595,\n",
       "  'DQX': 2.7214181783177667,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'M_DR_2': {'TYPE': 'MONITOR',\n",
       "  'S': 7.5,\n",
       "  'BX': 12.708969794574653,\n",
       "  'AX': 1.336396672748881,\n",
       "  'FX': 0.8542705111322586,\n",
       "  'BY': 7.606077841293868,\n",
       "  'AY': -0.9205261721701244,\n",
       "  'FY': 0.8360625396512283,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': -0.26987963222618594,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'V_BM_1': {'TYPE': 'VIRTUAL',\n",
       "  'S': 9.0,\n",
       "  'BX': 9.120629409698164,\n",
       "  'AX': 1.146568740002322,\n",
       "  'FX': 0.9936320882046995,\n",
       "  'BY': 10.914137614299747,\n",
       "  'AY': -1.2848470098337954,\n",
       "  'FY': 1.0014481823352765,\n",
       "  'DQX': 1.9928965825182252,\n",
       "  'DPX': -0.21385269164968146,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'M_DR_3': {'TYPE': 'MONITOR',\n",
       "  'S': 10.5,\n",
       "  'BX': 5.980356480296976,\n",
       "  'AX': 0.8524040348462865,\n",
       "  'FX': 1.1975436402846564,\n",
       "  'BY': 15.315159900296639,\n",
       "  'AY': -1.6491678474974665,\n",
       "  'FY': 1.1177308403082595,\n",
       "  'DQX': 1.7441269008149822,\n",
       "  'DPX': -0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None},\n",
       " 'TAIL': {'TYPE': 'VIRTUAL',\n",
       "  'S': 12.0,\n",
       "  'BX': 4.287017735718939,\n",
       "  'AX': 3.6486e-16,\n",
       "  'FX': 1.5043622236694847,\n",
       "  'BY': 19.81848928204488,\n",
       "  'AY': -5.5051e-16,\n",
       "  'FY': 1.2022623327871897,\n",
       "  'DQX': 1.54904104413488,\n",
       "  'DPX': -2.776e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Optics data can be converted into model table\n",
    "# Note, all locations have different name\n",
    "# If an element appear several times in a line, locations are renamed\n",
    "\n",
    "table = convert(columns, 'TFS', ['MONITOR'], ['MARKER'], rc=True)\n",
    "table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "1fefa5f3-e614-4e22-91ff-b21e28e4aeeb",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'TYPE': 'VIRTUAL',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M': {'TYPE': 'MONITOR',\n",
       "  'S': 0.0,\n",
       "  'BX': 4.287017735718936,\n",
       "  'AX': -3.338e-16,\n",
       "  'FX': 0.0,\n",
       "  'BY': 19.818489282044894,\n",
       "  'AY': -2.975e-17,\n",
       "  'FY': 0.0,\n",
       "  'DQX': 1.5490410441348796,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': -0.0,\n",
       "  'RC': None},\n",
       " 'M_DR': {'TYPE': 'MONITOR',\n",
       "  'S': 1.5,\n",
       "  'BX': 5.980356480296974,\n",
       "  'AX': -0.8524040348462865,\n",
       "  'FX': 0.3068185833848285,\n",
       "  'BY': 15.315159900296642,\n",
       "  'AY': 1.6491678474974667,\n",
       "  'FY': 0.08453149247893033,\n",
       "  'DQX': 1.744126900814982,\n",
       "  'DPX': 0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'V_BM': {'TYPE': 'VIRTUAL',\n",
       "  'S': 3.0,\n",
       "  'BX': 9.120629409698159,\n",
       "  'AX': -1.1465687400023221,\n",
       "  'FX': 0.5107301354647854,\n",
       "  'BY': 10.914137614299745,\n",
       "  'AY': 1.2848470098337954,\n",
       "  'FY': 0.20081415045191314,\n",
       "  'DQX': 1.992896582518225,\n",
       "  'DPX': 0.21385269164968151,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['BM', {'KIND': 'SBEND', 'L': 1.0, 'ANGLE': 0.17453292519943295}]},\n",
       " 'M_DR_1': {'TYPE': 'MONITOR',\n",
       "  'S': 4.5,\n",
       "  'BX': 12.70896979457465,\n",
       "  'AX': -1.3363966727488819,\n",
       "  'FX': 0.6500917125372264,\n",
       "  'BY': 7.606077841293864,\n",
       "  'AY': 0.9205261721701236,\n",
       "  'FY': 0.3661997931359615,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': 0.26987963222618605,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'V_QF': {'TYPE': 'VIRTUAL',\n",
       "  'S': 6.0,\n",
       "  'BX': 16.392007194825762,\n",
       "  'AX': -8.0415e-16,\n",
       "  'FX': 0.7521811118347426,\n",
       "  'BY': 5.674619594695141,\n",
       "  'AY': -2.5871e-16,\n",
       "  'FY': 0.601131166393595,\n",
       "  'DQX': 2.7214181783177667,\n",
       "  'DPX': 5.551e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['QF', {'KIND': 'QUADRUPOLE', 'L': 1.0, 'K1': 0.2}]},\n",
       " 'M_DR_2': {'TYPE': 'MONITOR',\n",
       "  'S': 7.5,\n",
       "  'BX': 12.708969794574653,\n",
       "  'AX': 1.336396672748881,\n",
       "  'FX': 0.8542705111322586,\n",
       "  'BY': 7.606077841293868,\n",
       "  'AY': -0.9205261721701244,\n",
       "  'FY': 0.8360625396512283,\n",
       "  'DQX': 2.3837861006470566,\n",
       "  'DPX': -0.26987963222618594,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'V_BM_1': {'TYPE': 'VIRTUAL',\n",
       "  'S': 9.0,\n",
       "  'BX': 9.120629409698164,\n",
       "  'AX': 1.146568740002322,\n",
       "  'FX': 0.9936320882046995,\n",
       "  'BY': 10.914137614299747,\n",
       "  'AY': -1.2848470098337954,\n",
       "  'FY': 1.0014481823352765,\n",
       "  'DQX': 1.9928965825182252,\n",
       "  'DPX': -0.21385269164968146,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['BM', {'KIND': 'SBEND', 'L': 1.0, 'ANGLE': 0.17453292519943295}]},\n",
       " 'M_DR_3': {'TYPE': 'MONITOR',\n",
       "  'S': 10.5,\n",
       "  'BX': 5.980356480296976,\n",
       "  'AX': 0.8524040348462865,\n",
       "  'FX': 1.1975436402846564,\n",
       "  'BY': 15.315159900296639,\n",
       "  'AY': -1.6491678474974665,\n",
       "  'FY': 1.1177308403082595,\n",
       "  'DQX': 1.7441269008149822,\n",
       "  'DPX': -0.1561982029636459,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': ['DR', {'KIND': 'DRIFT', 'L': 2.0}]},\n",
       " 'TAIL': {'TYPE': 'VIRTUAL',\n",
       "  'S': 12.0,\n",
       "  'BX': 4.287017735718939,\n",
       "  'AX': 3.6486e-16,\n",
       "  'FX': 1.5043622236694847,\n",
       "  'BY': 19.81848928204488,\n",
       "  'AY': -5.5051e-16,\n",
       "  'FY': 1.2022623327871897,\n",
       "  'DQX': 1.54904104413488,\n",
       "  'DPX': -2.776e-17,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# RC parameter from lattice data can be added to model table\n",
    "# Configuration table can be saved using util.save\n",
    "\n",
    "table = add_rc(table, lattice)\n",
    "table"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "70706793-5a95-4598-8d45-2208eb0a54fd",
   "metadata": {},
   "source": [
    "# Example-03: Workflow (ELEGANT)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "c7155f5d-e16a-4374-979a-b3477eee7a55",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "\n",
    "from model.external import load_lattice\n",
    "from model.external import rift_lattice\n",
    "from model.external import text_lattice\n",
    "from model.external import load_sdds\n",
    "from model.external import convert\n",
    "from model.external import add_rc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7f0167ee-1eb5-4a03-a06e-c6256c2f08a2",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR: DRIF,l=2\n",
      "\n",
      "BM: CSBEND,angle=0.17453292519943295,fint=0,l=1.0\n",
      "QD: QUAD,k1=-0.2,l=0.5\n",
      "QF: QUAD,k1=0.2,l=1.0\n",
      "\n",
      "M: MONI,\n",
      "\n",
      "HEAD: MARK, ! TEST: DRIF,\n",
      "TAIL: MARK, ! TEST: DRIF,\n",
      "\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL)\n"
     ]
    }
   ],
   "source": [
    "# Given some initial ELEGANT lattice file (FODO)\n",
    "\n",
    "file = Path('initial.lte')\n",
    "\n",
    "with file.open('r') as stream:\n",
    "    print(stream.read())\n",
    "\n",
    "# Several regular elements are defined\n",
    "# HEAD and TAIL should appear as the first and the last elements\n",
    "# All elements should be defined on a single line with numerical parameters\n",
    "# Lattice should be defined using lines\n",
    "# Comma after element type is mandatory\n",
    "# Comments appearing after definitions should also represent an element definition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "39ce25e6-47b7-4ec8-960c-b21b60fd99d6",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "DR {'KIND': 'DRIF', 'RC': '', 'L': 2}\n",
      "BM {'KIND': 'CSBEND', 'RC': '', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}\n",
      "QD {'KIND': 'QUAD', 'RC': '', 'K1': -0.2, 'L': 0.5}\n",
      "QF {'KIND': 'QUAD', 'RC': '', 'K1': 0.2, 'L': 1.0}\n",
      "M {'KIND': 'MONI', 'RC': ''}\n",
      "HEAD {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "TAIL {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# If element and beamline definitions comply with the above requirements\n",
    "# The lattice file can be loaded as a python dictionary\n",
    "\n",
    "lattice = load_lattice(file)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)\n",
    "\n",
    "# For each element and beamline, a key-value pair in created\n",
    "# Value is itself a dictionary containing all information about the original elements\n",
    "# Each element parameter is casted from string to int, float or string\n",
    "# Comment after element definition is saved into RC (it has a special use case, see below)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e0b8b369-29dc-4dc8-859b-658a0a17545e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONI', 'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]}\n",
      "H_DR {'KIND': 'DRIF', 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARK', 'RC': ['BM', {'KIND': 'CSBEND', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]}\n",
      "H_BM {'KIND': 'CSBEND', 'ANGLE': 0.08726646259971647, 'FINT': 0, 'L': 0.5}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "QD {'KIND': 'QUAD', 'RC': '', 'K1': -0.2, 'L': 0.5}\n",
      "V_QF {'KIND': 'MARK', 'RC': ['QF', {'KIND': 'QUAD', 'K1': 0.2, 'L': 1.0}]}\n",
      "H_QF {'KIND': 'QUAD', 'K1': 0.2, 'L': 0.5}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "M {'KIND': 'MONI', 'RC': ''}\n",
      "HEAD {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "TAIL {'KIND': 'MARK', 'RC': 'TEST: DRIF,'}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Error lattice is defined by a set of linear transformations between selected locations\n",
    "# Each locations can be a MONITOR (beam observation) or a VIRTUAL (error)\n",
    "# Two special locatons (HEAD and TAIL) should present in the lattice\n",
    "# Using the above dictionary representation, new observation locations can be inserted\n",
    "# Locations are inserted at the middle of selected elements (selected by type or name)\n",
    "# Selected elements are splitted in half and renamed, old names are binded to beamlines\n",
    "# Original element definitions are added to created location RC\n",
    "# Typicaly, monitor locations correspond to MONITOR elements, but new monitor elements can be also inserted\n",
    "# Virtual locations can be inserted into quadrupole or other elements to represent errors\n",
    "\n",
    "lattice = rift_lattice(lattice, \n",
    "                       'MONI', \n",
    "                       'MARK', \n",
    "                       ['DRIF'], \n",
    "                       ['CSBEND', 'QUAD'], \n",
    "                       exclude_virtual=['QD'])\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e7f72d66-2ac0-4a6f-b12d-45410acd13f5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR: MONI, ! DR: DRIF, L=2,\n",
      "H_DR: DRIF, L=1.0,\n",
      "DR: LINE=(H_DR, M_DR, H_DR)\n",
      "V_BM: MARK, ! BM: CSBEND, ANGLE=0.17453292519943295, FINT=0, L=1.0,\n",
      "H_BM: CSBEND, ANGLE=0.08726646259971647, FINT=0, L=0.5,\n",
      "BM: LINE=(H_BM, V_BM, H_BM)\n",
      "QD: QUAD, K1=-0.2, L=0.5,\n",
      "V_QF: MARK, ! QF: QUAD, K1=0.2, L=1.0,\n",
      "H_QF: QUAD, K1=0.2, L=0.5,\n",
      "QF: LINE=(H_QF, V_QF, H_QF)\n",
      "M: MONI,\n",
      "HEAD: MARK, ! TEST: DRIF,\n",
      "TAIL: MARK, ! TEST: DRIF,\n",
      "FODO: LINE=(HEAD, M, QD, DR, BM, DR, QF, DR, BM, DR, QD, TAIL)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Modified lattice can be converted to text\n",
    "# Comments are added to locations while original comments are preserved\n",
    "\n",
    "text = text_lattice('LTE', lattice, rc=True)\n",
    "\n",
    "print(text)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "4ec13d02-ae33-4d58-ade9-125c00fcc90a",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Compute TWISS parameters using ELEGANT\n",
    "# Separate command file is created\n",
    "\n",
    "with Path('final.lte').open('w') as stream:\n",
    "    stream.write(text)\n",
    "\n",
    "task = \"\"\"\n",
    "&run_setup\n",
    "  use_beamline=\"FODO\",\n",
    "  lattice = \"final.lte\",\n",
    "  p_central_mev = 1000\n",
    "&end\n",
    "\n",
    "&run_control\n",
    "&end\n",
    "\n",
    "&twiss_output\n",
    "  filename = \"binary.twiss\",\n",
    "  output_at_each_step = 1\n",
    "&end\n",
    "\n",
    "&bunched_beam\n",
    "&end\n",
    "\n",
    "&track\n",
    "&end\n",
    "\"\"\" ;\n",
    "\n",
    "with Path('final.ele').open('w') as stream:\n",
    "    stream.write(task)\n",
    "\n",
    "!elegant final.ele > /dev/null\n",
    "!sddsconvert -ascii binary.twiss final.twiss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "86013097-d261-486b-b2af-35f9604b6351",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "M_DR {'KIND': 'MONI', 'RC': ['DR', {'KIND': 'DRIF', 'RC': '', 'L': 2}]}\n",
      "H_DR {'KIND': 'DRIF', 'RC': ['', {'KIND': '', 'RC': ''}], 'L': 1.0}\n",
      "DR {'KIND': 'LINE', 'SEQUENCE': ['H_DR', 'M_DR', 'H_DR']}\n",
      "V_BM {'KIND': 'MARK', 'RC': ['BM', {'KIND': 'CSBEND', 'RC': '', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]}\n",
      "H_BM {'KIND': 'CSBEND', 'RC': ['', {'KIND': '', 'RC': ''}], 'ANGLE': 0.08726646259971647, 'FINT': 0, 'L': 0.5}\n",
      "BM {'KIND': 'LINE', 'SEQUENCE': ['H_BM', 'V_BM', 'H_BM']}\n",
      "QD {'KIND': 'QUAD', 'RC': ['', {'KIND': '', 'RC': ''}], 'K1': -0.2, 'L': 0.5}\n",
      "V_QF {'KIND': 'MARK', 'RC': ['QF', {'KIND': 'QUAD', 'RC': '', 'K1': 0.2, 'L': 1.0}]}\n",
      "H_QF {'KIND': 'QUAD', 'RC': ['', {'KIND': '', 'RC': ''}], 'K1': 0.2, 'L': 0.5}\n",
      "QF {'KIND': 'LINE', 'SEQUENCE': ['H_QF', 'V_QF', 'H_QF']}\n",
      "M {'KIND': 'MONI', 'RC': ['', {'KIND': '', 'RC': ''}]}\n",
      "HEAD {'KIND': 'MARK', 'RC': ['TEST', {'KIND': 'DRIF', 'RC': ''}]}\n",
      "TAIL {'KIND': 'MARK', 'RC': ['TEST', {'KIND': 'DRIF', 'RC': ''}]}\n",
      "FODO {'KIND': 'LINE', 'SEQUENCE': ['HEAD', 'M', 'QD', 'DR', 'BM', 'DR', 'QF', 'DR', 'BM', 'DR', 'QD', 'TAIL']}\n"
     ]
    }
   ],
   "source": [
    "# Load lattice can be also loaded from file\n",
    "# Original comments will be parsed as elements (look at HEAD and TAIL)\n",
    "# Empty RC will be nested in this case\n",
    "\n",
    "file = Path('final.lte')\n",
    "\n",
    "with file.open('w') as stream:\n",
    "    stream.write(text)\n",
    "\n",
    "lattice = load_lattice(file, rc=True)\n",
    "\n",
    "for key, value in lattice.items():\n",
    "    print(key, value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "e299a720-b7ad-4cbb-b281-014ad87322fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "# TWISS results can be loaded into python dictionaries\n",
    "\n",
    "data = Path('final.twiss')\n",
    "parameters, columns = load_sdds(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "8cd4345e-effb-48f1-ad46-c824e242d55f",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'M_DR': {'S': 1.5,\n",
       "  'BX': 5.980356479284525,\n",
       "  'AX': -0.8524040348212205,\n",
       "  'FX': 0.3068185834444499,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': 0.1561981825607101,\n",
       "  'BY': 15.31515988971357,\n",
       "  'AY': 1.649167846239909,\n",
       "  'FY': 0.08453149253790615,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'V_BM': {'S': 3.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': -1.146568740048648,\n",
       "  'FX': 0.5107301355818847,\n",
       "  'DQX': 1.99289632225274,\n",
       "  'DPX': 0.2138526637243729,\n",
       "  'BY': 10.91413760701325,\n",
       "  'AY': 1.284847009200138,\n",
       "  'FY': 0.2008141505892614,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M_DR_1': {'S': 4.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': -1.336396672789745,\n",
       "  'FX': 0.6500917126795847,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': 0.2698795969893243,\n",
       "  'BY': 7.606077834992553,\n",
       "  'AY': 0.9205261718281931,\n",
       "  'FY': 0.3661997933967667,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'V_QF': {'S': 6.0,\n",
       "  'BX': 16.39200719526896,\n",
       "  'AX': 3.608224830031759e-16,\n",
       "  'FX': 0.7521811119743597,\n",
       "  'DQX': 2.721417822995524,\n",
       "  'DPX': -5.551115123125783e-17,\n",
       "  'BY': 5.674619589422572,\n",
       "  'AY': 8.326672684688672e-16,\n",
       "  'FY': 0.6011311668647427,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M_DR_2': {'S': 7.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': 1.336396672789746,\n",
       "  'FX': 0.8542705112691347,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': -0.2698795969893243,\n",
       "  'BY': 7.606077834992548,\n",
       "  'AY': -0.920526171828191,\n",
       "  'FY': 0.8360625403327188,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'V_BM_1': {'S': 9.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': 1.146568740048649,\n",
       "  'FX': 0.9936320883668346,\n",
       "  'DQX': 1.992896322252739,\n",
       "  'DPX': -0.2138526637243729,\n",
       "  'BY': 10.91413760701323,\n",
       "  'AY': -1.284847009200136,\n",
       "  'FY': 1.001448183140224,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M_DR_3': {'S': 10.5,\n",
       "  'BX': 5.980356479284523,\n",
       "  'AX': 0.852404034821221,\n",
       "  'FX': 1.197543640504269,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': -0.1561981825607101,\n",
       "  'BY': 15.31515988971355,\n",
       "  'AY': -1.649167846239906,\n",
       "  'FY': 1.11773084119158,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'TAIL': {'S': 12.0,\n",
       "  'BX': 4.287017734831201,\n",
       "  'AX': 5.273559366969493e-16,\n",
       "  'FX': 1.50436222394872,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': -1.110223024625157e-16,\n",
       "  'BY': 19.81848926815184,\n",
       "  'AY': 1.387778780781446e-16,\n",
       "  'FY': 1.202262333729486,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Optics data can be converted into model table\n",
    "# Note, all locations have different name\n",
    "# If an element appear several times in a line, locations are renamed\n",
    "\n",
    "table = convert(columns, 'SDDS', ['MONI'], ['MARK'], rc=True)\n",
    "table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "f6d4a121-8d34-4db1-8c09-dbb1fd13317a",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'HEAD': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None},\n",
       " 'M': {'S': 0.0,\n",
       "  'BX': 4.287017734831204,\n",
       "  'AX': -1.321304551729011e-16,\n",
       "  'FX': 0.0,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': 2.775557561562891e-17,\n",
       "  'BY': 19.81848926815186,\n",
       "  'AY': 6.545730027929358e-16,\n",
       "  'FY': 0.0,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': None},\n",
       " 'M_DR': {'S': 1.5,\n",
       "  'BX': 5.980356479284525,\n",
       "  'AX': -0.8524040348212205,\n",
       "  'FX': 0.3068185834444499,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': 0.1561981825607101,\n",
       "  'BY': 15.31515988971357,\n",
       "  'AY': 1.649167846239909,\n",
       "  'FY': 0.08453149253790615,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'V_BM': {'S': 3.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': -1.146568740048648,\n",
       "  'FX': 0.5107301355818847,\n",
       "  'DQX': 1.99289632225274,\n",
       "  'DPX': 0.2138526637243729,\n",
       "  'BY': 10.91413760701325,\n",
       "  'AY': 1.284847009200138,\n",
       "  'FY': 0.2008141505892614,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': ['BM',\n",
       "   {'KIND': 'CSBEND', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]},\n",
       " 'M_DR_1': {'S': 4.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': -1.336396672789745,\n",
       "  'FX': 0.6500917126795847,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': 0.2698795969893243,\n",
       "  'BY': 7.606077834992553,\n",
       "  'AY': 0.9205261718281931,\n",
       "  'FY': 0.3661997933967667,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'V_QF': {'S': 6.0,\n",
       "  'BX': 16.39200719526896,\n",
       "  'AX': 3.608224830031759e-16,\n",
       "  'FX': 0.7521811119743597,\n",
       "  'DQX': 2.721417822995524,\n",
       "  'DPX': -5.551115123125783e-17,\n",
       "  'BY': 5.674619589422572,\n",
       "  'AY': 8.326672684688672e-16,\n",
       "  'FY': 0.6011311668647427,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': ['QF', {'KIND': 'QUAD', 'K1': 0.2, 'L': 1.0}]},\n",
       " 'M_DR_2': {'S': 7.5,\n",
       "  'BX': 12.70896979491113,\n",
       "  'AX': 1.336396672789746,\n",
       "  'FX': 0.8542705112691347,\n",
       "  'DQX': 2.383785789407781,\n",
       "  'DPX': -0.2698795969893243,\n",
       "  'BY': 7.606077834992548,\n",
       "  'AY': -0.920526171828191,\n",
       "  'FY': 0.8360625403327188,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'V_BM_1': {'S': 9.0,\n",
       "  'BX': 9.120629409314306,\n",
       "  'AX': 1.146568740048649,\n",
       "  'FX': 0.9936320883668346,\n",
       "  'DQX': 1.992896322252739,\n",
       "  'DPX': -0.2138526637243729,\n",
       "  'BY': 10.91413760701323,\n",
       "  'AY': -1.284847009200136,\n",
       "  'FY': 1.001448183140224,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': ['BM',\n",
       "   {'KIND': 'CSBEND', 'ANGLE': 0.17453292519943295, 'FINT': 0, 'L': 1.0}]},\n",
       " 'M_DR_3': {'S': 10.5,\n",
       "  'BX': 5.980356479284523,\n",
       "  'AX': 0.852404034821221,\n",
       "  'FX': 1.197543640504269,\n",
       "  'DQX': 1.744126672993481,\n",
       "  'DPX': -0.1561981825607101,\n",
       "  'BY': 15.31515988971355,\n",
       "  'AY': -1.649167846239906,\n",
       "  'FY': 1.11773084119158,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'MONITOR',\n",
       "  'RC': ['DR', {'KIND': 'DRIF', 'L': 2}]},\n",
       " 'TAIL': {'S': 12.0,\n",
       "  'BX': 4.287017734831201,\n",
       "  'AX': 5.273559366969493e-16,\n",
       "  'FX': 1.50436222394872,\n",
       "  'DQX': 1.549040841795901,\n",
       "  'DPX': -1.110223024625157e-16,\n",
       "  'BY': 19.81848926815184,\n",
       "  'AY': 1.387778780781446e-16,\n",
       "  'FY': 1.202262333729486,\n",
       "  'DQY': 0.0,\n",
       "  'DPY': 0.0,\n",
       "  'TYPE': 'VIRTUAL',\n",
       "  'RC': None}}"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# RC parameter from lattice data can be added to model table\n",
    "# Configuration table can be saved using util.save\n",
    "\n",
    "table = add_rc(table, lattice)\n",
    "table"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4604a99e-2f05-4693-85f2-f0ea61312fd6",
   "metadata": {},
   "source": [
    "# Example-04: Transformations benchmark (PTC)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "080a6c07-fab4-4a55-96dd-6276bb36237a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# In this example various symplectic transformations are compared with corresponding MADX-PTC transformations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "bdb8e52a-634f-42c3-9628-603df039e0e5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.005, -0.01, 0.005]\n",
      "[0.010000000000000002, -0.005, -0.010000000000000002, 0.005]\n",
      "[-1.734723475976807e-18, 0.0, 1.734723475976807e-18, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# calibration\n",
    "\n",
    "import torch\n",
    "\n",
    "from model.library.transformations import calibration_forward\n",
    "from model.library.transformations import calibration_inverse\n",
    "\n",
    "gxx = torch.tensor(1.005, dtype=torch.float64)\n",
    "gxy = torch.tensor(0.001, dtype=torch.float64)\n",
    "gyx = torch.tensor(0.005, dtype=torch.float64)\n",
    "gyy = torch.tensor(0.955, dtype=torch.float64)\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "res = calibration_forward(state, gxx, gxy, gyx, gyy)\n",
    "res = calibration_inverse(res, gxx, gxy, gyx, gyy)\n",
    "\n",
    "print(state.tolist()) \n",
    "print(res.tolist())\n",
    "print((state - res).tolist()) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "4d5b5046-cafc-45b0-824d-4ab2d787ac68",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005024875621890547, -0.005, -0.005024875621890547, 0.005]\n",
      "[0.005024875621890547, -0.005, -0.005024875621890547, 0.005]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# drift\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import drift\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length.item()} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = drift(state, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "9b7001fe-8e1e-49e1-9eae-31ab093ca099",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005024752473723395, -0.005, -0.005024752473723395, 0.005]\n",
      "[0.005024752473723394, -0.005, -0.005024752473723394, 0.005]\n",
      "[8.673617379884035e-19, 0.0, -8.673617379884035e-19, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# drift (with kinematic)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import drift\n",
    "from model.library.transformations import kinematic\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length.item()} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "state = drift(state, dp, length)\n",
    "state = kinematic(state, dp, length)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "91fd9e07-7966-4ca9-8c0f-2da9b966c091",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, -0.1, 0.0, 0.1]\n",
      "[0.0, -0.1, 0.0, 0.1]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# corrector\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import corrector\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "kx = -torch.tensor(0.1, dtype=torch.float64)\n",
    "ky = +torch.tensor(0.1, dtype=torch.float64)\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "magx:hkicker,l=0.0,kick={kx.item()};\n",
    "magy:vkicker,l=0.0,kick={ky.item()};\n",
    "map:line=(magx, magy) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = corrector(state, kx, ky)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "70c04db2-1d10-4d61-b82c-0a0c7e294ef9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0012338134845463512, -0.011134185772061586, -0.009559363509475737, -0.004042070986490389]\n",
      "[0.0012338134845463642, -0.01113418577206157, -0.009559363509475702, -0.0040420709864903495]\n",
      "[-1.3010426069826053e-17, -1.5612511283791264e-17, -3.469446951953614e-17, -3.9898639947466563e-17]\n"
     ]
    }
   ],
   "source": [
    "# focusing quadrupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import fquad\n",
    "\n",
    "kn = torch.tensor(1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length.item()}, k1={kn.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = fquad(state, kn.abs(), dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b2856de4-d7ff-4b08-9a71-2ff691c14770",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009559363509475737, 0.004042070986490389, -0.0012338134845463512, 0.011134185772061586]\n",
      "[0.009559363509475702, 0.0040420709864903495, -0.0012338134845463642, 0.01113418577206157]\n",
      "[3.469446951953614e-17, 3.9898639947466563e-17, 1.3010426069826053e-17, 1.5612511283791264e-17]\n"
     ]
    }
   ],
   "source": [
    "# defocusing quadrupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import dquad\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length.item()}, k1={kn.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = dquad(state, kn.abs(), dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "79f546f6-73cc-4e29-88d8-28571c7ab15c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00576876084434182, -0.0020884471766207963, 0.002582224887596925, 0.017416187766128223]\n",
      "[0.005768760844341825, -0.0020884471766207725, 0.0025822248875969544, 0.0174161877661282]\n",
      "[-5.204170427930421e-18, -2.3852447794681098e-17, -2.949029909160572e-17, 2.42861286636753e-17]\n"
     ]
    }
   ],
   "source": [
    "# generic quadrupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import quadrupole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(+1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: quadrupole, l={length.item()},k1={kn.item()},k1s={ks.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = quadrupole(state, kn, ks, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "7d079fa0-3bf2-4b11-b44e-e7cc7abb4b6b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005768760844341825, -0.0020884471766207725, 0.0025822248875969544, 0.0174161877661282]\n",
      "[0.005768760844341825, -0.0020884471766207725, 0.0025822248875969544, 0.0174161877661282]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# generic linear transformation\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import quadrupole\n",
    "from model.library.transformations import linear\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(+1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "vector = torch.zeros_like(state)\n",
    "matrix = torch.func.jacrev(quadrupole)(0.0*state, kn, ks, dp, length)\n",
    "\n",
    "ref = quadrupole(state, kn, ks, dp, length)\n",
    "res = linear(state, vector, matrix)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "3a088826-da54-4bd5-9df5-f7a88d4b0c1e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.07, -0.05, -0.06400000000000002]\n",
      "[0.01, -0.07, -0.05, -0.06400000000000002]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# quadrupole kick\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import gradient\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(1.5, dtype=torch.float64)\n",
    "ks = torch.tensor(1.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.05, 0.001], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,{(kn*length).item()}}},ksl={{0.0,{(ks*length).item()}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = gradient(state, kn, ks, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "5295eaba-09a7-45b8-9a89-b821b837c760",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.0044, -0.05, 0.00075]\n",
      "[0.01, -0.0044, -0.05, 0.00075]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# sextupole kick\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sextupole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.05, 0.001], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,0.0,{(ks*length).item()}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = sextupole(state, ks, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "be76c431-62ec-4d08-b33f-dcc3840ae08a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.01, -0.004938333333333334, -0.05, 0.0010916666666666668]\n",
      "[0.01, -0.004938333333333334, -0.05, 0.0010916666666666668]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# octupole kick\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import octupole\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "ko = torch.tensor(5.0, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.05, 0.001], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,0.0,0.0,{(ko*length).item()}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = octupole(state, ko, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "f5b562d5-b7ca-4fea-b3ab-0103a626c69c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.005231962156363519, -0.004575808017791941, -0.005024875621890682, 0.005]\n",
      "[0.005231962156363559, -0.004575808017791928, -0.005024875621890547, 0.005]\n",
      "[-3.9898639947466563e-17, -1.3010426069826053e-17, -1.3530843112619095e-16, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# pure dipole (no edge effects if e1 = e2 = 0)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import dipole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64 )\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sbend, l={length.item()}, angle={angle.item()},k1=0.0,k1s=0.0,e1=0.0,e2=0.0,kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = dipole(state, length/angle, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "98063db1-6987-4852-9732-3e4983fae16b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.007795176039169286, 0.0011097346020520168, 0.0007677684542948365, 0.01462661777023533]\n",
      "[0.0077951760391692755, 0.0011097346020520064, 0.0007677684542948021, 0.014626617770235346]\n",
      "[1.0408340855860843e-17, 1.0408340855860843e-17, 3.436920886779049e-17, -1.5612511283791264e-17]\n"
     ]
    }
   ],
   "source": [
    "# combined function dipole (no edge effects if e1 = e2 = 0)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import bend\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64 )\n",
    "ks = torch.tensor(0.5, dtype=torch.float64 )\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(1.0, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sbend, l={length.item()}, angle={angle.item()},k1={kn.item()},k1s={ks.item()},e1=0.0,e2=0.0,kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "res = bend(state, length/angle, kn, ks, dp, length)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "d3d88c90-405b-45b9-b21b-3bb9cac4fec7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.02505664248885726, 0.02888471799554683, 0.01948347950480536, 0.007752605073815676]\n",
      "[0.025056642488857035, 0.028884717995546608, 0.019483479504805307, 0.007752605073815616]\n",
      "[2.255140518769849e-16, 2.220446049250313e-16, 5.204170427930421e-17, 5.984795992119984e-17]\n"
     ]
    }
   ],
   "source": [
    "# combined function dipole with edge effects\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import bend\n",
    "from model.library.transformations import wedge\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "e1 = torch.tensor(0.02, dtype=torch.float64)\n",
    "e2 = torch.tensor(-0.03, dtype=torch.float64)\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.01, 0.005], dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sbend, l={length.item()}, angle={angle.item()},k1={kn.item()},k1s={ks.item()},e1={e1.item()},e2={e2.item()},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=false ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = wedge(state, e1, length/angle)\n",
    "state = bend(state, length/angle, kn + 1.0E-16, ks + 1.0E-16, dp, length)\n",
    "res = wedge(state, e2, length/angle)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "fd03af43-7b65-45a6-bea1-8306c1338494",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.08749190399027759, -0.05149961687573391, -0.05640828383591964, -0.019912883990595223]\n",
      "[-0.08749190399027745, -0.05149961687573378, -0.05640828383591953, -0.01991288399059518]\n",
      "[-1.3877787807814457e-16, -1.249000902703301e-16, -1.1102230246251565e-16, -4.163336342344337e-17]\n"
     ]
    }
   ],
   "source": [
    "# translations (exact alignment, straight layout, act on a thin representation at the entrance frame)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import drift\n",
    "from model.library.transformations import quadrupole\n",
    "from model.library.transformations import tx, ty, tz\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.015, 0.0025], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "dr: drift, l=1.0;\n",
    "mag: quadrupole, l={length.item()},k1={kn.item()},k1s={ks.item()};\n",
    "map:line=(dr, mag, dr) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "select,flag=error,pattern=\"mag\";\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()};\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = drift(state, dp, 1.0)\n",
    "state = tx(state, +dx)\n",
    "state = ty(state, +dy)\n",
    "state = tz(state, +dz, dp)\n",
    "state = quadrupole(state, kn, ks, dp, length)\n",
    "state = tz(state, -dz, dp)\n",
    "state = ty(state, -dy)\n",
    "state = tx(state, -dx)\n",
    "state = drift(state, dp, 1.0)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "46617dad-22ce-413d-8c8e-cad2bbe267a0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.19014967849021078, -0.2611883141418841, -0.10367399923762718, -0.09101974096085057]\n",
      "[-0.19014967849022751, -0.2611883141418846, -0.10367399923763249, -0.09101974096085078]\n",
      "[1.6736612096224235e-14, 4.996003610813204e-16, 5.3013149425851225e-15, 2.0816681711721685e-16]\n"
     ]
    }
   ],
   "source": [
    "# translations + rotations (exact alignment, straight layout, act on a thin representation at the entrance frame)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import quadrupole\n",
    "from model.library.transformations import tx, ty, tz\n",
    "from model.library.transformations import rx, ry, rz\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.015, 0.0025], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length.item()},k1={kn.item()},k1s={ks.item()};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "select,flag=error,pattern=\"mag\";\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()};\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = tx(state, +dx)\n",
    "state = ty(state, +dy)\n",
    "state = tz(state, +dz, dp)\n",
    "\n",
    "state = rx(state, +wx, dp)\n",
    "state = ry(state, +wy, dp)\n",
    "state = rz(state, +wz)\n",
    "\n",
    "state = quadrupole(state, kn + 1.0E-16, ks + 1.0E-16, dp, length)\n",
    "\n",
    "state = tz(state, -length, dp)\n",
    "\n",
    "state = rz(state, -wz)\n",
    "state = ry(state, -wy, dp)\n",
    "state = rx(state, -wx, dp)\n",
    "\n",
    "state = tz(state, -dz, dp)\n",
    "state = ty(state, -dy)\n",
    "state = tx(state, -dx)\n",
    "\n",
    "state = tz(state, +length, dp)\n",
    "\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "5a207d27-c76f-4739-b615-8644cc8b9a4f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.20185873553633701, -0.27629369448112884, -0.08354566211146026, -0.06880534321809641]\n",
      "[-0.20185873553633754, -0.2762936944811289, -0.08354566211146025, -0.06880534321809621]\n",
      "[5.273559366969494e-16, 5.551115123125783e-17, -1.3877787807814457e-17, -1.942890293094024e-16]\n"
     ]
    }
   ],
   "source": [
    "# translations + rotations (exact alignment, curved layout, act on a thin representation at the entrance frame)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import bend\n",
    "from model.library.transformations import wedge\n",
    "from model.library.transformations import tx, ty, tz\n",
    "from model.library.transformations import rx, ry, rz\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "angle = torch.tensor(0.1, dtype=torch.float64)\n",
    "kn = torch.tensor(-1.0, dtype=torch.float64)\n",
    "ks = torch.tensor(0.5, dtype=torch.float64)\n",
    "dp = torch.tensor(0.005, dtype=torch.float64)\n",
    "e1 = torch.tensor(0.005, dtype=torch.float64)\n",
    "e2 = torch.tensor(0.005, dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(2.5, dtype=torch.float64)\n",
    "state = torch.tensor([0.01, -0.005, -0.015, 0.0025], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length.item()},angle={angle.item()},k1={kn.item()},k1s={ks.item()},e1={e1.item()},e2={e2.item()},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+9,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "select,flag=error,pattern=\"mag\";\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()};\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=false ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp.item()},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "state = tx(state, +dx)\n",
    "state = ty(state, +dy)\n",
    "state = tz(state, +dz, dp)\n",
    "\n",
    "state = rx(state, +wx, dp)\n",
    "state = ry(state, +wy, dp)\n",
    "state = rz(state, +wz)\n",
    "\n",
    "state = wedge(state, e1, length/angle)\n",
    "state = bend(state, length/angle, kn + 1.0E-16, ks + 1.0E-16, dp, length)\n",
    "state = wedge(state, e2, length/angle)\n",
    "\n",
    "state = ry(state, +angle/2, dp)\n",
    "state = tz(state, -2.0*length/angle*(angle/2.0).sin(), dp)\n",
    "state = ry(state, +angle/2, dp)\n",
    "\n",
    "state = rz(state, -wz)\n",
    "state = ry(state, -wy, dp)\n",
    "state = rx(state, -wx, dp)\n",
    "\n",
    "state = tz(state, -dz, dp)\n",
    "state = ty(state, -dy)\n",
    "state = tx(state, -dx)\n",
    "\n",
    "state = ry(state, -angle/2, dp)\n",
    "state = tz(state, +2.0*length/angle*(angle/2.0).sin(), dp)\n",
    "state = ry(state, -angle/2, dp)\n",
    "\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "554e17dc-f44b-4934-9d37-9960a1d13ba2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00932966343120269, -3.829320024990772e-05, -0.008755742622854638, 0.0005]\n",
      "[0.009329663431209667, -3.829320024994158e-05, -0.008755742622854576, 0.0005]\n",
      "[-6.977057820378718e-15, 3.386098909943791e-17, -6.245004513516506e-17, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# exact sector bend (without fringe)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sector_bend\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.01, -0.0005, -0.01, 0.0005], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},kill_ent_fringe=true,kill_exi_fringe=true;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "state = sector_bend(state, length/angle, dp, length)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "0aac734b-90ea-4f8c-a0bf-8e49979b4999",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00933011773950498, -3.830113730822001e-05, -0.008756237750526722, 0.0004998143432367524]\n",
      "[0.009330117739498277, -3.8301137308233764e-05, -0.008756237750526754, 0.0004998143432367524]\n",
      "[6.702971511174383e-15, 1.3755815063409838e-17, 3.122502256758253e-17, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# exact sector bend (with fringe)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sector_bend\n",
    "from model.library.transformations import sector_bend_fringe\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.01, -0.0005, -0.01, 0.0005], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "state = sector_bend_fringe(state, +length/angle, dp)\n",
    "state = sector_bend(state, length/angle, dp, length)\n",
    "state = sector_bend_fringe(state, -length/angle, dp)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "e50aff00-749c-440d-b1c4-ead947d7e271",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009340060895391944, -3.805697197357787e-05, -0.00874628326389246, 0.0005003157283896672]\n",
      "[0.009340060895401722, -3.805697197360909e-05, -0.00874628326389242, 0.0005003157283896674]\n",
      "[-9.778636234081262e-15, 3.1218246304004493e-17, -3.9898639947466563e-17, -1.0842021724855044e-19]\n"
     ]
    }
   ],
   "source": [
    "# exact sector bend (with fringe and wedges)\n",
    "\n",
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.transformations import sector_bend\n",
    "from model.library.transformations import sector_bend_fringe\n",
    "from model.library.transformations import sector_bend_wedge\n",
    "from model.library.transformations import polar\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.01\n",
    "e2 = -0.01\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.01, -0.0005, -0.01, 0.0005], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map  ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact=true ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=6,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}};\n",
    "ptc_track_end;\n",
    "ptc_end;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "state = polar(state, e1, dp)\n",
    "state = sector_bend_fringe(state, +length/angle, dp)\n",
    "state = sector_bend_wedge(state, -e1, length/angle, dp)\n",
    "state = sector_bend(state, length/angle, dp, length)\n",
    "state = sector_bend_wedge(state, -e2, length/angle, dp)\n",
    "state = sector_bend_fringe(state, -length/angle, dp)\n",
    "state = polar(state, e2, dp)\n",
    "res = state\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "718f06d9-f5af-4c43-a377-cd6e08afc8c7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 1.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00, -4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "tensor([[ 1.0000e+00,  5.5508e-17,  0.0000e+00,  0.0000e+00],\n",
      "        [ 4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00, -4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([[ 1.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [-4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "tensor([[ 1.0000e+00,  0.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [-4.0001e-04,  1.0000e+00,  0.0000e+00,  0.0000e+00],\n",
      "        [ 0.0000e+00,  0.0000e+00,  1.0000e+00,  5.5234e-17],\n",
      "        [ 0.0000e+00,  0.0000e+00,  4.0001e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# linear wedge matrix\n",
    "\n",
    "from model.library.transformations import wedge\n",
    "from model.library.transformations import polar\n",
    "from model.library.transformations import sector_bend_fringe\n",
    "from model.library.transformations import sector_bend_wedge\n",
    "\n",
    "length = 2.5\n",
    "angle = 0.1\n",
    "e1 = 0.01\n",
    "e2 = -0.01\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "length = torch.tensor(length, dtype=torch.float64)\n",
    "angle = torch.tensor(angle, dtype=torch.float64)\n",
    "e1 = torch.tensor(e1, dtype=torch.float64)\n",
    "e2 = torch.tensor(e2, dtype=torch.float64)\n",
    "dp = torch.tensor(dp, dtype=torch.float64)\n",
    "\n",
    "def wedge_entrance(state):\n",
    "    state = polar(state, e1, dp)\n",
    "    state = sector_bend_fringe(state, +length/angle, dp)\n",
    "    state = sector_bend_wedge(state, -e1, length/angle, dp)\n",
    "    return state\n",
    "\n",
    "def wedge_exit(state):\n",
    "    state = sector_bend_wedge(state, -e2, length/angle, dp)\n",
    "    state = sector_bend_fringe(state, -length/angle, dp)\n",
    "    state = polar(state, e2, dp)\n",
    "    return state\n",
    "\n",
    "print(torch.func.jacrev(wedge)(state, e1, length/angle))\n",
    "print(torch.func.jacrev(wedge_entrance)(state))\n",
    "print()\n",
    "\n",
    "print(torch.func.jacrev(wedge)(state, e2, length/angle))\n",
    "print(torch.func.jacrev(wedge_exit)(state))\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "85d6656d-13d2-4cb4-8404-d1fdf6af354e",
   "metadata": {},
   "source": [
    "# Example-05: Drift (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "942d635e-4ba0-4b82-89f3-a55e423f5f10",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of drift element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "94da4e4d-ea80-4f6d-8b7c-d541629a3c23",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "5c39499a-c10e-4dfb-99f7-abd58e326dcc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0025373134328358204, -0.005, -0.003507462686567164, 0.001]\n",
      "[0.0025373134328358204, -0.005, -0.0035074626865671645, 0.001]\n",
      "[0.0, 0.0, 4.336808689942018e-19, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Drift('D', length=length, dp=dp, exact=exact)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "5ae0a652-05ba-4f39-b7ae-009373ddfa3f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.002537217378977325, -0.005, -0.003507443475795465, 0.001]\n",
      "[0.002537217378977325, -0.005, -0.0035074434757954654, 0.001]\n",
      "[0.0, 0.0, 4.336808689942018e-19, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Drift('D', length=length, dp=dp, exact=exact)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e0bba0d5-03e3-43ad-9955-05aa21a0b360",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0025372170792497145, -0.0049999999999999975, -0.003507395297032926, 0.0010000000000000009]\n",
      "[0.0025372170792497166, -0.004999999999999999, -0.0035073952970329247, 0.0010000000000000018]\n",
      "[-2.168404344971009e-18, 1.734723475976807e-18, -1.3010426069826053e-18, -8.673617379884035e-19]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:drift,l={length} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Drift('D', length=length, dp=dp, exact=exact)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()\n",
    "\n",
    "# Note, for some reason drift is not invariant under WX ans WY rotations in MADX"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "c3422dd0-926f-4f3b-9150-a2e7c2042351",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0025, -0.0050, -0.0035,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0025, -0.0050, -0.0035,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(D(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dl': torch.tensor(-length, dtype=D.dtype)}}))\n",
    "print()\n",
    "\n",
    "# In the above D.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**D.table(), **{'dl': torch.tensor(-length, dtype=DR.dtype)}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(D(state, data={**D.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "DA = Drift('DA', length, dp)\n",
    "DB = Drift('DB', length - 0.1, dp)\n",
    "\n",
    "print(DA(state) - DB(state, data={**DB.table(), **{'dl': torch.tensor(+0.1, dtype=DB.dtype)}}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "3850f79d-c1b7-40c5-8407-1802852021cb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([-0.0005,  0.0000,  0.0001,  0.0000], dtype=torch.float64)\n",
      "tensor([-9.7502e-08,  0.0000e+00,  1.9500e-08,  0.0000e+00],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=False, insertion=True)\n",
    "\n",
    "# Identity transformation without errors\n",
    "\n",
    "print(D(state) - state)\n",
    "\n",
    "# Represents effect of an error\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "D = Drift('D', length, dp, exact=True, insertion=True)\n",
    "\n",
    "print(D(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "b5146cc0-6f5b-47b9-9317-939ca62bbc9b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(D)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return D(state, data={**D.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "3020a87b-b812-4657-a53f-f163959d9d67",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[1.0000, 1.5000, 0.0000, 0.0000],\n",
      "        [0.0000, 1.0000, 0.0000, 0.0000],\n",
      "        [0.0000, 0.0000, 1.0000, 1.5000],\n",
      "        [0.0000, 0.0000, 0.0000, 1.0000]], dtype=torch.float64)\n",
      "\n",
      "tensor([-0.0050,  0.0000,  0.0010,  0.0000], dtype=torch.float64)\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "tensor(-0., dtype=torch.float64)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(D)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "dl = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, dl):\n",
    "    return D(state, data={**D.table(), **{'dl': dl}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, dl))\n",
    "print()\n",
    "\n",
    "# Compositional derivative (compute derivative of jacobian trace with respect momentum deviation)\n",
    "\n",
    "dp = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def trace(state, dp):\n",
    "    return (torch.func.jacrev(lambda state: D(state, data={**D.table(), **{'dp': dp}}))(state)).trace()\n",
    "\n",
    "torch.func.jacrev(trace, 1)(state, dp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "c906a277-85a1-451c-9d08-79505a16a072",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0025, -0.0050, -0.0035,  0.0010], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(D(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "D.ns = 100\n",
    "\n",
    "D(state)\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "4c9992c3-1047-43ae-8be5-c90bb10c9123",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.002499902498098708, -0.005, -0.003499980499619743, 0.001]\n",
      "[0.002499902498098709, -0.005, -0.0034999804996197477, 0.001]\n",
      "[-8.673617379884035e-19, 0.0, 4.7704895589362195e-18, 0.0]\n",
      "\n",
      "[0, 1, 0, 1, 0, 1, 0]\n",
      "[0.6756035959798289, 1.3512071919596578, -0.17560359597982877, -1.7024143839193153, -0.17560359597982877, 1.3512071919596578, 0.6756035959798289]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Drift('D', length, dp, order=1, exact=True)\n",
    "\n",
    "# For drift integration is performed only with exact flag\n",
    "# In this case, kinematic term error is added\n",
    "# This term actually commutes with paraxial drift map\n",
    "# But integration is still performed for consistency with matrix-kick-matrix split\n",
    "# Only one integration step is required to get exact result\n",
    "\n",
    "D.ns = 1\n",
    "ref = D(state)\n",
    "\n",
    "D.ns = 10\n",
    "res = D(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = D._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fbb64279-2e1f-4d77-9911-7d59b1e362b9",
   "metadata": {},
   "source": [
    "# Example-06: Quadrupole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d08456c6-d48d-4b01-9849-b640ffadf17a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of quadrupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "4b06f234-9f8d-4966-a6be-199f4bb672b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "bf455483-aa9d-4809-a8db-7616d51ad488",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.012268608165994052, 0.012991610983278109, 0.005825218798687177, 0.01752224400608683]\n",
      "[0.012268608165994057, 0.012991610983278092, 0.005825218798687172, 0.017522244006086807]\n",
      "[-5.204170427930421e-18, 1.734723475976807e-17, 5.204170427930421e-18, 2.0816681711721685e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},k1={kn},k1s={ks} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "Q = Quadrupole('Q', length=length, kn=kn, ks=ks, dp=dp, exact=exact)\n",
    "res = Q(state, alignment=align, data={**Q.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "2edcbd11-789a-4848-b024-1b692eabf59a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.012269208914523159, 0.012992157908766264, 0.005826335256074007, 0.017521822791072554]\n",
      "[0.01226920891452326, 0.012992157908766374, 0.005826335256074149, 0.017521822791072988]\n",
      "[-1.0061396160665481e-16, -1.0928757898653885e-16, -1.4224732503009818e-16, -4.3368086899420177e-16]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},k1={kn},k1s={ks} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "Q = Quadrupole('Q', length=length, kn=kn, ks=ks, dp=dp, exact=exact, order=5, ns=5)\n",
    "res = Q(state, alignment=align, data={**Q.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "f2bb9def-d872-4db2-9eee-ef866761d0ca",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.022075488016794924, -0.09165584224601611, -0.04570124622656498, -0.08629975808408008]\n",
      "[-0.02207548801679439, -0.09165584224601665, -0.04570124622656456, -0.08629975808408233]\n",
      "[-5.342948306008566e-16, 5.412337245047638e-16, -4.2327252813834093e-16, 2.248201624865942e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},k1={kn},k1s={ks} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "Q = Quadrupole('Q', length=length, kn=kn, ks=ks, dp=dp, exact=exact, order=5, ns=5)\n",
    "res = Q(state, alignment=align, data={**Q.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "1cccb51d-c1a3-4dcc-9098-5ac0d1162dfe",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.0242, 0.0380, 0.0152, 0.0200], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([-0.0908, -0.2335, -0.0963, -0.1316], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(Q(state))\n",
    "print()\n",
    "\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(Q(state, data={**Q.table(), **{'dl': -Q.length}}))\n",
    "print()\n",
    "\n",
    "# In the above Q.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**Q.table(), **{'dl': -Q.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(Q(state, data={**Q.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "QA = Quadrupole('QA', length, kn, ks, dp)\n",
    "QB = Quadrupole('QB', length - 0.1, kn, ks, dp)\n",
    "\n",
    "print(QA(state) - QB(state, data={**QB.table(), **{'dl': torch.tensor(+0.1, dtype=QB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "6e1f5eda-f9ba-45bc-8e82-61020d7b69f8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-5.5511e-17,  7.4593e-17, -1.4745e-17,  2.7756e-17],\n",
      "       dtype=torch.float64)\n",
      "tensor([-0.0002,  0.0037,  0.0003,  0.0031], dtype=torch.float64)\n",
      "tensor([-2.2924e-06, -3.9787e-06, -9.4215e-07,  2.1943e-07],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=False, insertion=True)\n",
    "\n",
    "# Identity transformation without errors\n",
    "\n",
    "print(Q(state) - state)\n",
    "\n",
    "# Represents effect of an error\n",
    "\n",
    "print(Q(state, data={**Q.table(), **{'dl': 0.1, 'kn': -0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=True, insertion=True, ns=100, order=1)\n",
    "\n",
    "print(Q(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "57e4fdb0-8f0c-475d-9baf-4e40d8255505",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=Q.dtype, device=Q.device)\n",
    "\n",
    "print(torch.vmap(Q)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return Q(state, data={**Q.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=Q.dtype, device=Q.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "48189c8b-bc04-41d3-bb8e-c4c03e9ca5e1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 4.7923,  3.0672,  1.8367,  0.8757],\n",
      "        [ 7.4479,  4.7923,  2.8495,  1.8367],\n",
      "        [ 1.8367,  0.8757, -0.1057,  0.7321],\n",
      "        [ 2.8495,  1.8367, -0.1507, -0.1057]], dtype=torch.float64)\n",
      "\n",
      "tensor([-0.0175, -0.0354, -0.0029, -0.0029], dtype=torch.float64)\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "tensor([-12.7901,  12.7901], dtype=torch.float64)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(Q)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "kn = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, kn):\n",
    "    return Q(state, data={**Q.table(), **{'kn': kn}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, kn))\n",
    "print()\n",
    "\n",
    "# Compositional derivative (compute derivative of jacobian trace with respect quadrupole strength)\n",
    "\n",
    "length = 0.5\n",
    "knf = +0.2\n",
    "knd = -0.2\n",
    "\n",
    "QF = Quadrupole('QF', length, knf)\n",
    "QD = Quadrupole('QD', length, knd)\n",
    "DR = Drift('DR', 5.0)\n",
    "\n",
    "dknf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dknd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dkn = torch.stack([dknf, dknd])\n",
    "\n",
    "def fodo(state, dkn):\n",
    "    dknf, dknd = dkn\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    state = DR(state)\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = DR(state)\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    return state\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def trace(dkn):\n",
    "    return (torch.func.jacrev(fodo)(state, dkn)).trace()\n",
    "\n",
    "torch.func.jacrev(trace)(dkn)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "93593b02-875e-4f2b-a7f9-8db8d855a4fd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.0243, 0.0381, 0.0153, 0.0200], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(Q(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(Q.container_output.shape)\n",
    "print(Q.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "Q.ns = 100\n",
    "\n",
    "Q(state)\n",
    "print(Q.container_output.shape)\n",
    "print(Q.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "0ba48709-87f5-4be9-bb70-9a43022178ce",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.02428427109202266, 0.038113543192801885, 0.015254854998694011, 0.019958320804526662]\n",
      "[0.02428676414378537, 0.038112599406681553, 0.015255420211007745, 0.019958093271800193]\n",
      "[-2.493051762711418e-06, 9.437861203318021e-07, -5.652123137335485e-07, 2.275327264690541e-07]\n",
      "\n",
      "[0, 1, 0, 1, 0, 1, 0]\n",
      "[0.6756035959798289, 1.3512071919596578, -0.17560359597982877, -1.7024143839193153, -0.17560359597982877, 1.3512071919596578, 0.6756035959798289]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "Q = Quadrupole('Q', length, kn, ks, dp, order=1, exact=True)\n",
    "\n",
    "# For quadrupole integration is performed only with exact flag\n",
    "# In this case, kinematic term error is added\n",
    "\n",
    "Q.ns = 1\n",
    "ref = Q(state)\n",
    "\n",
    "Q.ns = 10\n",
    "res = Q(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = Q._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "e0773bea-af9f-4c5e-b2e2-12bf9d626e61",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.2107, 0.1703], dtype=torch.float64)\n",
      "tensor([0.2126, 0.1681], dtype=torch.float64)\n",
      "tensor([0.2126, 0.1681], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Derivatives of twiss parameters\n",
    "\n",
    "# pip install git+https://github.com/i-a-morozov/twiss.git@main\n",
    "\n",
    "from twiss import twiss\n",
    "\n",
    "length = 0.5\n",
    "knf = +0.21\n",
    "knd = -0.19\n",
    "\n",
    "QF = Quadrupole('QF', length, knf)\n",
    "QD = Quadrupole('QD', length, knd)\n",
    "DR = Drift('DR', 5.0)\n",
    "\n",
    "dknf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dknd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dkn = torch.stack([dknf, dknd])\n",
    "\n",
    "def fodo(state, dkn):\n",
    "    dknf, dknd = dkn\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    state = DR(state)\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = QD(state, data={**QD.table(), **{'kn': dknd}})\n",
    "    state = DR(state)\n",
    "    state = QF(state, data={**QF.table(), **{'kn': dknf}})\n",
    "    return state\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def tune(dkn):\n",
    "    matrix = torch.func.jacrev(fodo)(state, dkn)\n",
    "    tune, *_ = twiss(matrix)\n",
    "    return tune\n",
    "\n",
    "# Compute tunes and jacobian\n",
    "\n",
    "values = tune(dkn)\n",
    "jacobian = torch.func.jacrev(tune)(dkn)\n",
    "\n",
    "# Test jacobiant\n",
    "\n",
    "print(values)\n",
    "print(tune(dkn + 1.0E-3))\n",
    "print(values + jacobian @ (dkn + 1.0E-3))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ed1c26f4-6b1f-4333-8a47-e8964fb9b279",
   "metadata": {},
   "source": [
    "# Example-07: Sextupole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a25b4b6d-3b76-47d9-9d60-7b1af9ddc472",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of sextupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "6052fb02-2899-4172-8f96-69cb2d0255bb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.sextupole import Sextupole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "60472c44-909a-4c44-89a0-8bd61ed645b0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.008745689261382875, -0.005080234821325765, -0.00476590910682766, 0.0008855562050471031]\n",
      "[0.008745689261382871, -0.00508023482132578, -0.00476590910682768, 0.0008855562050471008]\n",
      "[3.469446951953614e-18, 1.5612511283791264e-17, 1.9949319973733282e-17, 2.2768245622195593e-18]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sextupole, l={length},k2={ms} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "S = Sextupole('S', length=length, ms=ms, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = S(state, alignment=align, data={**S.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "30051f5c-9427-4fb2-88f4-b1bf7cef4562",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.008745672936611987, -0.005080234654232574, -0.004765906047078759, 0.000885556338827788]\n",
      "[0.00874567293661202, -0.0050802346542325495, -0.0047659060470788064, 0.0008855563388277869]\n",
      "[-3.2959746043559335e-17, -2.42861286636753e-17, 4.7704895589362195e-17, 1.0842021724855044e-18]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sextupole, l={length},k2={ms} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "S = Sextupole('S', length=length, ms=ms, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = S(state, alignment=align, data={**S.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "060aa4d8-2586-49ba-8cd3-389c4e8a9157",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.008663885569968804, -0.006258052120536049, -0.004896687680053297, -0.000915022709372755]\n",
      "[0.008663885569968922, -0.006258052120536033, -0.004896687680053253, -0.000915022709372733]\n",
      "[-1.1796119636642288e-16, -1.6479873021779667e-17, -4.423544863740858e-17, -2.200930410145574e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: sextupole, l={length},k2={ms} ;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "S = Sextupole('S', length=length, ms=ms, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = S(state, alignment=align, data={**S.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "06fc7a7d-7c34-4842-93f2-9910d90e6b1a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0087, -0.0051, -0.0048,  0.0009], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0087, -0.0062, -0.0049, -0.0009], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 0.25\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(S(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(S(state, data={**S.table(), **{'dl': -S.length}}))\n",
    "print()\n",
    "\n",
    "# In the above S.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**S.table(), **{'dl': -S.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(S(state, data={**S.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "SA = Sextupole('SA', length, ms, dp)\n",
    "SB = Sextupole('SB', length - 0.1, ms, dp)\n",
    "\n",
    "print(SA(state) - SB(state, data={**SB.table(), **{'dl': torch.tensor(+0.1, dtype=SB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "02270c3a-c3bb-42ac-85ca-ce6c33eb1cd1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0000, -0.0006,  0.0000, -0.0008], dtype=torch.float64)\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([-5.2560e-04, -5.6465e-04,  6.1078e-05, -7.7234e-04],\n",
      "       dtype=torch.float64)\n",
      "tensor([-1.3875e-04, -5.5306e-04, -9.3764e-05, -7.7778e-04],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.005\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=False, insertion=True)\n",
    "\n",
    "# Since sextupole is a nonlinear element, insertion is an identity transformation only for zero strenght\n",
    "\n",
    "print(S(state) - state)\n",
    "print(S(state, data={**S.table(), **{'ms': -ms}}) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(S(state, data={**S.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=True, insertion=True, ns=100, order=1)\n",
    "\n",
    "print(S(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "51f9375a-61d8-4ea2-9dc7-882543b4e0fb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=S.dtype, device=S.device)\n",
    "\n",
    "print(torch.vmap(S)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return S(state, data={**S.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=S.dtype, device=S.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "9d084357-0817-4268-8f58-2ab8e0e46233",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 0.9297,  1.4473, -0.0478, -0.0359],\n",
      "        [-0.0938,  0.9297, -0.0638, -0.0478],\n",
      "        [-0.0478, -0.0359,  1.0703,  1.5527],\n",
      "        [-0.0638, -0.0478,  0.0938,  1.0703]], dtype=torch.float64)\n",
      "\n",
      "tensor([-1.1813e-05, -1.5750e-05, -2.9883e-05, -3.9844e-05],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(S)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "ms = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, ms):\n",
    "    return S(state, data={**S.table(), **{'ms': ms}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, ms))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "ae5bc2c2-07f9-4edc-bfab-b696f0a56307",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0023, -0.0052, -0.0039,  0.0006], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(S(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(S.container_output.shape)\n",
    "print(S.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "S.ns = 100\n",
    "\n",
    "S(state)\n",
    "print(S.container_output.shape)\n",
    "print(S.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "fb10197c-e304-49ed-997a-1d0283f5814f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0022880403040043407, -0.005176627884407675, -0.0038882248469424585, 0.0005834231060909752]\n",
      "[0.0022871610802911667, -0.005176794799148338, -0.0038891562083014203, 0.0005832353574511327]\n",
      "[8.792237131739246e-07, 1.6691474066278522e-07, 9.313613589618727e-07, 1.877486398425181e-07]\n",
      "\n",
      "[0, 1, 2, 1, 0]\n",
      "[0.5, 0.5, 1.0, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "ms = 10.0\n",
    "dp = 0.0\n",
    "length = 1.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "S = Sextupole('S', length, ms, dp, order=0, exact=True)\n",
    "\n",
    "# For sextupole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "S.ns = 10\n",
    "ref = S(state)\n",
    "\n",
    "S.ns = 100\n",
    "res = S(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = S._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "bc85fb39-b5a8-4719-984c-14d55808607b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.2107, 0.1703], dtype=torch.float64)\n",
      "tensor([-0.2279, -0.2107], dtype=torch.float64)\n",
      "tensor([[0., 0.],\n",
      "        [0., 0.]], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Derivatives of twiss parameters (chromaticity)\n",
    "\n",
    "# pip install git+https://github.com/i-a-morozov/twiss.git@main\n",
    "\n",
    "from twiss import twiss\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.21)\n",
    "QD = Quadrupole('QD', 0.5, -0.19)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DA = Drift('DR', 0.25)\n",
    "DB = Drift('DR', 4.00)\n",
    "\n",
    "def fodo(state, dp, dms):\n",
    "    dmsf, dmsd = dms\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DB(state, data={**DB.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DB(state, data={**DB.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DA(state, data={**DA.table(), **{'dp': dp}})\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    return state\n",
    "\n",
    "dp = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "dmsf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dmsd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dms = torch.stack([dmsf, dmsd])\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def tune(dp, dms):\n",
    "    matrix = torch.func.jacrev(fodo)(state, dp, dms)\n",
    "    tune, *_ = twiss(matrix)\n",
    "    return tune\n",
    "\n",
    "def chromaticity(dms):\n",
    "    return torch.func.jacrev(tune)(dp, dms)\n",
    "\n",
    "# Compute tunes\n",
    "\n",
    "tunes = tune(dp, dms)\n",
    "print(tunes)\n",
    "\n",
    "# Compute chromaticity\n",
    "\n",
    "chromaticities = chromaticity(dms)\n",
    "print(chromaticities)\n",
    "\n",
    "# Compute derivative of chromaticities \n",
    "# The result is zero, since there is no dispersion to feed sextupoles down\n",
    "\n",
    "print(torch.func.jacrev(chromaticity)(dms))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9a5af188-3962-4346-b9e7-69c0fd7913ab",
   "metadata": {},
   "source": [
    "# Example-08: Octupole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7ded21b8-b066-4836-8135-bd50a23310ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of octupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "c4585155-0b09-4e84-91b2-0daa0d89459c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.octupole import Octupole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "af5acd11-30d5-4fbb-9850-670a00aa6025",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009004942132987458, -0.005000291994759593, -0.004801204788639501, 0.0009979801079392878]\n",
      "[0.009004942132987486, -0.005000291994759635, -0.004801204788639504, 0.0009979801079392843]\n",
      "[-2.7755575615628914e-17, 4.2500725161431774e-17, 3.469446951953614e-18, 3.469446951953614e-18]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "mo = + 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: octupole, l={length},k3={mo};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "O = Octupole('O', length=length, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = O(state, alignment=align, data={**O.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "652c325d-00b6-47b8-b901-9594a2cfc135",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00900492932570409, -0.005000291993307186, -0.004801202229721349, 0.0009979801112567327]\n",
      "[0.009004929325704207, -0.0050002919933071705, -0.004801202229721335, 0.00099798011125672]\n",
      "[-1.1622647289044608e-16, -1.5612511283791264e-17, -1.3877787807814457e-17, 1.2576745200831851e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "mo = + 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: octupole, l={length},k3={mo};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "O = Octupole('O', length=length, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = O(state, alignment=align, data={**O.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "19d0f11c-e3dc-40be-b934-d107f292ea77",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009005660276793346, -0.004983923494470567, -0.004794436076349048, 0.0011299481578555504]\n",
      "[0.009005660276792638, -0.004983923494470562, -0.004794436076348805, 0.0011299481578555233]\n",
      "[7.077671781985373e-16, -5.204170427930421e-18, -2.42861286636753e-16, 2.710505431213761e-17]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "mo = + 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: octupole, l={length},k3={mo};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "O = Octupole('O', length=length, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = O(state, alignment=align, data={**O.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "c6135d37-9763-4e07-9a74-12c45f182578",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0090, -0.0050, -0.0048,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0090, -0.0050, -0.0048,  0.0011], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(O(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(O(state, data={**O.table(), **{'dl': -O.length}}))\n",
    "print()\n",
    "\n",
    "# In the above O.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**O.table(), **{'dl': -O.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(O(state, data={**O.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "OA = Octupole('OA', length, mo, dp)\n",
    "OB = Octupole('OB', length - 0.1, mo, dp)\n",
    "\n",
    "print(OA(state) - OB(state, data={**OB.table(), **{'dl': torch.tensor(+0.1, dtype=OB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "737144d9-ff08-4d7b-8ccd-d30719a59150",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0000e+00, -4.1667e-07,  0.0000e+00, -2.2917e-06],\n",
      "       dtype=torch.float64)\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([-4.9754e-04, -5.2588e-07,  9.9342e-05, -3.2270e-06],\n",
      "       dtype=torch.float64)\n",
      "tensor([-1.7351e-08, -4.1976e-07, -6.9314e-09, -2.2953e-06],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=False, insertion=True)\n",
    "\n",
    "# Since octupole is a nonlinear element, insertion is an identity transformation only for zero strenght\n",
    "\n",
    "print(O(state) - state)\n",
    "print(O(state, data={**O.table(), **{'mo': -mo}}) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(O(state, data={**O.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=True, insertion=True, ns=100, order=1)\n",
    "\n",
    "print(O(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "677094a5-23a2-45cd-981f-40a7197ea6a2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=O.dtype, device=O.device)\n",
    "\n",
    "print(torch.vmap(O)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return O(state, data={**O.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=O.dtype, device=O.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "3b261fda-33d5-4c6b-8b81-a202a8e1f393",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 9.9997e-01,  1.9900e-01, -4.6335e-05, -4.6105e-06],\n",
      "        [-3.3141e-04,  9.9997e-01, -4.6567e-04, -4.6335e-05],\n",
      "        [-4.6335e-05, -4.6105e-06,  1.0000e+00,  1.9901e-01],\n",
      "        [-4.6567e-04, -4.6335e-05,  3.3141e-04,  1.0000e+00]],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([-5.7528e-10, -5.7815e-09, -4.0127e-09, -4.0327e-08],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(O)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "mo = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, mo):\n",
    "    return O(state, data={**O.table(), **{'mo': mo}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, mo))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "b1b01a89-88dc-41ae-b6fd-bab27e90eb5c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0090, -0.0050, -0.0048,  0.0010], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(O(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(O.container_output.shape)\n",
    "print(O.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "O.ns = 100\n",
    "\n",
    "O(state)\n",
    "print(O.container_output.shape)\n",
    "print(O.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "1aa2f3ff-9a61-45d3-a73e-c10a02b47ce5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00900492936806216, -0.005000291964120008, -0.004801202138358545, 0.0009979801465156844]\n",
      "[0.00900492932612774, -0.005000291993015304, -0.004801202228807697, 0.0009979801116093128]\n",
      "[4.193442121325219e-11, 2.889529587823958e-11, 9.044915164069245e-11, 3.4906371629978006e-11]\n",
      "\n",
      "[0, 1, 2, 1, 0]\n",
      "[0.5, 0.5, 1.0, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "O = Octupole('O', length, mo, dp, order=0, exact=True)\n",
    "\n",
    "# For octupole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "O.ns = 10\n",
    "ref = O(state)\n",
    "\n",
    "O.ns = 100\n",
    "res = O(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = O._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4d8ff990-9a7c-49d1-8fe7-a1d56543240a",
   "metadata": {},
   "source": [
    "# Example-09: Multipole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "576ab5fc-23cd-4f73-91c9-3f2390ab66a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of sextupole element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "9bd9ca75-a543-4d18-a08a-4caec0510a03",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.multipole import Multipole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "1ea961e2-8b60-490b-b1cc-974ebee5ad31",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00892946929535585, 0.0009165531774213284, -0.0017930189940976037, 0.01128986832436645]\n",
      "[0.008929469295357165, 0.0009165531774215092, -0.001793018994097765, 0.011289868324367684]\n",
      "[-1.3149203947904198e-15, -1.8084492237058214e-16, 1.6132928326584306e-16, -1.2333883914195098e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "dp = 0.005\n",
    "length = 0.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "M = Multipole('M', length=length, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = M(state, alignment=align, data={**M.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0b1ce0b6-0c4a-4796-be88-38ccf35281cf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00892945162589142, 0.0009165626425029898, -0.0017929090323601758, 0.011289834389170184]\n",
      "[0.008929451625892749, 0.0009165626425031966, -0.0017929090323603035, 0.011289834389171444]\n",
      "[-1.3287981825982342e-15, -2.067573542929857e-16, 1.2771901591879242e-16, -1.259409243559162e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "dp = 0.005\n",
    "length = 0.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "M = Multipole('M', length=length, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = M(state, alignment=align, data={**M.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "62bd9fb6-e013-469f-ae20-fec3ac487c93",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.001664975746516068, -0.04016261215593401, -0.015906155451718536, -0.05363979979736713]\n",
      "[0.001664975746510186, -0.040162612155939637, -0.015906155451718453, -0.053639799797374155]\n",
      "[5.882013626168359e-15, 5.627442956068762e-15, -8.326672684688674e-17, 7.022160630754115e-15]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "dp = 0.005\n",
    "length = 0.5\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:quadrupole,l={length},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "M = Multipole('M', length=length, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=5, ns=10)\n",
    "res = M(state, alignment=align, data={**M.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "878fb0a8-a137-4295-a232-8b4526fda4a1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0092, -0.0028, -0.0043,  0.0055], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0085, -0.0159, -0.0060, -0.0224], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(M(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(M(state, data={**M.table(), **{'dl': -M.length}}))\n",
    "print()\n",
    "\n",
    "# In the above M.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**M.table(), **{'dl': -M.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(M(state, data={**M.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "MA = Multipole('MA', length, kn, ks, ms, mo, dp)\n",
    "MB = Multipole('MB', length - 0.1, kn, ks, ms, mo, dp)\n",
    "\n",
    "print(MA(state) - MB(state, data={**MB.table(), **{'dl': torch.tensor(+0.1, dtype=MB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "2a65d2c6-623b-4732-bc00-4d39b5f38b34",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 6.9389e-18, -1.8792e-04, -8.6736e-19, -2.5229e-04],\n",
      "       dtype=torch.float64)\n",
      "tensor([ 6.9389e-18, -1.7347e-18, -8.6736e-19, -4.3368e-19],\n",
      "       dtype=torch.float64)\n",
      "tensor([-0.0004,  0.0009,  0.0002,  0.0021], dtype=torch.float64)\n",
      "tensor([-7.9785e-07, -1.9093e-04, -5.6642e-07, -2.5071e-04],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=False, insertion=True)\n",
    "\n",
    "# Since multipole is a nonlinear element (non-zero sextupole or octupole)\n",
    "# Insertion is an identity transformation only for zero strenght\n",
    "\n",
    "print(M(state) - state)\n",
    "print(M(state, data={**M.table(), **{'ms': -ms, 'mo': -mo}}) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(M(state, data={**M.table(), **{'dl': 0.1}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=True, insertion=True, ns=20, order=1)\n",
    "\n",
    "print(M(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "64156722-a31b-46e4-b9a9-28d4bba7333b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=True)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=M.dtype, device=M.device)\n",
    "\n",
    "print(torch.vmap(M)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return M(state, data={**M.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=M.dtype, device=M.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "f4aa669b-d048-4e9c-a9cf-2d86e7a7d6f5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 1.0353,  0.2012,  0.0274,  0.0017],\n",
      "        [ 0.3588,  1.0353,  0.2757,  0.0274],\n",
      "        [ 0.0274,  0.0017,  0.9653,  0.1969],\n",
      "        [ 0.2757,  0.0274, -0.3449,  0.9653]], dtype=torch.float64)\n",
      "\n",
      "tensor([-1.9468e-04, -1.9487e-03, -9.6920e-05, -9.5528e-04],\n",
      "       dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=False)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(M)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "kn = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, kn):\n",
    "    return M(state, data={**M.table(), **{'kn': kn}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, kn))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "2f7a7c2a-5f81-4cbf-b86d-05c754f556e4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0092, -0.0028, -0.0043,  0.0055], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(M(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(M.container_output.shape)\n",
    "print(M.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "M.ns = 100\n",
    "\n",
    "M(state)\n",
    "print(M.container_output.shape)\n",
    "print(M.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "5e8e13be-6c21-4ec3-b54d-b1ac92b29d89",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.009228705737231328, -0.0027662827194168435, -0.0043416399485996455, 0.0055422008499342295]\n",
      "[0.009228699312521689, -0.0027663108074714327, -0.0043416467924913375, 0.0055422142138782556]\n",
      "[6.424709639296644e-09, 2.808805458923494e-08, 6.843891692080717e-09, -1.336394402605412e-08]\n",
      "\n",
      "[0, 1, 2, 1, 0]\n",
      "[0.5, 0.5, 1.0, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "ms = 25.0\n",
    "mo = 110.0\n",
    "mo = 50.0\n",
    "dp = 0.005\n",
    "length = 0.2\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "M = Multipole('M', length, kn, ks, ms, mo, dp, order=0, exact=True)\n",
    "\n",
    "# For multipole with non-zero sextupole and/or octupole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "M.ns = 10\n",
    "ref = M(state)\n",
    "\n",
    "M.ns = 100\n",
    "res = M(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = M._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "96686a69-20a6-4bf4-ae7e-8725c634ec1c",
   "metadata": {},
   "source": [
    "# Example-10: Dipole (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7396d90f-93dc-4087-b2db-8a8e044e4d5b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of dipole element with MADX-PTC and other features\n",
    "\n",
    "# Note, cylindrical multipole is included upto octupole order\n",
    "# Potential is not truncated in paraxial case, only sqrt is expanded \n",
    "# In exact case effects of multipoles are not accounted in wedges (cases with e1 or e2 not equal to zero)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "8331a8a0-0761-42fb-ac91-5c9490717526",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.sextupole import Sextupole\n",
    "from model.library.dipole import Dipole"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "207dea76-8d75-418a-8e5d-a4fbd3110a11",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[5.160257777686003e-05, -0.004956273150572646, -0.0030019980019983517, 0.001]\n",
      "[5.160257777670049e-05, -0.004956273150572624, -0.003001998001997979, 0.001]\n",
      "[1.5954034968124198e-16, -2.2551405187698492e-17, -3.725318664660193e-16, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0113463c-b1dc-499b-bbf6-ea4b65a35d33",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[6.408749411377232e-05, -0.00494998958983017, -0.002995752944647053, 0.0010049983869644134]\n",
      "[6.408749411361558e-05, -0.0049499895898301935, -0.002995752944646423, 0.001004998386964413]\n",
      "[1.5673497655993573e-16, 2.3418766925686896e-17, -6.29704621779581e-16, 4.336808689942018e-19]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, e1 & e2)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "dcd83a30-099d-45f2-8500-20e175ed1f07",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0027250502286323983, -0.004697460778410744, -0.007781317874336121, -0.004015687563474919]\n",
      "[0.0027250502286329382, -0.004697460778410177, -0.007781317874339214, -0.004015687563475917]\n",
      "[-5.399326818977812e-16, -5.672545766444159e-16, 3.093011957666647e-15, 9.983333604246525e-16]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, e1 & e2, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "914e2fda-da37-414d-a083-9e8c49518162",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.002043638956596164, -0.006566087436123452, -0.00259447159458907, 0.0010855376916213359]\n",
      "[-0.002044085292481253, -0.006566346702412594, -0.0025944404024843, 0.0010855252766681649]\n",
      "[4.4633588508913996e-07, 2.5926628914162836e-07, -3.11921047697547e-08, 1.2414953170971493e-08]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, kn & ks)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = False\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "d881da15-8f29-4801-8864-ca03a21005fa",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013167193439103305, 0.005511119368028012, -0.010781508233295324, -0.007329921037793256]\n",
      "[0.013155910631909329, 0.005501237219297177, -0.01077978061323904, -0.007328193049690298]\n",
      "[1.1282807193976202e-05, 9.88214873083506e-06, -1.7276200562840738e-06, -1.7279881029579405e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, kn & ks, alignment)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "bd452fc9-ae8e-4e24-88c7-bb9930c5f33b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013072849472264409, 0.005416718324594963, -0.010908836090706359, -0.007452351251381879]\n",
      "[0.013061618858280511, 0.005406876286035405, -0.010906993838412468, -0.007450515116391215]\n",
      "[1.1230613983897672e-05, 9.842038559557814e-06, -1.8422522938908031e-06, -1.8361349906643315e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "02298fb0-7cc7-41a1-9efe-dc79991c115d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013030972087034147, 0.005379072261796265, -0.010940636831296861, -0.007479587493733525]\n",
      "[0.013019736470994862, 0.005369216085022898, -0.010938788726490435, -0.007477745021701217]\n",
      "[1.123561603928562e-05, 9.856176773366705e-06, -1.8481048064261651e-06, -1.8424720323075017e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (paraxial, e1 & e2, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in paraxial case, MADX seems to truncate cylindrical potential\n",
    "# Note, model dipole doesn't account for multipoles in wedges\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = False\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "48ce99f8-57cd-433a-98c4-13842cc9aea6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.002770798305588665, -0.004651371270674763, -0.007745680488823617, -0.0039921009984161026]\n",
      "[0.002770798305497435, -0.004651371270673967, -0.007745680488833819, -0.003992100998417079]\n",
      "[9.122997496335827e-14, -7.953707137353661e-16, 1.0202776123957591e-14, 9.766493169749424e-16]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "f345bcf6-1393-46d3-9947-1acf84b5a281",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013055723507830729, 0.005405610520344896, -0.01089583005089035, -0.007447552679263773]\n",
      "[0.013055723646615967, 0.005405610850033719, -0.010895828250285258, -0.007447551055281059]\n",
      "[-1.3878523850985314e-10, -3.296888231169026e-10, -1.8006050921115513e-09, -1.623982713930272e-09]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in model dipole cylindrical potential is truncated at octupole\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.0\n",
    "e2 = 0.0\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "75764464-2ec0-48e0-8a96-ef0bfb6d3268",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.013018589129527029, 0.005372361621197678, -0.010919187705983761, -0.007468383469439608]\n",
      "[0.013013881710655763, 0.005367955807036615, -0.010927596957623284, -0.007474796553900096]\n",
      "[4.707418871265426e-06, 4.4058141610630805e-06, 8.409251639522608e-06, 6.413084460487467e-06]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (exact, e1 & e2, kn & ks, ms & mo, alignment)\n",
    "\n",
    "# Note, in model dipole cylindrical potential is truncated at octupole\n",
    "# Note, model dipole doesn't account for multipoles in wedges\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag:sbend,l={length},angle={angle},e1={e1},e2={e2},knl={{0.0,{kn*length},{ms*length},{mo*length}}},ksl={{0.0,{ks*length}}},kill_ent_fringe=false,kill_exi_fringe=false;\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=5,sector_nmul=5 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "D = Dipole('D', length=length, angle=angle, e1=e1, e2=e2, kn=kn, ks=ks, ms=ms, mo=mo, dp=dp, exact=exact, order=2, ns=25)\n",
    "res = D(state, alignment=align, data={**D.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "28115334-e395-41d8-871a-9849beefd329",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-0.0020, -0.0066, -0.0026,  0.0011], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0044, -0.0061, -0.0038,  0.0013], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0130,  0.0054, -0.0109, -0.0075], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.1\n",
    "ks = 0.1\n",
    "ms = 0.1\n",
    "mo = 0.1\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(D(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dl': -0.5*D.length}}))\n",
    "print()\n",
    "\n",
    "# In the above D.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**D.table(), **{'dl': -D.length}} replaces the 'dl' key value \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(D(state, data={**D.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "DA = Dipole('DA', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "DB = Dipole('DB', length - 0.1, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "print(DA(state) - DB(state, data={**DB.table(), **{'dl': torch.tensor(+0.1, dtype=DB.dtype)}}))\n",
    "\n",
    "# Note, while in some cases float values can be passed as values to deviation variables\n",
    "# The correct behaviour in guaranteed only for tensors"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "d50366fa-d74c-4749-a4f0-1d6a525122c4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-1.7347e-18,  8.6736e-19,  8.6736e-19, -2.1684e-19],\n",
      "       dtype=torch.float64)\n",
      "tensor([ 9.9380e-06,  4.9995e-05, -1.9980e-06, -2.1684e-19],\n",
      "       dtype=torch.float64)\n",
      "tensor([-2.3859e-06, -5.8600e-06, -7.2738e-07, -2.4947e-07],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Insertion element\n",
    "\n",
    "import torch\n",
    "from model.library.dipole import Dipole\n",
    "\n",
    "# In this mode elements are treated as thin insertions (at the center)\n",
    "# Using parameters specified on initialization, transport two matrices are computed\n",
    "# These matrices are used to insert the element\n",
    "# Input state is transformed from the element center to its entrance\n",
    "# Next, transformation from the entrance frame to the exit frame is performed\n",
    "# This transformation can contain errors\n",
    "# The final step is to transform state from the exit frame back to the element center\n",
    "# Without errors, this results in identity transformation for linear elements\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.0\n",
    "ks = 0.0\n",
    "ms = 0.0\n",
    "mo = 0.0\n",
    "dp = 0.0\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=False, insertion=True)\n",
    "\n",
    "# For dipole insertion is an identity transformation in the following is true\n",
    "# dp = 0 (chomatic orbit change)\n",
    "# kn & ks and ms & mo are all equal to zero (nonlinearity of cylindrical potential)\n",
    "\n",
    "print(D(state) - state)\n",
    "\n",
    "# Represents effect of an error (any nonzero value of strengh or a change in other parameter)\n",
    "\n",
    "print(D(state, data={**D.table(), **{'dp': 0.001}}) - state)\n",
    "\n",
    "# Exact tracking corresponds to inclusion of kinematic term as errors\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=True, insertion=True)\n",
    "\n",
    "print(D(state) - state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "f3db79ab-c1e6-4b72-b424-4bb50cf75380",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(D)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, dp):\n",
    "    return D(state, data={**D.table(), **{'dp': dp}})\n",
    "\n",
    "dp = 1.0E-3*torch.randn(512, dtype=D.dtype, device=D.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dp).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "bedf0bb0-593f-4f90-9353-9a7bd59d99bc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 0.3083,  1.4545,  1.0125,  0.6652],\n",
      "        [-0.3993,  0.3083,  1.0602,  1.0168],\n",
      "        [ 1.0168,  0.6652,  2.3568,  2.8065],\n",
      "        [ 1.0602,  1.0125,  1.7383,  2.3568]], dtype=torch.float64)\n",
      "\n",
      "tensor([0.0004, 0.0002, 0.0005, 0.0005], dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(D)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "e1 = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(state, e1):\n",
    "    return D(state, data={**D.table(), **{'e1': e1}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, e1))\n",
    "print()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "108c29b5-70db-4226-b30c-5e231bf5bd5e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-0.0086, -0.0098, -0.0022, -0.0008], dtype=torch.float64)\n",
      "torch.Size([10, 4])\n",
      "torch.Size([10, 4, 4])\n",
      "torch.Size([100, 4])\n",
      "torch.Size([100, 4, 4])\n"
     ]
    }
   ],
   "source": [
    "# Output at each step\n",
    "\n",
    "# It is possible to collect output of state or tangent matrix at each integration step\n",
    "# Number of integratin steps is controlled by ns parameter on initialization\n",
    "# Alternatively, desired integration step length can be passed\n",
    "# Number of integration steps is computed as ceil(length/ds)\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=False, ns=10, output=True, matrix=True)\n",
    "\n",
    "# Final state is still returned\n",
    "\n",
    "print(D(state))\n",
    "\n",
    "# Data is added to special attributes (state and tangent matrix)\n",
    "\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)\n",
    "\n",
    "# Number of integration steps can be changed\n",
    "\n",
    "D.ns = 100\n",
    "\n",
    "D(state)\n",
    "print(D.container_output.shape)\n",
    "print(D.container_matrix.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "a728d14d-f46d-47b8-96ff-5b1528a81353",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[-0.008587515809774631, -0.00981976009190801, -0.0021662845096666753, -0.0008078063877268332]\n",
      "[-0.008587660168877737, -0.009820004323629564, -0.002166780652684309, -0.0008081645802833107]\n",
      "[1.4435910310542366e-07, 2.442317215550771e-07, 4.961430176337635e-07, 3.581925564774893e-07]\n",
      "\n",
      "[0, 1, 2, 3, 4, 3, 2, 1, 0]\n",
      "[0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5]\n"
     ]
    }
   ],
   "source": [
    "# Integration order is set on initialization (default value is zero)\n",
    "# This order is related to difference order as 2n + 2\n",
    "# Thus, zero corresponds to second order difference method\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "kn = 0.5\n",
    "ks = 0.5\n",
    "ms = 1.0\n",
    "mo = 1.0\n",
    "dp = 0.001\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "D = Dipole('D', length, angle, e1, e2, kn, ks, ms, mo, dp, exact=True, ns=10)\n",
    "\n",
    "# For dipole integration is always performed\n",
    "# In exact case, kinematic term error is added\n",
    "\n",
    "D.ns = 10\n",
    "ref = D(state)\n",
    "\n",
    "D.ns = 100\n",
    "res = D(state)\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "print()\n",
    "\n",
    "# Integrator parameters are stored in data attribute (if integration is actually performed)\n",
    "\n",
    "maps, weights = D._data\n",
    "print(maps)\n",
    "print(weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "06d311c6-8138-433b-9ab1-c854eaf0e3e8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0.2210, 0.1703], dtype=torch.float64)\n",
      "tensor([-0.2310, -0.2107], dtype=torch.float64)\n",
      "tensor([[ 0.6149,  0.1072],\n",
      "        [-0.2916, -0.3693]], dtype=torch.float64)\n",
      "tensor([ 4.0159e-16, -1.2143e-16], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Derivatives of twiss parameters (chromaticity)\n",
    "\n",
    "# pip install git+https://github.com/i-a-morozov/twiss.git@main\n",
    "\n",
    "from twiss import twiss\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.21)\n",
    "QD = Quadrupole('QD', 0.5, -0.19)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Dipole('DR', 3.50, 0.15)\n",
    "\n",
    "def fodo(state, dp, dms):\n",
    "    dmsf, dmsd = dms\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = BM(state, data={**BM.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = QD(state, data={**QD.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SD(state, data={**SD.table(), **{'dp': dp, 'ms': dmsd}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = BM(state, data={**BM.table(), **{'dp': dp}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = SF(state, data={**SF.table(), **{'dp': dp, 'ms': dmsf}})\n",
    "    state = DR(state, data={**DR.table(), **{'dp': dp}})\n",
    "    state = QF(state, data={**QF.table(), **{'dp': dp}})\n",
    "    return state\n",
    "\n",
    "dp = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "dmsf = torch.tensor(0.0, dtype=torch.float64)\n",
    "dmsd = torch.tensor(0.0, dtype=torch.float64)\n",
    "dms = torch.stack([dmsf, dmsd])\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "def tune(dp, dms):\n",
    "    matrix = torch.func.jacrev(fodo)(state, dp, dms)\n",
    "    tune, *_ = twiss(matrix)\n",
    "    return tune\n",
    "\n",
    "def chromaticity(dms):\n",
    "    return torch.func.jacrev(tune)(dp, dms)\n",
    "\n",
    "# Compute tunes\n",
    "\n",
    "tunes = tune(dp, dms)\n",
    "print(tunes)\n",
    "\n",
    "# Compute chromaticity\n",
    "\n",
    "chromaticities = chromaticity(dms)\n",
    "print(chromaticities)\n",
    "\n",
    "# Compute derivative of chromaticities \n",
    "\n",
    "jacobian = torch.func.jacrev(chromaticity)(dms)\n",
    "print(jacobian)\n",
    "\n",
    "# Correct chomaticity\n",
    "\n",
    "print(chromaticity(dms - torch.linalg.pinv(jacobian) @ chromaticities))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "02f34857-7739-4c9f-a7b2-194afe494250",
   "metadata": {},
   "source": [
    "# Example-11: Corrector (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "6cf3434e-ef9b-4abb-80a0-161ed75e11b7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of corrector element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "8cf9243c-0141-48d0-939f-ed1727e53d0f",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.corrector import Corrector"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "56f915fc-864f-4777-b8d8-9940b5361896",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.001, 0.0, -0.005]\n",
      "[0.0, 0.001, 0.0, -0.005]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "cx:hkicker,l=0.0,kick={cx};\n",
    "cy:vkicker,l=0.0,kick={cy};\n",
    "map:line=(cx, cy) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "C = Corrector('C', cx=cx, cy=cy, dp=dp)\n",
    "res = C(state, alignment=align, data={**C.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "154f0b88-3fd8-4a93-8bad-7f8649426d99",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.0014941712485121669, 0.0, -0.004875187409743301]\n",
      "[-6.938893903907228e-18, 0.0014941712485121667, 0.0, -0.004875187409743301]\n",
      "[6.938893903907228e-18, 2.168404344971009e-19, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (alignment)\n",
    "\n",
    "# Only dx and dy alignment errors seems to work as expected in MADX \n",
    "# Also, wz rotation can be assosiated with tilt\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = align*torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "cx:hkicker,l=0.0,kick={cx},tilt={wz.item()};\n",
    "cy:vkicker,l=0.0,kick={cy},tilt={wz.item()};\n",
    "map:line=(cx, cy) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "C = Corrector('C', cx=cx, cy=cy, dp=dp)\n",
    "res = C(state, alignment=align, data={**C.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "1f2b1b47-8f6c-4190-ba23-dfc8496b8caf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0000,  0.0010,  0.0000, -0.0050], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0000, -0.0010,  0.0000,  0.0050], dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "C = Corrector('C', cx, cy, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(C(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(C(state, data={**C.table(), **{'cx': -cx, 'cy': -cy}}))\n",
    "print()\n",
    "\n",
    "# In the above C.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**C.table(), **{'cx': -cx, 'cy': -cy}} replaces the 'cx' and 'cy' key values \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(C(state, data={**C.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "CA = Corrector('CA', cx, cy, dp)\n",
    "CB = Corrector('CB', cx - 0.001, cy, dp)\n",
    "\n",
    "print(CA(state) - CB(state, data={**CB.table(), **{'cx': + 0.001}}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "bb87ec24-04cc-45e6-a77c-ae8376ab7ea3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "C = Corrector('C', cx, cy, dp)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=C.dtype, device=C.device)\n",
    "\n",
    "print(torch.vmap(C)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, cx, cy):\n",
    "    return C(state, data={**C.table(), **{'cx': cx, 'cy': cy}})\n",
    "\n",
    "cx = 1.0E-3*torch.randn(512, dtype=C.dtype, device=C.device)\n",
    "cy = 1.0E-3*torch.randn(512, dtype=C.dtype, device=C.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, cx, cy).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ce4d05a0-9f36-4ba5-b82f-79052615687b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[1., 0., 0., 0.],\n",
      "        [0., 1., 0., 0.],\n",
      "        [0., 0., 1., 0.],\n",
      "        [0., 0., 0., 1.]], dtype=torch.float64)\n",
      "\n",
      "tensor([[0., 0.],\n",
      "        [1., 0.],\n",
      "        [0., 0.],\n",
      "        [0., 1.]], dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "cx = +0.001\n",
    "cy = -0.005\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "C = Corrector('C', cx, cy, dp)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(C)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "dcx = torch.tensor(0.0, dtype=torch.float64)\n",
    "dcy = torch.tensor(0.0, dtype=torch.float64)\n",
    "dc = torch.stack([dcx, dcy])\n",
    "\n",
    "def wrapper(state, dc):\n",
    "    dcx, dcy = dc\n",
    "    return C(state, data={**C.table(), **{'cx': dcx, 'cy': dcy}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, dc))\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd58df7d-32e6-4019-8bb5-44ae51af421b",
   "metadata": {},
   "source": [
    "# Example-12: Gradient (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "57c86b2d-a0ea-41b1-934f-7f159937bd3e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Comparison of gradient element with MADX-PTC and other features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "21f5ddf4-257d-475d-a246-14ac7c8b42cb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.gradient import Gradient"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "0fd74c26-8051-4021-a8b9-d1869b628f87",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.001, 7.5e-06, -0.005, -2.75e-05]\n",
      "[0.001, 7.5e-06, -0.005, -2.75e-05]\n",
      "[0.0, 0.0, 0.0, 0.0]\n"
     ]
    }
   ],
   "source": [
    "# Tracking\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = False\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,{kn}}},ksl={{0.0,{ks}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "G = Gradient('G', kn=kn, ks=ks, dp=dp)\n",
    "res = G(state, alignment=align, data={**G.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "d7bc6085-448a-4ad9-9d57-57cfd750f72a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.000991887042015914, 0.00016412084104346932, -0.005011606734840507, 0.00023479809553215934]\n",
      "[0.0009918870420159223, 0.00016412084104346948, -0.005011606734840506, 0.00023479809553215904]\n",
      "[-8.239936510889834e-18, -1.6263032587282567e-19, -8.673617379884035e-19, 2.981555974335137e-19]\n"
     ]
    }
   ],
   "source": [
    "# Tracking (alignment)\n",
    "\n",
    "ptc = Path('ptc')\n",
    "obs = Path('track.obs0001.p0001')\n",
    "\n",
    "exact = True\n",
    "align = True\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "\n",
    "dp = 0.005\n",
    "\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "qx, px, qy, py = state.tolist()\n",
    "\n",
    "dx = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = align*torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = align*torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = align*torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = align*torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = align*torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "code = f\"\"\"\n",
    "mag: multipole,knl={{0.0,{kn}}},ksl={{0.0,{ks}}};\n",
    "map:line=(mag) ;\n",
    "beam,energy=1.0E+6,particle=electron ;\n",
    "set,format=\"20.20f\",\"-20s\" ;\n",
    "use,period=map ;\n",
    "select,flag=error,pattern=\"mag\" ;\n",
    "ealign,dx={dx.item()},dy={dy.item()},ds={dz.item()},dphi={wx.item()},dtheta={wy.item()},dpsi={wz.item()} ;\n",
    "ptc_create_universe,sector_nmul_max=10,sector_nmul=10 ;\n",
    "ptc_create_layout,model=1,method=6,nst=1000,exact={str(exact).lower()} ;\n",
    "ptc_setswitch,fringe=false,time=true,totalpath=true,exact_mis=true ;\n",
    "ptc_align ;\n",
    "ptc_start,x={qx},px={px},y={qy},py={py},pt={dp},t=0.0 ;\n",
    "ptc_track,icase=5,deltap=0.,turns=1,file=track,maxaper={{1.,1.,1.,1.,1.,1.}} ;\n",
    "ptc_track_end ;\n",
    "ptc_end ;\n",
    "\"\"\" \n",
    "\n",
    "with ptc.open('w') as stream:\n",
    "    stream.write(code)\n",
    "    \n",
    "system(f'madx < {str(ptc)} > /dev/null')\n",
    "\n",
    "with obs.open('r') as stream:\n",
    "    for line in stream:\n",
    "        continue\n",
    "    _, _, qx, px, qy, py, *_ = line.split()\n",
    "    \n",
    "ref = torch.tensor([float(x) for x in (qx, px, qy, py)], dtype=torch.float64)\n",
    "\n",
    "G = Gradient('G', kn=kn, ks=ks, dp=dp)\n",
    "res = G(state, alignment=align, data={**G.table(), **error})\n",
    "\n",
    "print(ref.tolist())\n",
    "print(res.tolist())\n",
    "print((ref - res).tolist())\n",
    "\n",
    "ptc.unlink()\n",
    "obs.unlink()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "2cd7bc99-9036-4513-bc86-988b6ca18592",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 1.0000e-03,  7.5000e-06, -5.0000e-03, -2.7500e-05],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([ 0.0010,  0.0000, -0.0050,  0.0000], dtype=torch.float64)\n",
      "\n",
      "tensor([ 1.0000e-03,  3.2500e-05, -5.0000e-03,  4.7500e-05],\n",
      "       dtype=torch.float64)\n",
      "\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Deviation/error variables\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "G = Gradient('G', kn, ks, dp)\n",
    "\n",
    "# Each element has two variant of a call method\n",
    "# In the first case only state is passed, it is transformed using parameters specified on initializaton\n",
    "\n",
    "print(G(state))\n",
    "print()\n",
    "\n",
    "# Deviation errors can be also passed to call method\n",
    "# These variables are added to corresponding parameters specified on initializaton\n",
    "# For example, element lenght can changed\n",
    "\n",
    "print(G(state, data={**G.table(), **{'kn': -kn, 'ks': -ks}}))\n",
    "print()\n",
    "\n",
    "# In the above G.table() creates default deviation dictionary (with zero values for each deviaton)\n",
    "# {**G.table(), **{'kn': -kn, 'ks': -ks}} replaces the 'kn' and 'ks' key values \n",
    "\n",
    "# Additionaly, alignment errors are passed as deivation variables\n",
    "# They are used if alignment flag is raised\n",
    "\n",
    "print(G(state, data={**G.table(), **error}, alignment=True))\n",
    "print()\n",
    "\n",
    "\n",
    "# The following elements can be made equivalent using deviation variables\n",
    "\n",
    "GA = Gradient('GA', kn, ks, dp)\n",
    "GB = Gradient('GB', kn - 0.001, ks, dp)\n",
    "\n",
    "print(GA(state) - GB(state, data={**GB.table(), **{'kn': + 0.001}}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "5ddbeefa-aebe-4d0f-878e-32e8fd24a294",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n",
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "# Call method can be used to map over a set of initial conditions\n",
    "# Note, device can be set to cpu or gpu via base element classvariables\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "dp = 0.005\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "G = Gradient('G', kn, ks, dp)\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=G.dtype, device=G.device)\n",
    "\n",
    "print(torch.vmap(G)(state).shape)\n",
    "\n",
    "# To map over deviations parameters a wrapper function (or a lambda expression) can be used\n",
    "\n",
    "def wrapper(state, kn, ks):\n",
    "    return G(state, data={**G.table(), **{'kn': kn, 'ks': ks}})\n",
    "\n",
    "kn = 1.0E-3*torch.randn(512, dtype=G.dtype, device=G.device)\n",
    "ks = 1.0E-3*torch.randn(512, dtype=G.dtype, device=G.device)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, kn, ks).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "4a66a9ac-180a-4c5e-8e49-88cf53b78fd0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 1.0000,  0.0000,  0.0000,  0.0000],\n",
      "        [-0.0050,  1.0000, -0.0025,  0.0000],\n",
      "        [ 0.0000,  0.0000,  1.0000,  0.0000],\n",
      "        [-0.0025,  0.0000,  0.0050,  1.0000]], dtype=torch.float64)\n",
      "\n",
      "tensor([[-0.0000,  0.0000],\n",
      "        [-0.0010, -0.0050],\n",
      "        [-0.0000,  0.0000],\n",
      "        [-0.0050,  0.0010]], dtype=torch.float64)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "# Both call methods are differentiable\n",
    "# Derivative with respect to state can be computed directly\n",
    "# For deviation variables, wrapping is required\n",
    "\n",
    "kn = +5.0E-3\n",
    "ks = -2.5E-3\n",
    "dp = 0.005\n",
    "state = torch.tensor([0.001, 0.0, -0.005, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(+0.01, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.01, dtype=torch.float64)\n",
    "dz = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.0, dtype=torch.float64)\n",
    "wy = torch.tensor(0.0, dtype=torch.float64)\n",
    "wz = torch.tensor(torch.pi, dtype=torch.float64)\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "G = Gradient('G', kn, ks, dp)\n",
    "\n",
    "# Compute derivative with respect to state\n",
    "\n",
    "print(torch.func.jacrev(G)(state))\n",
    "print()\n",
    "\n",
    "# Compute derivative with respect to a deviation variable\n",
    "\n",
    "dkn = torch.tensor(0.0, dtype=torch.float64)\n",
    "dks = torch.tensor(0.0, dtype=torch.float64)\n",
    "dk = torch.stack([dkn, dks])\n",
    "\n",
    "def wrapper(state, dk):\n",
    "    dkn, dks = dk\n",
    "    return G(state, data={**G.table(), **{'kn': dkn, 'ks': dks}})\n",
    "\n",
    "print(torch.func.jacrev(wrapper, 1)(state, dk))\n",
    "print()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2d39e1ec-6a49-49f0-be16-7d87e66b4b33",
   "metadata": {},
   "source": [
    "# Example-13: Linear (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "e3774f55-fcb6-4b32-855f-640856f2abc7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Can be used to model elements as linear transformations\n",
    "# Constant offset can be used to model first order dispersion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "614d15e9-7236-454b-a328-3129e100a722",
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.dipole import Dipole\n",
    "from model.library.linear import Linear"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "4f736fd9-de5b-4f98-9493-9d414d802936",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.012284014325104016, 0.013015328226371463, 0.005866573649483532, 0.01748719571870364]\n",
      "[0.012284330668424102, 0.013015814342968814, 0.005867420763768485, 0.01748647747810468]\n",
      "[-3.163433200861071e-07, -4.861165973507608e-07, -8.471142849530294e-07, 7.182405989576701e-07]\n"
     ]
    }
   ],
   "source": [
    "# Linear quadrupole\n",
    "\n",
    "length = 1.0\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0\n",
    "Q = Quadrupole('Q', length, kn, ks, dp)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "matrix = torch.func.jacrev(lambda state, dp: Q(state, data={**Q.table(), **{'dp': dp}}), 0)(state, Q.dp)\n",
    "vector = torch.func.jacrev(lambda state, dp: Q(state, data={**Q.table(), **{'dp': dp}}), 1)(state, Q.dp)\n",
    "\n",
    "length = 1.0\n",
    "kn = - 2.0\n",
    "ks = + 1.5\n",
    "dp = 0.0001\n",
    "Q = Quadrupole('Q', length, kn, ks, dp)\n",
    "\n",
    "L = Linear('L', (dp*vector).tolist(), matrix.tolist())\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "print(Q(state).tolist())\n",
    "print(L(state).tolist())\n",
    "print((Q(state) - L(state)).tolist())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "c9d05c2e-a6f0-4dc0-a62a-a62c2c647850",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2.8326139356223135e-06, -0.005001000818821848, -0.002994615078158236, 0.001004198140800915]\n",
      "[9.165104284458664e-06, -0.004994998958072864, -0.002993748697591074, 0.001004997134048961]\n",
      "[-6.33249034883635e-06, -6.001860748984511e-06, -8.663805671619597e-07, -7.989932480460815e-07]\n"
     ]
    }
   ],
   "source": [
    "# Linear dipole\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "dp = 0.0\n",
    "D = Dipole('D', length, angle, e1, e2, dp)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "matrix = torch.func.jacrev(lambda state, dp: D(state, data={**D.table(), **{'dp': dp}}), 0)(state, D.dp)\n",
    "vector = torch.func.jacrev(lambda state, dp: D(state, data={**D.table(), **{'dp': dp}}), 1)(state, D.dp)\n",
    "\n",
    "length = 2.0\n",
    "angle = 0.05\n",
    "e1 = 0.025\n",
    "e2 = 0.025\n",
    "dp = 0.0001\n",
    "D = Dipole('D', length, angle, e1, e2, dp)\n",
    "\n",
    "L = Linear('L', (dp*vector).tolist(), matrix.tolist())\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "print(D(state).tolist())\n",
    "print(L(state).tolist())\n",
    "print((D(state) - L(state)).tolist())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ea354b5c-a05a-4e63-80e8-72432ddbc71a",
   "metadata": {},
   "source": [
    "# Example-14: BPM (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "3094cba7-8994-490d-9a9c-cf7c8ea73fbb",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import torch\n",
    "from model.library.drift import Drift\n",
    "from model.library.bpm import BPM"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "2875e9f6-0128-4332-b88d-4a876a6495d0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# BPM acts as identity transformation with calibration error\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "B(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "fff40a60-4558-40af-8cc1-aa4b7a20a044",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'xx': tensor(0., dtype=torch.float64),\n",
       " 'xy': tensor(0., dtype=torch.float64),\n",
       " 'yx': tensor(0., dtype=torch.float64),\n",
       " 'yy': tensor(0., dtype=torch.float64),\n",
       " 'dx': tensor(0., dtype=torch.float64),\n",
       " 'dy': tensor(0., dtype=torch.float64),\n",
       " 'dz': tensor(0., dtype=torch.float64),\n",
       " 'wx': tensor(0., dtype=torch.float64),\n",
       " 'wy': tensor(0., dtype=torch.float64),\n",
       " 'wz': tensor(0., dtype=torch.float64)}"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Calibration errors can be passed as deviation variables\n",
    "\n",
    "# qx -> xx qx + xy qy\n",
    "# qy -> yx qx + yy qy\n",
    "\n",
    "B.table()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "96342c98-66a8-4828-919c-d6de4148847e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "tensor([ 0.0105, -0.0048, -0.0042,  0.0011], dtype=torch.float64)\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Transform to BPM frame and back to beam frame\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "print(state)\n",
    "\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)\n",
    "\n",
    "B.direction = 'inverse'\n",
    "\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "5075d077-bfa4-4065-a765-0dce03220938",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n",
      "tensor([ 0.0105, -0.0048, -0.0042,  0.0011], dtype=torch.float64)\n",
      "tensor([ 0.0100, -0.0050, -0.0050,  0.0010], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Transform to BPM frame and back to beam frame using a pair of BPMS\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "BA = BPM('B', direction='forward')\n",
    "BB = BPM('B', direction='inverse')\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "print(state)\n",
    "\n",
    "state = BA(state, data={**BA.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)\n",
    "\n",
    "state = BB(state, data={**BB.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "print(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ef7f9850-585c-4e64-a9d9-309f7fc517c3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[ 5.0000e-03, -4.0000e-03,  0.0000e+00,  0.0000e+00],\n",
      "        [ 4.5880e-03, -2.4404e-04, -1.0625e-03,  5.6516e-05],\n",
      "        [ 0.0000e+00,  0.0000e+00,  5.0000e-03, -4.0000e-03],\n",
      "        [-4.8809e-05,  5.1249e-03,  1.1303e-05, -1.1868e-03]],\n",
      "       dtype=torch.float64)\n",
      "tensor([[ 0.0000e+00,  8.6736e-19,  0.0000e+00, -5.4888e-19],\n",
      "        [ 0.0000e+00,  0.0000e+00,  3.3881e-20,  0.0000e+00],\n",
      "        [-2.7105e-19,  0.0000e+00,  8.6736e-19,  0.0000e+00],\n",
      "        [ 2.1684e-19,  3.9302e-19, -3.3881e-21,  2.1684e-19]],\n",
      "       dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "D = Drift('D', 1.0)\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "error = torch.stack([xx, xy, yx, yy])\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "\n",
    "def line(state, error):\n",
    "    xx, xy, yx, yy = error\n",
    "    state = D(state)\n",
    "    state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "    return state\n",
    "    \n",
    "print(torch.func.jacrev(line, 1)(state, error))\n",
    "\n",
    "def line(state, error):\n",
    "    xx, xy, yx, yy = error\n",
    "    state = D(state)\n",
    "    B.direction = 'forward'\n",
    "    state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "    B.direction = 'inverse'\n",
    "    state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}})\n",
    "    return state\n",
    "    \n",
    "print(torch.func.jacrev(line, 1)(state, error))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "38d5bf9c-03dd-4ae9-949f-5024913df66f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([ 0.0105, -0.0048, -0.0042,  0.0011], dtype=torch.float64)\n",
      "tensor([ 0.0086, -0.0048, -0.0082,  0.0008], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Alignment support\n",
    "\n",
    "xx = torch.tensor(1.05, dtype=torch.float64)\n",
    "xy = torch.tensor(0.01, dtype=torch.float64)\n",
    "yx = torch.tensor(0.05, dtype=torch.float64)\n",
    "yy = torch.tensor(0.94, dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.05, dtype=torch.float64)\n",
    "dy = torch.tensor(-0.02, dtype=torch.float64)\n",
    "dz = torch.tensor(0.05, dtype=torch.float64)\n",
    "\n",
    "wx = torch.tensor(0.005, dtype=torch.float64)\n",
    "wy = torch.tensor(-0.005, dtype=torch.float64)\n",
    "wz = torch.tensor(0.1, dtype=torch.float64)\n",
    "\n",
    "error = {'dx': dx, 'dy': dy, 'dz': dz, 'wx': wx, 'wy': wy, 'wz': wz}\n",
    "\n",
    "B = BPM('B', direction='forward')\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}, **error})\n",
    "print(state)\n",
    "\n",
    "state = torch.tensor([0.01, -0.005, -0.005, 0.001], dtype=torch.float64)\n",
    "state = B(state, data={**B.table(), **{'xx': xx, 'xy': xy, 'yx': yx, 'yy': yy}, **error}, alignment=True)\n",
    "print(state)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37e17f59-4312-4476-86b1-090baf77b82a",
   "metadata": {},
   "source": [
    "# Example-15: Line (element)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "99804e4c-198f-4b74-b35d-4da7d066c585",
   "metadata": {},
   "outputs": [],
   "source": [
    "# In this example line usage is illustrated"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "72ddc9bb-790a-4505-9855-c812ab3c8367",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from os import system\n",
    "\n",
    "import matplotlib\n",
    "from matplotlib import pyplot as plt\n",
    "matplotlib.rcParams['text.usetex'] = True\n",
    "\n",
    "import torch\n",
    "\n",
    "from model.library.drift import Drift\n",
    "from model.library.quadrupole import Quadrupole\n",
    "from model.library.sextupole import Sextupole\n",
    "from model.library.dipole import Dipole\n",
    "from model.library.line import Line"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8779d6c6-dd7b-4def-be01-f1c4de04b196",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define unique elements\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.25)\n",
    "QD = Quadrupole('QD', 0.5, -0.20)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Dipole('BM', 3.50, torch.pi/8.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0ab37b81-2203-439f-ad56-a9844b69a4f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define a line\n",
    "# With propagate flag, values for other flags will be propagated to all root elements (but not to lines!)\n",
    "\n",
    "FODO = Line('FODO', \n",
    "            [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], \n",
    "            propagate=True, \n",
    "            dp=0.0, \n",
    "            exact=False, \n",
    "            output=False,\n",
    "            matrix = False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "9373e0b2-186a-4a9e-a5be-d462d80d3478",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n",
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Similar to elements, lines have to variants of call method\n",
    "\n",
    "# 1) without deviation variables\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "print(FODO(state))\n",
    "\n",
    "# 2) without deviation variables (defaut dictionary)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "print(FODO(state, data=FODO.table()))\n",
    "\n",
    "# In both cases, it is possible to apply alignments errors using alignment flag\n",
    "# Alignment errors can be applied to elements and to line as a whole (see examples below)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "48b097f3-083e-486f-a05c-bcf5c531e793",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'QF': {'kn': tensor(0., dtype=torch.float64),\n",
       "  'ks': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'DR': {'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'SF': {'ms': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'BM': {'dw': tensor(0., dtype=torch.float64),\n",
       "  'e1': tensor(0., dtype=torch.float64),\n",
       "  'e2': tensor(0., dtype=torch.float64),\n",
       "  'kn': tensor(0., dtype=torch.float64),\n",
       "  'ks': tensor(0., dtype=torch.float64),\n",
       "  'ms': tensor(0., dtype=torch.float64),\n",
       "  'mo': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'SD': {'ms': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)},\n",
       " 'QD': {'kn': tensor(0., dtype=torch.float64),\n",
       "  'ks': tensor(0., dtype=torch.float64),\n",
       "  'dp': tensor(0., dtype=torch.float64),\n",
       "  'dl': tensor(0., dtype=torch.float64)}}"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Values of deviation variables can be passed only to unique elements\n",
    "\n",
    "FODO.table(alignment=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "82570947-6828-4512-b786-1403ae4871ff",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=FODO.dtype, device=FODO.device)\n",
    "print(torch.vmap(FODO)(state).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "47fc6727-a7c8-4aea-a070-ce451cdda266",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([512, 4])\n"
     ]
    }
   ],
   "source": [
    "# Mapping over a set of initial conditions and parameters\n",
    "\n",
    "state = 1.0E-3*torch.randn((512, 4), dtype=FODO.dtype, device=FODO.device)\n",
    "dknqf = 1.0E-3*torch.randn(512, dtype=FODO.dtype, device=FODO.device)\n",
    "\n",
    "def wrapper(state, dknqf):\n",
    "    data = FODO.table()\n",
    "    data['QF']['kn'] = dknqf\n",
    "    return FODO(state, data=data)\n",
    "\n",
    "print(torch.vmap(wrapper)(state, dknqf).shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "91693306-3aa5-443c-8936-f70d778dac5d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[-0.4395, 15.4433,  0.0000,  0.0000],\n",
      "        [-0.0522, -0.4395,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  0.4963,  5.3596],\n",
      "        [ 0.0000,  0.0000, -0.1406,  0.4963]], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability (state)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "print(torch.func.jacrev(FODO)(state))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "cfdd131a-2aad-4429-a04e-9d911da90d26",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([0., 0., 0., 0.], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability (parameter)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "dknqf = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(dknqf):\n",
    "    data = FODO.table()\n",
    "    data['QF']['kn'] = dknqf\n",
    "    return FODO(state, data=data)\n",
    "\n",
    "print(torch.func.jacrev(wrapper)(dknqf))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "8d7eb47f-b2c6-41b7-99ac-3f4d9bc56b63",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[-0.4395, 15.4433,  0.0000,  0.0000],\n",
      "        [-0.0522, -0.4395,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  0.4963,  5.3596],\n",
      "        [ 0.0000,  0.0000, -0.1406,  0.4963]], dtype=torch.float64)\n",
      "tensor([[-7.5649, -3.8172,  0.0000,  0.0000],\n",
      "        [ 0.4176, -7.5649,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  2.7423,  1.3262],\n",
      "        [ 0.0000,  0.0000,  0.5426,  2.7423]], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# Differentiability (composed)\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "dknqf = torch.tensor(0.0, dtype=torch.float64)\n",
    "\n",
    "def wrapper(dknqf):\n",
    "    data = FODO.table()\n",
    "    data['QF']['kn'] = dknqf\n",
    "    return torch.func.jacrev(lambda state, data: FODO(state, data=data))(state, data)\n",
    "\n",
    "print(wrapper(dknqf))\n",
    "print(torch.func.jacrev(wrapper)(dknqf))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "87afaf52-e7aa-4219-93e5-d271c7f15b90",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7.19 s, sys: 34 µs, total: 7.19 s\n",
      "Wall time: 7.19 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "# Tracking\n",
    "\n",
    "# Note, in general tracking is slow\n",
    "# This is especially the case for exact integration of elements with large number of slices\n",
    "\n",
    "qx = torch.linspace(0.0, 0.01, 16, dtype=torch.float64)\n",
    "px = torch.zeros_like(qx)\n",
    "qy = torch.zeros_like(qx)\n",
    "py = torch.zeros_like(qx)\n",
    "\n",
    "state = torch.stack([qx, px, qy, py]).T\n",
    "orbit = []\n",
    "\n",
    "for _ in range(2**10):\n",
    "    state = torch.vmap(FODO)(state)\n",
    "    orbit.append(state)\n",
    "\n",
    "qx, px, *_ = torch.stack(orbit).swapaxes(0, -1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "a2cf3720-6952-434f-8f21-01beda3bb8d7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYYAAAFeCAYAAACB7binAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8fJSN1AAAACXBIWXMAAA9hAAAPYQGoP6dpAABV9ElEQVR4nO19zW4cR5J/dLcoeagZiWzdxuNug8Be5qhpvgH9BoQX1H05WsxtB+DA8MHYw8DbB98WaNIPIGFEvYH0BiS1T9DESJr1zWyStrTSWGT8D/5XOzuZVRWREVlV3YwfUNBHZX10VWX84jtbiIhgMBgMBsP/R7vuGzAYDAZDs2DEYDAYDIYZGDEYDAaDYQZGDAaDwWCYgRGDwWAwGGZgxGAwGAyGGRgxGAwGg2EGRgwGg8FgmMGNum+gabi8vITvvvsOfvOb30Cr1ar7dgwGg0EMRIQffvgBfvvb30K7XW4PGDF4+O677+CTTz6p+zYMBoNBHa9fv4bf/e53peOMGDz85je/AYCfH+CdO3dqvhuDwWCQ4/z8HD755JOpfCuDEYOHzH10584dIwaDwbBQoLrHLfhsMBgMhhkksxiOj4/h6dOnsLa2BsfHx7C9vQ0rKyvssbH7AACeP38Ox8fHsLa2BgAAGxsbqX6uwWAwLA4wEe7fvz/9+3g8xs3NzaixsfuePXuG29vb031ra2uk+z47O0MAwLOzM9J4g8FgaDq4ci2JxXB8fDzz77W1NXj+/Dl7bOw+AIA//vGPcHR0NN337NmziF9iMBgM1w9JYgzPnz+Hbrc783/dbhdevHjBGhu77/j4GE5OTmBlZQVevHgBp6enU3eSwWAwGIqRhBhOT0+D/39ycsIaG7vvxYsX0O12p/GHb7/9Fp4+fUq4c4PBYDBUmq6aJ8y5Y8v2nZycwPHxMWxsbMDKygpsb2/D6uoqYGAV0/fv38P79++n/z4/Pyffo8FgMCwiklgMKysrV6yDzLXDGRu7b21tbTomuwYABF1ZX3/9Ndy9e3e6WdWzwWC47khCDHlpoYPBgDU2dh8nnvDFF1/A2dnZdHv9+jX5WIPBYFhEJHEl+YL5+PgYBoPBjOaeafZFY30Lg7NvMBjA6ekprKysTGsZ7t+/f+Veb926Bbdu3RL/ZoPBYFgUJIsx7O/vw1/+8hdYX1+Hg4MD2N/fn+77+uuvYX19HXZ2dkrHSvf94Q9/gKOjI0tXNVSC9fV1ODw8hOXlZXj79i0MBgP4l3/5F3jy5AncuXMHJpMJrK6uwvn5+fTfvV4PfvzxRwAA+PWvfw2vXr0qHPPXv/4VHj58WOfPNCw4WhiKyF5jnJ+fw927d+Hs7Mx6JRlmkAn9IkF+cXFx5bhOpxP8/1gsLS3BTz/9dIU8XDI6ODhQu55h/sGVa9YryWDw8ODBA7hx4wZ0u11otVrQ7Xbhxo0bcHh4CAAAr169gpOTEzg5OYFXr14BAMBkMpkR/svLywDwc8zr888/h06nA6urqwAAsLq6OvPvXq8H3W4Xut0u9Hq90jE//fTTzDUnkwkAALx9+xYAAA4PD+HevXtw79496Pf70Gq1YH19PekzMywWzGLwYBbD9cKDBw/gyZMn8PHHH8M//vEP+Oijj+Ddu3dweXmZe0yRxfD555/Do0ePkt5zZrnkWQyZReGj0+lccWdVcb+G+sGVa0YMHowYFhsZEWQCMoTl5WV4//793ArR3d1d+PLLLwHgF+LKQ6vVglarBR999BF88803FrtYUBgxCGHEsFjY3d2F//qv/wJEzBWQnU5nxmJYRAHpE2JGdpeXl9PCT58QLVaxODBiEMKIYTGQCUJEvOIWcl0q1134PXjwAP72t7/lutDsWS0GLPhsuHbY3d2FTz/9FNbX16HT6cDt27fhb3/7G1xcXFwRdIPBAD58+AAnJyeAiNde0D169AguLi7gzZs38K//+q8zAW8AmAluHx4ewo0bN+DBgwd13a6hIhgxGOYW6+vr0Gq14E9/+hO8fPkSDg8P4fLyEt6+fQsfffQRdDod6PV60Ol0YGtry4igBI8ePZohza2trSBRPH78eCZby4hi8WDEYJg7ZOmkWfpoZhUsLS1Bu92G5eVl+Oabb+DDhw/w8uVL+PDhQ61B47z0V//f/X4fOp0O3Lx5E27fvg337t2D3d3d2u47jygyZOmyjx8/NoJYNKguE7QAsBXcmovBYIAAcGXr9XrY7/dxNBpVej9bW1vY6XRwdXUVAQBXV1dn/r28vBy8X87WarWw1Wphr9crvNZgMKjsd2fvodVqXbnXdruNy8vLlb8LQzG4cs2IwYMRQ3MwGo2w3+/jYDDATqczI4Q6nQ5ubW0lv4etrS1st9u4tLSEy8vLuLy8jDdv3pwKbKqALxLq2b97vd7MtdrtNptIqiQM//24z2N5ebmyd2QohxGDEEYM9SPTxPMEYwphl10zE87ZViT8W60WyWKIvd/RaITLy8ski4FKSimJIiNRn9RarZYRRM0wYhDCiKE+5LmKUlgIvhuoSPjnWQxNEnbZs6MQRhVEsbW1FSTRJj2z6wQjBiGMGKpHJqR94ZVpyRrChEIEIYth3gUZ9XenIArX4vEtrypjIgYjBjGMGKpDnoWgKTRCpFO1i6VJqIso8sh/3ol3XmDEIIQRQ3qECKEqyyDTXK8LEZSBShRaArwKZcBwFUYMQhgxpEOe9q4hFLLAZ55gGwwGtaS0zhvKiEIaUPevYxZENTBiEMKIQR+ZEND0M49GI+x2u7i0tBTMHrpuLqJUKHPFSQW5WRDVwIhBCCMGfbhCWypMMkLIyx6qq7jKzQrKMnCye8sC2WV1DNx/V6ldZ78vr2gvhQXRtMyveYYRgxBGDHrIJns24ZeXl0Xny9Muq8geyksHzf6d55+vYsuI9+bNm9jtdishxjxXkNRSC71jq6SWw4hBCCMGOfzJ3Wq1RP79kBBaXl5OKgR9IqAK6SothrL7qCLrKkXtSZbmau4lPRgxCGHEEA/tgGJV/uetra2p1p0JcarArcOtk8HvWXTz5s1CskhJFGVB65jrhRIKLEAdByMGIYwY+NAW4KkzVsr85SEimBdh1JQK6NA7jLXwtC3Q6wgjBiGMGOgIBYJjhGjWjK3X6yW1EIoybHyLYV6IgApKvUL2DDR9+iGlQaowaMWsrhOMGIQwYqCj3++rTPiQ5q6hpVeVkz+PoBCFljWhpUBk0Mxyuy4wYhDCiIGGTBPsdDpRLoJMWGgHGbN4Qcrc+0WEG2fJ26QEoeVyTFEXs+gwYhDCiKEYIXdMDEKEIBHYRdkxVuzGQ5E1oeFu0qqAt+ppOowYhDBiCENb29MISuadL7MY6iiQyiyhLJsmI8BQMLgoHdUdU7ewKyLdFGTO/ab883Q6neh7WlQYMQhhxDCLLDAs1cpCmSWxAs/v9V+1O8EX/pxFc6RbVifhau9VkUeRu0ny3LUC1O53YdbhLIwYhDBimEWm8cZ2JdU09/M0zJRCkZP+6W7aFgOHPNzV71IuxBOy1CQuppDmz32vVX0X8wYjBiGMGH6GX33abrdFx0s1wTzhmGLtBq7wr6LK2O/FFLIYiogi1b3lkXWsG0/qXrKmfGEYMQhhxBCeXJxJHnL11CEkypBHXqGtqhYTEriZYkXV2ymsCW03k9TS1EqSWBQYMQhhxDBrjnM0v5Ag19IctdwCruZdpl3HElqTUGYFaZNdRhA+SWi5D7mBZd8VOO/vMxZGDEJcZ2LwhQhVUGjGEULn0hJYZb76JloBmvCD5nmWkdaz0OyUKg0su+9+0d9zCEYMQlxHYvCblXG1Mg1BnsJtVKQtX3cNEpEeU9GoQNd4rxLFw7+H6wYjBiGuIzH4gp0z4VyBHitA/EkrEdhZ3CDP332diaAIFJKQknTIUuGcUyswfR1boRgxCHHdiMENGnLM/NAk5UKzwVp2rpDwqTtgnJGVuyaDGyB2M42a0sSvqKhN4z1J3EshtyDneV03FyKiEYMY14UYYoN6GpqfZkwib6lPiT+be3231iNUp1DWg6hsC9U3VKn1pqgfkWa++efguD81lJp5gxGDENeFGGImuIavWMNKKHJ79Hq9JL36Q9lMMZXOVIuBc06/niKVtZFXcR6beaapZMRYhe63uOhWQ2OIYTwe43A4xP39fRwOhziZTKLGxu5zsbOzU3h9F4tODH5mCmdCuJpv1eZ/hjztNcUyn25dAEVA51kMMQLb/Z1FFkMRAaVYXyFDnpIQQ8oa30asJaNlATUdjSGG+/fvT/8+Ho9xc3MzamzsvgxHR0cIAEYMeFWo9vt90nGSBVI0tMLQvbuCUjO1kiJw3b/XKUxCPZso915FgaAW6UsqninHXpcGfI0ghvF4PCO0ERFXVlbYY2P3udjf38e1tTUjBpzVjqgatjtxuEsqalRA58UQNMmgTKDGrjlRB0KtM4pIYmlpSfy7NFuWSK2H2LTURW/A1whi2Nvbw42NjZn/W1tbw6OjI9bY2H0Z9vf3p/9/nYlB4oeNmaBahU2aWUv+OfMEmasBL4pbgVL9rPFs86qepXUtXIUkNi3VfyaL8v4R+XKtDQlwenoa/P+TkxPW2Nh92XlXVlZK7hTg/fv3cH5+PrMtEnZ3d+Hx48dwcXEB5+fngIhwcHBQetyDBw/gxo0bsLq6CgAAg8EAHj16VHrc+vo6HB4eTv/d6XRga2sL3rx5Aw8fPiTdc3Zt9zzdbhdGoxHp3n3s7u7C7du3odPpTM95cXEx3b+6ujpzn/izwkT6vfOAR48ewYcPH+Dk5AS2trag0+lM3yvAL8/i8PAQOp0OdDodePDgQdR1Li8v4fLyEgaDwfT/Dw8PodVqwfr6OvlcBwcH03ttt9vw8uVL+POf/0w+FhHh7du30+tTru3e88XFBTx58oR8v4uGJMSQhzxhzh1L2ffkyRPY2Ngovc7XX38Nd+/enW6ffPIJ+R7nAe5k+vzzz0nHrK+vs8kkJMwHgwF8+PCBJGB3d3fh008/hX6/P722e57vv/+eTCz+Pf3pT3+Ct2/fwuXl5XRfp9OZks3JyQn5PucdLkmMRiPo9/vQ6/Wm+zPB/vjxYxFJHBwczAhagJ8F9O3bt2F3d5d1r9l7e/v2Ldy7d498vE9ON27cKPwtGaFsbW1Bq9WCi4sL1v0uFFKYLXt7e0H//7Nnz1hjY/c9e/ZsxnVU5Ep69+4dnp2dTbfXr18vhCvJ99VS2mZL/LsS90FeGqSk11Ke22SR3AOayJIE8lJlNddZ4L4HSZq0f21q+3h3HlCTNJqMRsQY8gLDIeFcNDZ2X0Yc2QYAuLOzE4xx+FiUGEP2YXNWSovteeROPm7GUqjQjUssoftwt16vV9kKZ3mL8Wj+PXVwNAVJhLLTOOcJJSFwEgK4sSP3GTShEl2KRhAD4tVUUjdQfHR0hOPxmDQ2dp8LAJi5XhEWgRhi+hfFHBMS7JKMpVarFd1507+PlG0wygigis0VsimFV166scSik5wnNiFhNBpFHed+V1VU0qdCY4hhPB7jzs4O7u/vXykw29zcxOFwSBobuw8RcTKZ4HA4RADA7e3thbcYQlpVGWIXNJFkDPmTNKYwKhNYoZTMVKuUlS2Ak9JKoBJPKssibyEeLeuBc68x33l2Xe637hPZvLqVGkMM84p5JgZ/snA1oljti6PxjUajK1oYF5oxiRBCVcdUAqjDzUMlKy13Wt7zj6lZcI+XVIfHtsK4Lm4lIwYh5pUY3I+93W6zi9eoH7sv2GMnZKvViioa8y2VTIvVqm8o2lyLoWlFUNRiPS0SLXIxSVtpx9bZcI51v2Fqr6fsmHmsjjZiEGJeicGdHGXCVsN91Ol0WELdFwCcY9221ZrCjdILqe62FxK4GnnKdRbqtB5iiSV0Pc4xTVMMymDEIMQ8EgPXpI5xH/kTSbJuA3VSZQSm0WvJv58iQTmPJEABxSqSCDz//Nz4g2avJAr8lumU9+5eI0UX31QwYhBiHomBMyFi/KudTmcm8Ji6sVnesbFCu6jZW6YtzksvJC0UkURsl9S883Lfma+EcPt6ca08V1EqO8a3MrvdLukadcOIQYh5IgZuD6SYBmMuIVAnWyhrRFLwJqlDyHN1zLOLSBt5zyiWiEPxB+46GRKlghsDc38/tQDO/b7nwa1kxCDEvBCD+zFTg2Fcrd+9BjV7qI7WyT78dtTuFruoDBd5QXJXALnvz/+3lnuHg7wuqbHZONL4Q0jBoBCLf13KfWcWZbvdJikMfmZe02HEIMS8EIMraKjmr7twSxligsWxLoDQsTHa/Gg0wqWlJTXNl3LP7spreYJdY/NJLnUBX17L7th1NCSJAzGV9X6iRBlGoxH2+/3pfVKOiU2XrQNGDELMAzFwNXl3QlLNee4kDhWtUeGTUMwkC2mn2qml3JRQLYuBsqUobMtrjRHj2ssjbeq9xqweGNNunpt55P6WJsOIQYh5IAZXcJRNEK5WEzOZRqPRjPDgtNSQpqDmBVE1hKPf15+q0WsGs/PcYtTV2mKeadGzkD7n2EaNkkZ63Gtxxseu/VA1jBiEaDIxcLMuuMFmrvkdugY1S0MaTwi5O7JFYiSCsMgdlVI7jwG1TkGLrPLShzUaHlKVlhhFgusWjZkHnPPXASMGIZpMDFyzlZOdEdPmwp9wMcuFZtoWJxYRcrVoFWmFAtbztKpbWdtxjeeVR57cuoWYIDHi1e+Ha3FQ3K9cyzkmDlIljBiEaCoxcHyfMfncrvCLKXjjuI9iBZRmbUPoXjTP3RSUVXdrr7MgeaecFvExKaauhUlVYjiWACchpGoYMQjRVGLg9GnhWBa+eR6zkAlFEGi4jvxjY4qwysiAm28/TyirfI5NDQ7FYDiCMWQFUp4/N8U0lPnGcSuVWQIxKeRVwYhBiCYSA6damWNZxPTGj+k0qdlFU+IGKav2vS4oSkeVEITvXuJaIy7BUNwxfoop5d792gjKdTj1P+6zbdL6DUYMQjSNGDiFNNygGTcF0BfwlN70sUI9m2A3b94UuXbyUi6rJgNKqitHwGmhzIKSNsPjvLPYlOcYtybH7cNN4mjisqBGDEI0jRg4pfdczZ+jNcUEjGPXbdDwXRcJvBRC179nyhoJ1C1EJtq/QbMtRih7KFbIx1TNczulAuimfcdY1alhxCBEU4gh87tmGnNZGijHheQL7FQCPqafTIgUuGmWoXNoTtIiKyRGyEvIJIWVIW1lkXeelFlH/vVStHxx74mCJq3fYMQgRFOIwTV1KcFQzkfITb/kZiwhzk7u2NqGmzdviglBS2CWBW4pQj5Wa46ptNYiQP+80lbaqftmcZ8BJ37AifUhNmv9BiMGIZpADBI3D8eFRMlAcs9NGa/V+IwzkULX1JiMZf537YWDOPcV6tHkbxorzhURYmyKMrelBeeaXJenJH5AKabknDsljBiEaAIxcFpecLs8xvSejx1PFUiSrKMUtQ1FGTtVkwAVlJoM6XORWEGh90StUud+H9wkCT8llUMkZRY618pIBSMGIeomBs6HxF1/mfuRSiYjJS4Q0vQlAerYlg9UN1HTyCAPblFbnkUR+1tCz4pjOYRINyblmTKeEwDmWCbcld+aEGswYhCibmKgfvx+FgY31bQMMZXWEiuBo32GtGONfj3+1qQ8dAk03EGUc8a6lqjHxmjfVMWJawm45y4b24RYgxGDEHUSAyclzv2IKcKLM0H8TqFlkGp/HE1fIpDc62sXeM0DtAlCQtC+C1T7O867x6JrcC0BjsDnKGUpYMQgRJ3EQP14uKmp1I89NFk5cYWq4wkxwkw7JjGPKCIIadYR51n631u73WZbvlxLg5LMwSEf6pytO9ZgxCBEXcTAEbAcn6Xrwy8b77cK4BT9UDQhrbz2GK2+SkKgBoK5m/a9avZOiiX80Wh0pQI/xbW4bS1SCPw6Yw1GDELURQwpPkR/0hWN59YdcCenpDVGrMDKa/AGwK+RyAO3vkFz01q/usi1Jqk2p1ofMQWUkpgZ5RoxAr9sbJ2xBiMGIeoghtjYQhH8eoUy36p7Xq45z9XAqrIU8khBKkzrJIOyTfLbiog09TuLqWPhume4NTkxweWy83LITBNGDELUQQzUjyXG3QRQbgFwW1dIFgCKtRQ4Ak+SM5/3GyjLe8YSGAXU+gotkqgjayzmnXOD0Zyqf46GTz1vXbEGIwYhqiYG6sfHKWRzWyAvLS0VWgASFxK3nUas1ikteNNMydQWwLHgkFXZN5AHSYuRWHKQFrNxFRVO5TI1caPMwqgj1mDEIETVxED9SDj9ityxRVWfnFS+0PgycE330DUkLowYoZ26gjglNIPJZeeNfS8x8QPtCn2O68evF6Kel1ozUVWswYhBiCqJgap9cwQsJ14QWzUdMz5F64O842ImXBkhaAV6q8BoNLqyjoXUgpAkAWgUQHK+N4oSksqlRFWcOAqWBowYhKiSGGI+orKP2BUIZaZvRgy9Xo91r1wNLpV/OXQtrjZfpmXPCxnkoYzwuL/Pj3OkjBlxj+FY1RKXUhFilL0qrAYjBiGqIgZObCFWgBeBU9/A0Zik2SWxRMKdYEWEsIiVz2UEIQksp4wdcSxPrrCPdSlp1StUaTUYMQhRFTFQP55+vz/9eDhdIlNkUXDbY6SyFLQzZlISgrTYTfueQmszZxuntkMrLZVrOXAEONfKKBvrWkvUDqxFz6RKq8GIQYgqiIGjffR6vemE0OorT81E4k5iSXC6CkshdfVzVfUNq6urSe+X+jyqyjxC5LmJOETiWhmtVqtwrL94VhGo84AzXyQwYhCiCmLgfAzUsdSS/1TBae54rmYX0nQlVblSLS1V24uYLUXBXtUFbZT3T/1uEXmWQIouqZlCV3b9qqwGIwYhUhNDrL+emv5W1muGqnlxYxscKyim6C12tbQ8AZ66tkGDgGKuRXlXIUifUxVZaO7YpaWlwrGcb4zaNgYxzgVcZom495kKjSGG8XiMw+EQ9/f3cTgc4mQyiRobu+/o6AiHwyEOh0Pc3NwsvL6L1MTAKW6hjqWu+MZJ6XMJhKNJUT5uP5WyDDEBbb9PlIQQONZBal8xhyy4v1VS0BY6PsZy4IzVcm2647SsBk7BWxXV0I0hhvv370//Ph6PcXNzM2ps7L7hcDjzd3dsEVITQ7awe5mfOCbtTauKE5GuRUkrVbmpr1SNOBRg5QptihCuO52Vco8av5sa1/CrsSnX5oz3763MpUSdb7G1CkXXT2GJxKIRxDAej68I4pWVFfbY2H1HR0cz1xuPxwgAOB6PS+89NTFQtSPtcRxfJpVspEJem0RCx3CEWgbXP9xEMsiDVkpqhhj3UMyaHlyLkOM6jV1bgaoMFV0/VTpsDBpBDHt7e7ixsTHzf2tra3h0dMQaG7sPEXF/f3/6/0dHRwgAJHdSSmLQLpmPGcchkLKxnEmXmkRCx3CF4SIVu2Wasr+1Wi1W1XPoPJTiMW6iAPd9U7Vx/7ujulrLNHdqsgc1CO7GJFJYDY0ghuFwGBTaz549Y42N3edjZ2fnytgM7969w7Ozs+n2+vXrZMTAjRlQP86y4Fbsurdlk5NqpscEmzUsBWka67yRQQgadRuxz5YjlBF55MBRNKjp2f55NZQtaqyBm+zBRaOJwdXiKWNj97mYTCa4traWay189dVXwUmjTQxbWz+3TS7ruRMbMygCVYCnWuXK1ZrKSCykbZYhJLioyCOF2I6kMdeqgozyLAgJeVLu032XZZlEoesUgfNdcVrLU69PTUmlkk3KOEMjiGFvby/o/w9p80VjY/e52N7eLowtVGUxULV76kdJ9bNy2nVT75Gj2XH81DGaaazASlnslieEpZu0sE3DeuAeF7M6mzueusAUReGgnpc6XzjuH8o5OQFwLhpBDHmB4ZDWXjQ2dl+G4XA4JYXJZFJbjMFNnSwLllG1e2qKKlVTiknt4wp6jgUUQwrUpSS1SaGuYrdY4ZF3v7FxnJRJB2XzhSNMXeulqHI5Ra0PtYMBlZS4aAQxIF5NJXXdPkdHRzNafNHY2H37+/tT62EymeDe3h7pvlMQQyacOUtsFmkgMamsZb5VahyC426SuKa4mSzUiRRa3CZ1bQP1eq6g0Ton9zekKmjj1rpwUj2p90EV5BwrW7vnWarspMYQw3g8xp2dHdzf38ednZ0ZbX1zc3OmzqBobMy+LD3V3fLSZX2kJIYy4UzNYKB+tO44ajYGtb6hzHTn3CdXo4zRWvOax3EnH9VNpO0KoMYnuNcNkQM1+Mm9NmdsbDYRZ05QXaAamYEc6yJFrKExxDCvSEEMmRlJ1VKKcp61P0SOdsSZgBx3AFfAcwV7KLe+7J58lBGCVmM7rfvhEl6MJRUiK854jsXJ+YZSkAhVUdNQ6KjuZA6MGIRIQQyUD8KNBRR9XDFLgRaZrq6JW5Q1wkll5VSnciYqVxDlHcPRqssEcOoWGGUosySo95fnxuIGizUrl2O/uTLLnGoNUOsaYsZpEAgHRgxCaBMD9SPM+gfdvHmz8HxUbYI6+ahBsRQVpKmD0yFLQaO2oW4yCKEsPkG951DVdxn891j2bXJSWDmxiRQpqdT5xk0aoRCIZsq0EYMQ2sRA/QAp46huH6obhzPpYno8cX4zV9OMCU7HFso1mRB8FBFEypoFjptIsqxmWXBZc76lGEdVxKhxSSqMGITQJIaYAFaRIKdqRNRU1tiK6DxIKlfLUCcpzGP1s7SaO8Zt57vdOM0Xi8DpOeSeUyPhQnucO+eKXLzUTEYqjBiE0CQG6odPWTLQ1Ya03E2UcZx2FtRxXO2SUwkdSwopCt6omURlm8RSkZBdTHyG86449xOzFC0nYK0xjuIm4iSPUGufKDBiEEKTGLKPmerOKRpHXfgjtlAtD66VkmKilQkEzgI9sT19Qhk5McJYiwiKtthMlVAQnXIuruXAcRNJ3E9FoNbPaBMD12rQ6oVGgRGDEFVbDNQFxql9WajuIeo4d1EdbdO8bKJxm/r5Aoxigsd0D6Wco4qNe58hIU/RRrnBZck7LgL1t8e4PjXcRNQWGVSrgZLmToURgxBaxKDdOIvyoVOvGTMhtHo8xQr6ssnBzZFHvCrQOSY7p/I5dasNrhUR87slJM3JoOO4IKnnLAJXkdLqkEq5P81CNyMGIbSIQVPgU4PY1MBWzOTSsAI47gCOJumPpWhYvnDkCFft4jKt63J+g+8+oxzrX59Tn8JxARYh5pwa1gVX0St7PpT4nmZTPSMGIbSIgfvii7Q26qTJrlm2GAv3fByNr2iyxsYruC6kMsSSQpFgrjKVVatmIYYc3PFlVqT/vKjnpVoNnAwlyn1yvvM8UOe0puJIgRGDEFrEQHmhVO2CEsSmauMxbqQy85n68VJ/L8dl4BdklWnrMaTQ5GK3PLKKJTtu/ECrBoFjNWQJCRxioGr52j3K8kC1BihznwIjBiE0iMFNsdQILlE+NGqr4JiPu2iyUNMIqwgylgnpGA05jxSq7o1UhlBmFZW4OPUH3PEpCh7dTDVtN5FGnzJqFwPKvVGfXRmMGITQIAZq1SIlHY36MWpqM6nHpQgwlpnk/nkpgj0kbJtGCC7ygtUx8QNuexLqWA0SSVGxH2OF5IFaiEqxBqjxxTIYMQihQQya9QuaH6x7zSJtRjtriTqROcV0vguJ45qimOUaLbpdcFNaJQQUuhblN/vHcAg8hdWg0dGUu84INW7CKQql/IYiUMcVwYhBCA1iyIRKUYMwqr+dSgyUD9Y1wYusmZSTmOoiKLo2JzVVo7VDjLamXdvAJaWQ9cCNH3AJtwix74vy+6jun6LzUV2iVALRtAY04gxGDEJoEANFmGvGFxBpWQ6u4NXIWuJOYI6wpxINJ6uj7LxuG4Jsoyxgn4FT2xC7cS0JKTlwnm/RuVNYDZpKE3X9aO1sIso46rmKYMQghJQYtra2sNVqYavVUtE8KOOorh/KB+YKR+pE17AW3HEcsuT08+f6zalCWLsQjWJtUM8VsgI0M49SWw1F3z01CE29P8pco7bboGr5HMtC0obbiEEIKTFQNQpK5oKmwEekffhuC4yi36CpEXHGUXPjQ8K6CDEZS6H7cbcyTZaCsv5LqdJSOc8uRuCXnZPbkK7ofFRFglt7RL1mEajjpG24jRiEkBIDNQuCoiloflwxJCMlI+0sE056qi/YOAKL4j4qshI0etuEEAqIU95VBskz4QjLqtyU1HHub6HG1qrKJqLKCyOGmiElBsqHOhqNpmZw0YumfDTaVoWmwI8hGaqw5/izObnuZc8HMb9moKpUVj8OQvmdiPw22rFuoiKLlPpNUF02VAudEo+I+a6LQBlHvX9pQz0jBiGqsBgywVLWuoLy0aQS+BqCnBpHSalFcsdyi7vKhE1K+FlcZVosIp8IY8lYOo5qRboEovHNVm0NaNcp5cGIQYgqYgxc7aXog9dclIf68Wn2ltEWKBxrwRfyZRp3bH1ASsSssyBxExWB+izdcVK3U2zWm+Sa1HGaGUzUOZcHIwYhJMRAzUiimIXUD5RCMnUU3KR0N1HHcQQKlVip95GHomByrOURQw6xDe401hCnni/mnReh6rgedX1nitCXtuA2YhBCQgxU1wnlJWuW8lNL9FNlZUhN5NjgtAaBIMpXeMsjAspGRUxaKnWs9joITdbyqYVuHGEOUNwGX3NJ0DwYMQghIQZq7rKWhkCt/tQ0aTVzx2MmPtUVxrkut3KaYinkBahjN4ow4C5tyumPFPMOqurtRfX5U87lWtfS2B5VmGu6ZvNgxCCEhBiyD5SzfkAeuBpJVRlJFAulDqsi9nycc1IFNEXQ++81FEgObWXgtgCJJdM8UNua1EEgmvE46rkoXgTqb5TEGYwYhJAQg6ZJWPWHrpn2Wsekj3VPcHo3UWtTQhuntQZiMblwg+RVtqqgxrO4WUcamW3Uhnqcc5VZ4ZRx1LkniTMYMQghIQbNIJJWFhHV3aQppFNoeZxrUl0AHAIpE+x5Gr+0tiHvvGXuSv84jfoQ6rNL9S1VFavinktD+eEQiMUYaoCEGDiCrkxgaAWoXS1Jmo1B1Qa5Foq2YKCmQGoFp/MqkjURQzqxJCgdpynMqdesw01EuS+qxUPJVJR0WTViECJ18Jk7GaSmJTVlTjO7iSs8qoqPUK0PThO5KhfzCZFDkSDh1Glovo86+glp3j9Vyag6u5BKMiEYMQiR2mLQzKXmrMGgsdCPZnZTHQI/RnhwBGBKUsgQqlkoAnVszLgmKQeaqa3U3kqUuUV9T5Q1XCRtMYwYhIglBs2UOc2AG7cATpo9oTlBm1AzwSGQqqqgQ3GHPMRaSXnwV87LQ6r3WwRN5UZL6FOtf4rCaMHnGhFLDNSPl/IBaBIDZQy1qKdqLVBT4McQFvWZlQmQvHPnbZQMJv8Y7eAy9dqUMZqWRRGqtqA144Xc5YC5AWgjBiFiiUEzYMXtpVTVxFuUc1HdeFq1EGVrKuRtZYuyUO/BD45Tzid1dWpaA6kUl6raVFDORVmfxb9/DowYhIglBs21YDWFpmZMQ6tYJ1XaYFUk47tTKBpq7FZ0bqrAp/6umFiN9JqUMZq9vmLWZshDHdlLsUVuRgxCxBIDNZVMW4uq6nrUcVzy0CRIqZvEdw9RzsURtGXHcMZy78Ud01R3YRE0z6UVP3DHSK0PamA5Ns7AlWttMKjg97///cyfIezu7kKn0wEAgF6vlzsuG5P9GcLbt29n/pSg1WrN/BnC7u4u6VyIOPNnGb755hvSOApOTk5Ex7vPcnV1lXRM0bjJZHLl//BnZSw4Pm9f0Xsp2peHx48fs4/Ju6b0XJqgzBsAgMvLy5k/Q8jea9H7HQwG079/+eWXuePOz89n/gzhf//3f2f+zMPHH38882cqtJA6g5k4Pj6Gp0+fwtraGhwfH8P29jasrKywx6bYV4Tz83O4e/cunJ2dwZ07d8i/98aNG3BxcQGdTgc+fPgQHPPpp5/Cy5cvAQCg3+/D3//+9+C4drsNiAitViv34+12uzCZTGB1dbVQIFLuy53oeZ/DvXv3ptdZWlqCf/7zn9Hnooxp6rnW19fh8PCQdS7K/ZUdv7y8DG/evCkdm3eNfr8Pr169Kh1HOdfu7i78+7//u8q53DGDwQAODg5UziX9FijzBuBnErq8vIR2uw0XFxfBMZS5Sp3PlOuFwJZrLHuEgfv370//Ph6PcXNzM2psin1FSBl81uzPTvVJasUFsuAYlJjNlHNRxmieK8ZFRBmjMa4IMdeaN9eOZoyIeu9VVz9r3jul3iGERsQYxuPxjGBGRFxZWWGPTbGvDCnTVauedIh6k0Dz3qtOx3XHSH9jzLliKlX9c2iTlWRMHeeqeplb6rkosT6tMYj07CUfjYgxPH/+HLrd7sz/dbtdePHiBWtsin2pQPFJUsZQx1H9qZmfO+Tv5ozRBDLjEJqQxiFizlXkyy4C9flQ4yHzjMxtUuQ+ocTKtEGJ9WmNAQD46aefZv5MhSTEcHp6Gvz/0EQqGptin4/379/D+fn5zBYDSoCJMoY6jhJAqwPtdnvmT0M+Wq3WdJNAk+zmGVSFo2olTvN6n3zyycyfqVDp7M0T2Nyxmvu+/vpruHv37nSLfeBZQKcosEMZQx2XBdLLAupVf7h1aG0GAwcUCzmTFWUyizJOU2mkZi9JkYQYVlZWrmgxJycnQSFWNDbFPh9ffPEFnJ2dTbfXr18zfukv0HTZNPFc1OtRTH6DoemgWh8UC7lqpVEDSYhhY2Mj+P9u3i9lbIp9Pm7dugV37tyZ2WKQ1SUU1SdUbZ4CmGunycD/X7cgjbWUxZmuC6hxN8rcoc4biiJUtaKngSTSYm1tbebfx8fHMBgMphr7ixcv4Pj4uHRsin2p8OOPP878GYJmjOHs7GzmzzxQXDtUklkE3L59W+1cN2/eVB3ng+qOa1qcqS5QtXxN4ao1vzSVRhWwcp4YGI/HuLOzg/v7+7izs4OTyWS6b3NzE4fDIWlsin1FiE1XzRaxKeq/Qu2OWHWXSMqYVGtCV3Hvmj2AslRbzrlippnfH4h6rXlrqKi5QpvmvWuuCEdJz9ZcQzqERtQxzDNiiYHa60RrQlEnQdUTqonCp+5zxZCDf6z0/Wmuk0Edxx1TlcJR9ZzQXOktdrGeRtQxXEdk7QbctgMhaJmV1OwfStaEpnnKPdf6+rr4ming18FwxyGz51HZuLyUVOo53TYeUlCfDRePHj0SHa9Z20PBgwcPpn8PxS8zaMUhAAD+8Y9/zPyZCkYMSqAKRK3UNWq6aiagQoIqg6bPlXKura2t6d81BVa/3xcdv7S0NP079VkUjQt9C0V1C3n7it6dC2qCgfv8Y+D+Zum5NKGZEUeZz0+ePAGAn4kor8cTwC8xpqJYE1V+fPTRRzN/poIRgxKogWVKd0RKShpVmFO1KAq0LAupZujC1dTKrLUy5DUG9OFnnuUFtE9OTmbIxoVb3FZEFkXP2r9unkD0O+PmPf8YS0DzXebB1cw1z1Wk5VPmFzV1lKKcUeUHpYuzCliOqmuA1Cu4aTW1owaDKderumFYzLk0G/dRfcvUcWW/NXYFtzJQx8eMk/rfUwX8m7RMKPVcmnPQgs81IfWaz5QmWJofCfcD15x40nO5AkG6oA9VUFFXRQstwlMG/9x5G2V1Lv8YauC2jiSEqoLKVTfaowpprYWBqMpgCEYMQsQSA/WlUbooUlNRtbQazYyVupftpAoh6jjOus/c5RZjEVouNA9UQqQ+6zqW/6TOB8o4Teu46vviKCE+jBiEiCUGRJoGoUkMmhO0iT3qqeNihJXGuNDY1OTAIYXQ/WmOk1oCdSsRlHNJrV6qwqiZ0hqCEYMQEmLIPoKij4my0IY7+aWTL1VhWtG5qnZfUcdRLSNfyFCKEasgB7+4jvoeuM9Z+j784rwqrqkZh6CuF6Kp5VPOFRtfQDRiEENCDBRrgPLRuYJJI2CVIuBdh4anTSAcN1ERQlp82TEc5AWvi9576Jg8aLub3BXzpN8cdZymAKaeS1PL57wnsxhqgIQYKC4gqpuI8tFRNQjKR5fKfSXNJsp+I+eaGtlEvmAtey55gWXuEow+8kiniNQQ44PT1CA/9RlrWrxF4yjKj3uuojmjGeOjzFFN11UejBiEkBCDZo+jqlPcsl5PZR8npzcMR9DkgeqWSOEm8oU9tW9OaOMs71mW3lpGCv59cCyLImi+r5SJBdJzUeYo9Xdquohi22EgGjGIISEG6oRotVrYarVU/fRFoJBMjF84DyndRNpZRxxhSBHKoWNCm2tJ+M8rbytTJvLORb3XovNTCcR1I2m/e+m9UZ8JZe5RFSnKNakCn9KoMw9GDEKkthgQ9fKtqYHlVNlEVWWluJo71WfNuW7RcwkJWgo5xBa15W2UvPXQNYuO88dT3X5VJhVwFSSpJUAlGU13E/VcRgw1InW6KiLtY8m0iE6no1r1KyUQd+JQhbSUQGLdSZxsoiKEXEScAqNYMuDEJ2Kyo2KJlHrOPMS6/fKQSvHRIDaKTOAQ1tLSUqE8yIMRgxASYtAMIvX7/emYfr8vOhc16KY5+amZVTETUSubiCNEQ4KXYjmEkBdQjg1Ux5CC7/LRqJyOqSfRLjQsgibJUDIQqRa9VmV0EYwYhJAQA6LexzcajaYfTJHvkfohV52mRx3HXaiFq2Vy8vzLrIAqaxaoCJFM2T1l1ihlfGxwWmolUsdRrQrtzB8uARbdl1bMsQhGDEJIiUEzC4HyYWmeizp5NIuJUo/jjo0hB2lKagzyYhhlVowkOK1BIFRBzk1TrfJbpM4TzS4HkuI2RCMGMaTEoJm3TCEZ6rk06xSakHVUZEX5QoUTgC0THIj5aalVWQ++G4hKaiFSKDrGtyyKEPOutb8J6v3lgasYlaUgU66pGcQughGDEFJi0FziU9Ma0Eyvo46jan2x4zgpqUUBO/+8FAugKOuoSEOUII+QKGmsiFefSdE36gf8q6yF4IzTFKyaAp/qCta8ZhGMGISQEoNmnxVNyyKm8Eh6TUR9zY9aCc2tXPaFLlW4FxW1lf1mCspqHCjFTqPR6EqfJW7lNHVs0XOjWpoxWWjUFFSNTgIUMnKtuqLkEUrvNPf+YxMejBiEkBIDxa+ImCbOkEKYU8ZQ/KxlZEk9H1VoIPLSVxH5lc5518nbWq1Waaoh9VxUK8F/XpTfxbHMfGFPTa0uehcx1q124WMRKMTgEnHRM6HIC+p9FcGIQQgpMYxGI1xeXlbLMuBaFhoEwtXWNLS/WAFTRsC+UCwTzCH/PVXr1y5qC22cQHfI2ij73vxjOM+3yHrh1EJotqRApCth3H5LGm01snFFRWvS+AKiEYMYUmJA1F1JStOHqtmz3h+nrdkV/V5OSqo/lqJpSwvaEPVJgutCCF2/TMhzM5Y4RYLU3xLTeoOaXFAkfDXb0yPy3E1llqQ0IwnRiEEMDWLgVhAXfYiue0Pj46HcmzvpiiZxTOohtd142bWpPXlC56VoXiHLIda/i3g1w6dsi2mUliGm3iLkcuIQrsZ3gpi2qE3aQQBRd25Trkn1QJTBiEEIDWKgfmTcrqdFGg83bbXoo+WY6ZpxC8T4FEluURcluBwSsJQ4QV2IrW1AvBpf4QSnOe9ew1rQbtFBHafdQYCy/js1ZlkGIwYhNIhBs7mdK6Q5/t48uJqwxsdNjVtQTX//2hxBwi1Oo1gOMYvk1IG87KiY5ntl1grHhZS6clqjJUWMhq8xrynxBWqWYxmMGITQIAZE3ThDplkAFJvD1IBX9rFppMpqpyByzonIE1KIV11EFJdNUcqoxL2kgTxCoGqYIRdXETiZXhx3U2wyg4Z7iPutaXRPpsYXJGswuDBiEEKLGDR9kW7qW1FOdMo0vyJQJz9Hk40dS9HkfWFKnXRFcYJ2u12pi6mofoJKVtwgOzdWwyEc6j1Qv/EU7iZu7y/Nuh1J4BnRiEEMLWLQfPFU7T2mMIhq0WgHobmaKWcsxX3iF8pxXENlRW2prIiy60p+Q1l7d0SeoOdkjnHeNTVLjxJL86+t7W4qAiW+QL0mBUYMQmgRA/WlUtddoGoO1GCVZnorYlwvJk2rgdspNZSFwxHqnHTUWKIoI4IYQgidNybWohUn8sdyLJYiaLeaoI7TjC9Qr0mBEYMQWsSASBPmruZa5CaKaRtM9b9qaEpUE5/jo5YII4pACrWKiBHk3FRUrY3rdw7dZwwplD2fVJYh9R7qylpylQ2N+IJGYVsGIwYhNImBEjiiCnxEfkodtaBHoy1HquAyR2iHtHiKCc7tOso5j/YWKyRi15KI6T5LfV/+N6NtLXC+Fw3liJp5R/0dWvEFRCMGMTSJgWrOaruJNIvdEOOC1VruA6lgooxHzBfqkniBBlFI89fzXF6x2Vgc4V327N3aibJWH1Rh796DRkM/RH7L7rL5XnV8AdGIQQxNYqAK8jpWl/LHUYUzNUjOFfhl4AjrkDCkCHhJgVgTIVlxToOQtZrv+ecuArV5nRucphJN0TjXJVz0u+uILyAaMYihSQyccnbKh6Bt+nLcSVTrIkVBEyKPdEL3wRHwkmKxJiDv/qm/P8a1xqlZQOQRPdUKoLZeQdRduAqRv1Z0lfEFRCMGMTSJAVHfTeRqOpQsJo7mlqIGgbNADtcS4AorjnBvclFbHjRqG0K/m/teUgantRMqtIiBMs6NqWi5l6kwYhBCmxi03URugIvaO0kjZY8jlN2x3I6eZeAKLWlgOfVCPFLkpd1q/dYySMlaKxaFGLfGCfU71nA3uZl7Zcpaq9USN85z0QhiGI/HOBwOcX9/H4fDIU4mk6ixsfuOjo5wOBzicDjEzc3Nwuv70CYGRF03kSsIioJXiLqLASHyyIZaYORfPyZ+QIF/DNdEz1tnuQ6SoAS1OVZNbOCdG2xGlL1r6liNZpP+vRaBOs8oq7Uh0t1cHDSCGO7fvz/9+3g8xs3NzaixsfuGw+HM392xZUhBDNrZRNRsJ+o4zmSh9m3iWALc+AEi33LQCixTi8403U2c7CYuOcXWNiDygs2h38EZqxXIjrm+RsorIm0+urU1mmuH104M4/H4iiBeWVlhj43dd3R0NHO98XiMAIDj8Zh0/3VZDIhxjes0xvn3SC1kK9N8OEKD40sOjadoq4iyTJ2y61O3vHchOSeXECTpuTHPXlLYqNWoDzFtZl8RqAH0bH5p996qnRj29vZwY2Nj5v/W1tbw6OiINTZ2HyLi/v7+9P+Pjo4QAMjupBTEwNEqUn64GhlKvk9ba4IjzqYaUtY94AqFvPviHk89X8pNkq0Sul9KryTEuOA01yLkjOW4LFO4kbi1SgD5Sg81lTUGtRPDcDgMCu1nz56xxsbu87Gzs3NlrIt3797h2dnZdHv9+rU6MSDqF52lSEml9m3iaPcSlwB3snMFfMh6kLY3RkxHFNIYhpQQuau8ZeBci1NBj0j3x3PmQYxFrrFONDWVNQaNJQZXi6eMjd3nYjKZ4NraWqG18NVXXwUnizYxxBTKlH0cMZOi6MN0r13m36QG+/yxZZM9JOhTuZXyrscRlhxQYgWpAth5/ZyoRBjzXkLHlYHacwsxPu2UqpyUEQg1JZz6+7UW5QkhGTHs7e3hzs5O7pZp63t7e0H/f0ibLxobu8/F9vZ2aWyhKosBkV9aT61pKJsU/X6fNIE4WUeI9EA0oqyYrSz7KnQMR8i6JnwVBFEVioiIQ0AxPahGoxF7uVCOshFriZbdQ8p23WXX1lqUJ4TaLYa8wHBIay8aG7svw3A4nJLCZDKpNcaQgfoxUYvYqB+xa56XBYw5k8iNCXAsDMq5YzKVJG6lvOOr0OZTIM9tRI0l5J2Hkluv4RLkuCeL3jGnqIyjlFGtAOo4RP2iNhe1EwPi1VRS1+1zdHQ0o8UXjY3dt7+/P7UeJpMJ7u3tke89JTEg8hfmoeZkl31MHBOdOum4wV9pW4vYjBmuMKxrIR4JRqPRjAWXwkqgCDfEWYWB8rw4CQ2IvICz+91rBIgRecqTdswwFo0ghvF4jDs7O7i/v487Ozsz2vrm5uZMnUHR2Jh9WXqqu+Wly4aQmhioH0DMEoZUzalsgnOqWTmaHvfcofNTJ02M+4NyDuk5tZEibpF3Tsp5uO8XcbZ4kKPVl1m//rk1XEOIvFiAdpFpLBpBDPOM1MTg+vs5aaFFiBH4HG297KPm+IYR5ZYDNVUzFHCN0fY5BWaprYnU9xKq8I4l4xRE4lojnKSHsrHUOcRxN6WIQ8TCiEGI1MTgBjrLgkwxH1bZxHLNZU4wkGOyUz5ujpaI2JyaBY5gjtXYY69D+abyILGwQsdSnq9UQeDEIapu6805J3WcBEYMQqQmBkRekIk6NqabatmH6Fo3ZcKbsxpXaDxFoHHXdXaRRxCxrqCiTKaqN4mWmfdcqO0YYgP+qZMRUilA2m1mOPEKCYwYhKiCGDgfg3axDSLddOUK+yoyj/xrLC0tkQPLqWsWqqyAlt5z0b1KrLGY7DFunElT0HMUpRjLnKrQpchEcmHEIEQVxIDIMx+pY6mBNv+cVAsjxuVTJrT9OECMC4IrKLXdSzHXomzcbCrp/XCsJ62kAMoz52QhcYopEXmWhTaBpM5EcmHEIERVxBAbCKbWK3ACxtRFhKgfsFvYFNPzKMZykAq21ARRN7SK3ULnomQHhY7jWhfctT1SWRZaBMIhMCmMGISoihgQ08QaUripuHnm/nhKplKMJhmqruUK9rIg77yTxGg0mtGKJYSAGCZkilWjUZNSdh2O9h/rQkrRZ6mKb8yIQYgqiYHzcXC0G87kp47luog4ml7eNaiCK6bS1keZy4cTy2gCNGIIZeejrjAWk8YqyViinD/WhUSdI02JLWQwYhCiSmJApJuT1PoHRN6i6CnrFbgprP41JMelIgiOQKwaZdZPbMwiNh01ZNFR+l5Jkxg459d0IWn3WdKEEYMQVRMDJ37gLg1YNsE5cYFU9QpcF1SGWMshdGyshpx3Li0NXAOcWgcttxH1XO5KZC4paMebuCQSG5zmuJC0+ixpwohBiKqJAZH+8fldUosmGScQ7Z6XQlCSiZsyeyXvWKkAz4tlaAvimN+U4h62trauCHUJsVOP5b5z7reIGL/mNKduQqvPkiaMGISogxg4QWBOSwDOeV0Lg+NSitHSYgXM8vKyqDMogNwN5D+rpm1SYSOt9fCPpy5RGWMlcl2VsYkZANXXN2jDiEGIOogBkW5e+uSgGYhONXFC4yXtFjTSUrU0+iqL2lIQQQaN5+Q/CyqRSzOWuFlvnCxAyv2kIBBtGDEIURcxxPr5NesVEHlEwv3QfQHQbrejMlRiBGLqqmcXqchC+16LrB+OdSYhb42MpbL7lLg/66hvSAEjBiHqIgZEupnpTmjuwilctw/HtxpbtUwVBtw+/z6KBOG81ytwoFm7ISFtbkEaYpx1wXE5cSxhThyvrthCBiMGIeokBu7Hw/FXcjQsThuMmMkdEtCxaakxMYMyjb6JqagaKPrdWs8xZXKBtEKe4nJyU07L7omT+VdXbCGDEYMQdRIDIs/cjLUEKBMkNt01O3+qgGPoeqkIoqn1ChykqOyWFhTGvnepdapZlMlRnuqMLWQwYhCibmJwPyLKx8/58FPWIMQWQUkyliQplf65ioSn5Nx1IVWrj9j3jKhnKaYiEmrKqT+WkwBSF4wYhKibGBB5HxLHEuCsCofIzzwajUYz5EOZYKHrcLSqvLiBpGaBko7KTZ1NCU6hm4TcNOMJnPcckwHXarWw0+mQY3Cc8amC0ylhxCBEE4gh+/BWV1ex0+moViNLMoliXD0Ut5V/TMwkkqa1Us9Zt0XhZ5lVQQYhy4zTOyo2Gy10LDd43O/3Vccjxi0DWldsIYMRgxBNIIYMnCwljkYlMbGpQiamT5LEcggdnwkhasyDe+68TdLN1L+Ov2pdVSRVVO1dRTwhREjcWBfFqnPfVdn47J6y+yp7xpx1JFLDiEGIJhFDbHCZY95SiCSmAjmmXYH/OwB+Duxx3TZFQryphW1U7T/vGE1rJe+3SSvPU7fU4L5nzpzxv2eOJULtLpwSRgxCNIkYEHnxBk7wLJsUVI3an+QUk1tTMHCFuvv7tLXpvHvONMkYIZ+3hSyGlEV5WtfTyjijkhHXl89VjlwLmGuJNCEWZcQgRNOIIdYSoGgpfvM8iv+WE6Tz7ykTmpTjNIPKIQ1Yy8VERVlQO5X2X4Yiy4e7BoU0U0yDTKi+fM7z5sTMYuZIFTBiEKJpxIDIS41zNeQyIRzKIuLeT0xKKldYcH3NIZR1SG3KBK4C2fsIERU14SHvnLHPNca6DH2/KRIq3PNzLAWKVV0VjBiEaCIxcCuRM22FqkFxJ4okoBgrjCXkEjpPyMXUbrdxeXm5UkuiSpQF0GPJMfRuOC4g3/VGtSj94ygWr38M5f5iLIsmpTMjGjGI0URiQJytRKYIrtj2GrFWQGxLC25fnpD/XrNYS+vcTYD7+0Kxg+ybktR8+Bo7x/0kqYvgzgdEjCKSbCy37UzTYMQgRFOJwdeQuPnW3JWzYgrTqIiNO2QICXSJll9kRcwbUVAL9LQL3WJIXsN6LLOgQ8dQLRLO/TWlkC0PRgxCNJUYEH/R0DKC0O6P5I6nLrDCLcYLXUtDsGhNyrwAqrtx1sNIiaJMIn/Lxkifj5SUQ8+Xk84ZQyjS9GzKNepuklcGIwYhmkwMGTgfOTfNLiaYhxhXBIcY153VRcidQf2tMfdXJHS1hXCGUApn2T1lBKZBXEUuNymZxy7mQ712zPfFTTWN6Q5QNYwYhJgHYkhZmBMStDETUOIainEL5QkvbsplEfzKV+rmE4cv2POIJfb8msJJyzKLrU8I3QMn5Zn7XLjp4dxgdl0wYhBiHogBkWe6atQfUCBxD2lkHRW5gVJkieS5cmLbWFA3l1hSFevlXZtLOqGYB+cc3C6/eb8hxTfPDWbXCSMGIeaFGFwhSBV6sZlHnGKw2PRDxPi89KJ719B2Y+AKGanFUIV7YmtrC9vtdjAAH1PXgKhD9px1QfKuS1UIYovemuo+cmHEIMS8EAPiVY1Fu0cSIr86OoPEdaBVs1BkQVAD+NcBKUhU0lEV8aqCQc0+irEUYhIouPOobhgxCDFPxOALPk4xW6vVIk1WiRYf8g1z/MqhmoVYl1CRe0Q7WNx0lKW0coW4i9B7k8QjMhdoTEwhRc8k/5h5+WaMGISYJ2LIwP1QfSuAG5TjpOT55EVdnyF0XQ33ip/yGxKKEsHYVPjvL/TbJYH6vJYjHMGpqYSkzKZrempqCEYMQswjMSDyTFtfY6R+4Jk2GKNhx6zP4F5XaxlP/7zu7wlt1N77TQSlsltihRVdQ6PXUqzbMlX9TWzNThNgxCDEvBJDzEcbaxLHCADfzI8Vtr5mmPU30liIJy/46gpQqcWSEu6zKfodvV5PRbBppbL650md6CB1H1GPaRIaQQzj8RiHwyHu7+/jcDjEyWQSNTZ2n4udnZ3C6/uYV2LIwOnEijgr5LmaE1cYhI7TynbR1OxdC4VSs+BaHCkJYzQaYb/fx16vFySrok3rvvJcRjFuKGmSQWwsQ+I+mlfrsRHEcP/+/enfx+Mxbm5uRo2N3Zfh6OgIAeBaEQOnEyvi1cnJdStxTfjQNbWsh1QTt6hNddHma+0uybh/d4mF8nfqtTW7xGbPwH/nWqmskn5ZnDgEt55nnt1HLmonhvF4PCO0ERFXVlbYY2P3udjf38e1tbVrRQyIs7nf1EBqrFuJ24/JvV5svUPoPCHBmXKhlLLOpSk3l3BSFrtlFkpeHCHmeho9smKqjf3rUtdK4F6nqaidGPb29nBjY2Pm/9bW1vDo6Ig1NnZfhv39/en/Xzdi8DuxUq2AWA3ODSxzM3q0rIe8c8XcUyz8oH4Ki0GzxUcR8p5lr9fDfr8fdQ/Sdy053j0m1XKhTQZXrrVBGaenp8H/Pzk5YY2N3Zedd2VlpeROf8b79+/h/Px8Zpt3PHz4EP77v/8blpeXAQDg8vISHjx4UHrcYDCY/v3i4gKePHlCut5f//pX6HQ602s9fvyYdD0AgIODA9ja2poeDwBweHgI/X4fbty4QT5Pdq7RaDT93Rmye+p2u9BqtWB9fZ18Tg4ePnwIb968AfxZ4YKLi4vp3xERLi8vg38/OTkh//2f//wnPHz4MMn9r6+vQ6vVglarBYeHhzP7Op0ObG1twcuXL+Hvf/876x4ePHgAN27cmDnnYDAARISDg4Oo47e2tkjH7+7uwr1796bf12AwgDdv3hTef/YcHj9+DAA//3bKfS4UVGkJEYfDYVCbzzR46tjYfYg/WyLu/xdZDF999VVQM5pni8FFTIAuRlPSWKM5Rc1CXlzguhW15YGS0iqxtlK0V49NY41xH81zXMFFMlfS3t4e7uzs5G7Pnj2bjgv5/7P9/jnzxsbue/bs2QwRlBHDu3fv8OzsbLq9fv16oYgh1icbOzmkla/Z8ZortZXVK1wnkvADsHlkIHkWeV1oYwSs646TfIOcFFiNZ9A01B5jyAsMh4Rz0djYfRlxZBsA4M7OTjDGEcIixBhC4GZxhDQ9jq9emnWSafsawsUFlSS0s3rqRF4XWE3LAPGXWhANosneU3Y+zmI+sVYyd630eULtxIB4NZXUdfscHR3heDwmjY3d5wIAZq5XhkUlBsRfJgyn/0yo3xEVWoFlzQC1C0rlcyaU5kWD9Ft+5P02TspmGfLcUTHnDwXwOcHu2K6nLqEtivvIRSOIYTwe487ODu7v718pMNvc3MThcEgaG7sPEXEymeBwOEQAwO3t7WtvMSDGd6x0J2vMZA+RS8w5fE1Qu6iNQhKuRdGEDq2uICyrs0iRi69ZiS4pgIx1mfpExLFM5gmNIIZ5xiITQ4bY1g6S2EFo0muu1KYtoN0KX0phm+uCaLVawVRTyv25tQM+UYVIKW9zLQZNMihqQqiZZkx1W0qSHvy0bgB6kea8wYhBiOtADG7fIq5bSVqU5muYrVaLPRnzgpsx98O5piuoKcK5aHOFWXZOaaFcapdXHilLiEfqJozpFJxBUn8zbzBiEOI6EANivFsJcXYyc33AiD8Tk+vTXVpaUhcuVbYwcHsrFVkM3I1iMaR0YxWl+0qvr7Fug9v4MCYxIvsGua3g5xFGDEJcF2LIkE38LEWU69ONyRpBvEoOUu0zJGjqIIk8hHzZIYshs4Tq1l5Tuew0WqjH9vdCvNrlN7aKe95gxCDEdSOGzKftTtbYbA7uBM+uffPmTTXhQ0nNnIfsoqrhJxikeG6hYrWqExkk64LMM4wYhLhuxJDBn3CSJThjUhRDzdqkWr7fGdO3Iq6bcPBRFYmGrA9u5pJWn6Xr5D5yYcQgxHUlBsT45RER09YspBRQmbBY1CU9ffgCMrRpuLLyEgS4ZB9SPKSV+NfFfeTCiEGI60wMiLKV1qSTuOxcVdUrZC6VeSpsC8FNuQ1ZTa71pBWD0ax+RpS5KhFlKdaLBCMGIa47MSDGFwtlkLbTKDuX5uR2M1vyiCIjOG0hqgWf7Ch1F6kW8tGyPvwgNTe5IWZRnkWGEYMQRgy/QLp6lUaw0b2PlJquex3fYigTsFWQhi/8V1dXSYSW6ln59+U/E8k63KFYE+dc/ndH7aq6yDBiEMKI4Sok691Ke9+4KEqhlAiisvv3ew9RC9uy9NNMcw6RTohY/PRVyrVC10i1qE/2HqRppz5CJMN5r34jvJTfxbzBiEEII4arkPTEd88hqXtwUZRNU5XLwA3ixpBG7BayGFqtViUCsIiYtddsiPnGFr0RngRGDEIYMYQRmrwx0J68eQVTdcYCXOLSshjq0HzLAvWtVkuUyaWVrKCpdCwqjBiEMGIohkbcIbRIjEbxVJG2XtVayYuAolYYWu9Kww3lKysSN+Wiw4hBCCMGGjT63GgHLRGLi9q0BNsiosg9p1kMqFX9LK2PuG4wYhDCiIEGLTdA6jbaRR1Br3P1M4VANQv+NKqfEXXiXdcRRgxCGDHwoFWzEJrwmhPfLfbK2zL3SRNrFaSgEEGK365Z9OgXX1rGER1GDEIYMcRBw0VQtAiMpmZIXa0NAGoN/sbCTSdttVqFhJiKCPKerdZiPotE2lXAiEEII4Z4aNYsIIatkRSavF/YVlQ74GYM1eWOyoRvr9djVzynsoaKXIKS64Usjnkh6CbBiEEIIwY5tNMHUzbWC8Ht9sopMPNTTUNC2yWfTJvP2o77i/yE0lc5dRLuNTTbX7jII28pYVb9zhcdRgxCGDHoIUXNQshfXYXWHmpJQXVHpdqyGgiffKoQnqkEt2ZMwvALjBiEMGLQQ6qahVRuCwnKiEPTYhgMBpXn62fxn9CiSinfqVkIOjBiEMKIQR+ptMCyQOciZhdVjSqK3cxCSA8jBiGMGNIhtVZYVv1s2mc5MiLIrBm/e2tmMWgVIto7qgZGDEIYMaRHngDXEgpFOfvXvbDNRxkRZG4vrWI3sxDqgRGDEEYM1aEqrbEoJtFut68VUWTtJG7evInLy8u5RKCdzWQWQr0wYhDCiKF6VCU0qIVtddYoaMMngtDvTZnWahZCM2DEIIQRQ31IlRMfQuZCcS2Goi2UHdQk4eYX6ZUt8pMRRZX1DfNOsvMMIwYhjBjqR13pqH5sglqjkJdWKiG0vHuJLXpLTQT+fZuF0CwYMQhhxNAc5Ll+MtdHVf2L8moUKKThE0jm1skCvX5bC+kqcL7FkPoZ+ZaKWQjNhBGDEEYMzUWoYK7dbifXgvNA1eolG9ViqFojt9Tg+YIRgxBGDM1HFlB1CSLrINpk/z/HYmjS/btN+zIrxI9fVNmOw8AHV661EBHBMMX5+TncvXsXzs7O4M6dO3XfjqEAu7u78OWXXwIAwMnJSXDMYDCAg4ODKm9rYbC+vg6Hh4fBfcvLy/D+/Xv4/PPP4dGjRxXfmYELrlxrV3BPBkMSPHz4EL7//nv4/vvvYTAYAADA6uoqdDqd6ZjDw0O4ceMGdLtdaLVasL6+XtftNh7r6+vQarWg2+3CjRs3Zkih0+lAr9eDVqsFy8vL8M0338CHDx+MFBYURgyGhcDBwQEgIpycnMCHDx+mRAEAcHFxAZPJBAB+JopWqwX9fh9u374NnU4HHjx4UNdt14bd3d3p7+/3+zNEMJlM4OLiYjp2MBjAhw8f4OXLl3B5eQlv3ryBhw8f1nXrhgpgxGBYSGREsbW1BZ1OB1ZXV2f2v3r1Ct6+fQuXl5fw+PHjGU15EYnCtwb+/Oc/T3//q1evZoggs7q2trYAEc0Vdw1hxGBYaDx69Ag+fPgAJycngIhTS6LX68Hy8jK0279MgUxT9omi3+9Du92G27dvw+7ubl0/hYSMAG7fvj3zp28NvHv3bvr7e73eDBFkVpe5ia4vLPjswYLP1w9ZkHV1dRXOz89ntGcfWdD1zp07MJlMpsdk/04Z7PbvM7tmr9eDH3/8EQDyg/AZsmMtaHy9wJVrSYjh+PgYnj59Cmtra3B8fAzb29uwsrLCHhu7DwDg+fPncHx8DGtrawAAsLGxQbp3IwaDL4A//vhjeP36NfzqV7+C//u//4OyKdPtdgEA4Ne//jW8evUKlpeX4e3bt9M/V1dX4fT0FH71q1/B73//e/if//mfXKLhCH0AgKWlJfjpp5+uXNOys6432HItQcos3r9/f/r38XiMm5ubUWNj9z179gy3t7en+9bW1sj3bnUMhiKUrdSW1VOk2PxajeyavV4Pu91ubYV+huaj9gK38Xg8I7QREVdWVthjY/chIq6treFkMpm5DhVGDAYJsiUwu90u9nq9meKvULuKwWBQSDQm9A0a4Mq1G0IL5QqeP38+NaUzdLtdePHiBdy/f5889vDwMGrfysoKnJycwMrKCrx48QLW1tam7iSDITUePnxoqZyGuYd6VtLp6Wnw/0P+0aKxsftevHgB3W53Gn/49ttv4enTp7n3+/79ezg/P5/ZDAaD4TpD3WLIQ54w544t23dycgLHx8ewsbEBKysrsL29Daurq7kBw6+//hr+8z//k3xvBoPBsOggE8O3334L4/E4d/9nn302Fca+dZC5dnwUjZXsy7bsGgAQdGUBAHzxxRfwH//xH9N/n5+fwyeffJL7Ow0Gg2HRQSaG7e1t0riNjQ3Y29u78v9uiwLK2LW1tah9lJQ+F7du3YJbt26xjjEYDIZFhroryQ/0Hh8fw2AwmNHcV1ZWgkFhd6xvYXD2DQYDOD09hZWVlWktQ8haMBgMBsNVJIkx7O/vw1/+8hdYX1+Hg4MD2N/fn+77+uuvYX19HXZ2dkrHSvf94Q9/gKOjI3j27FmKn2kwGAwLCWuJ4cEqnw0Gw6LB1mMwGAwGgwhGDAaDwWCYgRGDwWAwGGZQWYHbvCALuVgFtMFgWBRk8owaUjZi8PDDDz8AAFiRm8FgWDj88MMPcPfu3dJxlpXk4fLyEr777jv4zW9+A61Wi3xcVjH9+vVry2ZyYM8lH/ZswrDnko/YZ4OI8MMPP8Bvf/vbmVUL82AWg4d2uw2/+93voo+/c+eOfcwB2HPJhz2bMOy55CPm2VAshQwWfDYYDAbDDIwYDAaDwTADIwYl3Lp1C7766itryOfBnks+7NmEYc8lH1U9Gws+GwwGg2EGZjEYDAaDYQZGDAaDwWCYgaWrEnB8fDxdQ/r4+Bi2t7eDK9JRxr548QL+7d/+DY6OjqKv0RRoPZeifS9evAAAgPv378Px8TGcnp42bm2NKp7DPH4fAPaN5KHxMgUNpbh///707+PxGDc3N6PG7u/v49HREYYeO+caTYHWcynat729jQCAAIAbGxs4mUyU7l4PVTyHefw+EO0byUPTZYoRQwnG4/HMA0ZEXFlZEY31XyLnGk2B1nMpO8/e3h5OJpPGTvYqnsM8fh+I9o3kYR5kisUYSvD8+XPodrsz/9ftdqfma+xYjePqhNZzoZwntJxrU1DFc5jH7wPAvpE8zINMsRhDCU5PT4P/f3JyIhqrcVyd0HouZec5PT2Fp0+fAgDAwcEB/PGPf7yyVnidqOI5zOP3AWDfSB7mQaYYMUQi78FLx2ocVye0nku2zw2Yra2twWeffQbj8Tj+BiuC9nOQXqNJsG8kjCbJlGtLDN9++23hx/PZZ5/BxsYGrKysXGHZk5OToNnKGatxXApU/VzKznN8fDzNMMmyK46PjxujEVbxHJr0fXBg30gYcyFTyNGIa4q8IE4o0EUd6z92zjWaAq3nUrTv6OhoJmA2mUwQABr1XKp4DvP4fSDaN5KHeZApFnwuga91HB8fw2AwmMmhPj4+Jo114Zp0nOOaAq3nUrZvOBxO9z1//hw2Nzcb9Vyqeg5F12gq7BsJYy5kCok+rjnG4zHu7Ozg/v4+7uzszLDu5uYmDodD0thnz57hzs4OAsB0DOW4pkLruRTtOzo6wuFwiHt7e7izs1PBr+Kjiucwj98Hon0jeWi6TLEmegaDwWCYgbmSDAaDwTADIwaDwWAwzMCIwWAwGAwzMGIwGAwGwwyMGAwGg8EwAyMGg8FgMMzAiMFgMBgMMzBiMBgMBsMMjBgMBoPBMAMjBoPBYDDMwIjBYDAYDDMwYjAYDAbDDP4fVXtD1L0XGhQAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 400x400 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Plot trajectories\n",
    "\n",
    "plt.figure(figsize=(4, 4))\n",
    "plt.scatter(qx.cpu().numpy(), px.cpu().numpy(), s=1, color='black')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "4dbe0c31-2a03-4dd0-9230-d6663bf8c426",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 800x200 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 13.7 s, sys: 149 ms, total: 13.8 s\n",
      "Wall time: 13.7 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "# Output can be collected at each integration step\n",
    "# Note, container is overwritten at each call\n",
    "\n",
    "FODO.ns = 0.01\n",
    "FODO.output = True\n",
    "\n",
    "state = torch.tensor([+0.01, 0.0, -0.01, 0.0], dtype=torch.float64)\n",
    "orbit = []\n",
    "for _ in range(16):\n",
    "    state = FODO(state)\n",
    "    orbit.append(FODO.container_output)\n",
    "qx, _, qy, _  = torch.vstack(orbit).T\n",
    "\n",
    "plt.figure(figsize=(8, 2))\n",
    "plt.scatter(range(len(qx)), qx.cpu().numpy(), s=1, color='blue')\n",
    "plt.scatter(range(len(qy)), qy.cpu().numpy(), s=1, color='red')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "fc1160cc-c4f4-406e-8731-18629f03c9e3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 13.3 s, sys: 3.99 s, total: 17.2 s\n",
      "Wall time: 20.7 s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "tensor([0., 0., 0., 0.], dtype=torch.float64)"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "# Functions can be compiled, but note that dynamo unrolls loops completely (torch 2.4)\n",
    "# This leads to very long compilation times\n",
    "\n",
    "FODO.ns = 1\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "table = 1.0E-3*torch.randn((512, 4), dtype=FODO.dtype, device=FODO.device)\n",
    "\n",
    "fodo = torch.compile(FODO)\n",
    "fodo(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "9accb757-afef-43ea-b322-18e1707a3954",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3.98 ms ± 9.28 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "FODO(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "33ded75c-6342-470f-972b-b883f6295d34",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "364 µs ± 1.43 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "fodo(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "9323a3b7-0e75-42f3-a283-46816242eb64",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "7.49 ms ± 26.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "_ = torch.vmap(FODO)(table)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "0fe47bba-3e74-48ff-bff6-37c1f3980ef9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "7.55 ms ± 22.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n"
     ]
    }
   ],
   "source": [
    "%%timeit\n",
    "\n",
    "_ = torch.vmap(fodo)(table)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "62632473-9c09-4fb4-a02a-181bd2863eb8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Note, compositional operations (map or jacobian seems to break/ignore compiled version)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "3e38cba7-7fbf-46b5-bb62-6b953578d8a9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'FODO'"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# name (property)\n",
    "# This property can be used to get/set line name\n",
    "\n",
    "FODO.name"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "b6d2fc70-f6d1-412c-8ea9-b545de461d26",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "18"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# sequence (property)\n",
    "# Contains ordered sequence of elements\n",
    "# Elements can be added or removed from it\n",
    "\n",
    "len(FODO.sequence)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "9427bf24-8f57-40db-89de-1ae2873760c9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'QF': ('Quadrupole',\n",
       "  tensor(0.5000, dtype=torch.float64),\n",
       "  tensor(0., dtype=torch.float64)),\n",
       " 'DR': ('Drift',\n",
       "  tensor(0.2500, dtype=torch.float64),\n",
       "  tensor(0., dtype=torch.float64)),\n",
       " 'SF': ('Sextupole',\n",
       "  tensor(0.2500, dtype=torch.float64),\n",
       "  tensor(0., dtype=torch.float64)),\n",
       " 'BM': ('Dipole',\n",
       "  tensor(3.5000, dtype=torch.float64),\n",
       "  tensor(0.3927, dtype=torch.float64)),\n",
       " 'SD': ('Sextupole',\n",
       "  tensor(0.2500, dtype=torch.float64),\n",
       "  tensor(0., dtype=torch.float64)),\n",
       " 'QD': ('Quadrupole',\n",
       "  tensor(0.5000, dtype=torch.float64),\n",
       "  tensor(0., dtype=torch.float64))}"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# unique (property)\n",
    "# name: (type, length, angle) data for all unique elements\n",
    "\n",
    "FODO.unique"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "b93ee2c5-855c-433c-87e9-072a6dcc7e2a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor(12., dtype=torch.float64)"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# length (property)\n",
    "\n",
    "FODO.length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "bae73748-f864-4687-b81b-9eb89a8e0f2f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor(0.7854, dtype=torch.float64)"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# angle (property)\n",
    "\n",
    "FODO.angle"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "0469183e-dac9-4792-a190-98b1081eb216",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'QF': 10, 'DR': 10, 'SF': 10, 'BM': 10, 'SD': 10, 'QD': 10}\n",
      "{'QF': 5, 'DR': 3, 'SF': 3, 'BM': 35, 'SD': 3, 'QD': 5}\n",
      "{'QF': 5, 'DR': 1, 'SF': 25, 'BM': 35, 'SD': 25, 'QD': 5}\n"
     ]
    }
   ],
   "source": [
    "# ns (property)\n",
    "# This property can be used to get/set number of integration steps to unique elements\n",
    "\n",
    "# Set value integration steps to all elements\n",
    "\n",
    "FODO.ns = 10\n",
    "print(FODO.ns)\n",
    "\n",
    "# Set ceil(element.length/value) integration steps to each element\n",
    "\n",
    "FODO.ns = 0.1\n",
    "print(FODO.ns)\n",
    "\n",
    "# Set by name or type\n",
    "\n",
    "FODO.ns = (('DR', 1), ('Sextupole', 0.01))\n",
    "print(FODO.ns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "635af0f5-1cbb-474c-8dff-5e4ad55e2fb3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'QF': 0, 'DR': 0, 'SF': 0, 'BM': 0, 'SD': 0, 'QD': 0}\n",
      "{'QF': 0, 'DR': 0, 'SF': 1, 'BM': 1, 'SD': 1, 'QD': 0}\n"
     ]
    }
   ],
   "source": [
    "# order (property)\n",
    "# This property can be used to get/set integration order to unique elements\n",
    "\n",
    "# Set value integration steps to all elements\n",
    "\n",
    "FODO.order = 0\n",
    "print(FODO.order)\n",
    "\n",
    "# Set by name or type\n",
    "\n",
    "FODO.order = (('BM', 1), ('Sextupole', 1))\n",
    "print(FODO.order)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "5fc306a4-8dd9-41e4-acfd-4f31d469f80f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'QF': 1, 'DR': 1, 'SF': 1, 'BM': 1, 'SD': 1, 'QD': 1}\n",
      "{'QF': 0, 'DR': 0, 'SF': 0, 'BM': 0, 'SD': 0, 'QD': 0}\n",
      "8\n"
     ]
    }
   ],
   "source": [
    "# Nested lines\n",
    "# Note, flags for lines are not propagated\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "RING = Line('RING', 8*[FODO], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "RING.ns = 1\n",
    "print(RING.ns)\n",
    "\n",
    "RING.order = 0\n",
    "print(RING.order)\n",
    "\n",
    "# Note, sublines are not flattened\n",
    "\n",
    "print(len(RING.sequence))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "dd4c2418-8baf-460d-9fcb-ef989a65c630",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "tensor([0., 0., 0., 0.], dtype=torch.float64)"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Tracking, mapping and differentiation is similar to flat lines\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "RING(state)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "d41ef33e-c41b-4072-b59c-7a632a7f2ff2",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'FODO': {'QF': {'kn': tensor(0., dtype=torch.float64),\n",
       "   'ks': tensor(0., dtype=torch.float64),\n",
       "   'dp': tensor(0., dtype=torch.float64),\n",
       "   'dl': tensor(0., dtype=torch.float64)},\n",
       "  'DR': {'dp': tensor(0., dtype=torch.float64),\n",
       "   'dl': tensor(0., dtype=torch.float64)},\n",
       "  'SF': {'ms': tensor(0., dtype=torch.float64),\n",
       "   'dp': tensor(0., dtype=torch.float64),\n",
       "   'dl': tensor(0., dtype=torch.float64)},\n",
       "  'BM': {'dw': tensor(0., dtype=torch.float64),\n",
       "   'e1': tensor(0., dtype=torch.float64),\n",
       "   'e2': tensor(0., dtype=torch.float64),\n",
       "   'kn': tensor(0., dtype=torch.float64),\n",
       "   'ks': tensor(0., dtype=torch.float64),\n",
       "   'ms': tensor(0., dtype=torch.float64),\n",
       "   'mo': tensor(0., dtype=torch.float64),\n",
       "   'dp': tensor(0., dtype=torch.float64),\n",
       "   'dl': tensor(0., dtype=torch.float64)},\n",
       "  'SD': {'ms': tensor(0., dtype=torch.float64),\n",
       "   'dp': tensor(0., dtype=torch.float64),\n",
       "   'dl': tensor(0., dtype=torch.float64)},\n",
       "  'QD': {'kn': tensor(0., dtype=torch.float64),\n",
       "   'ks': tensor(0., dtype=torch.float64),\n",
       "   'dp': tensor(0., dtype=torch.float64),\n",
       "   'dl': tensor(0., dtype=torch.float64)}}}"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Deviation table contains unique lines with unique elements (unique by names)\n",
    "\n",
    "RING.table(alignment=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "ca15becf-4999-487d-8155-1fc37bde9563",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([-0.0047,  0.0005, -0.0045, -0.0014], dtype=torch.float64)\n",
      "tensor([-0.0055,  0.0005, -0.0048, -0.0014], dtype=torch.float64)\n"
     ]
    }
   ],
   "source": [
    "# If this can be used to pass different values of deviation variables to unique elements\n",
    "# But values should match for consistent differentiation\n",
    "\n",
    "LA = Line('LA', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "LB = Line('LB', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "RING = Line('RING', [LA, LB], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "state = torch.tensor([0.01, 0.0, 0.01, 0.0], dtype=torch.float64)\n",
    "\n",
    "kn = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "data = RING.table()\n",
    "\n",
    "data['LA']['QF']['kn'] = kn\n",
    "data['LB']['QF']['kn'] = kn\n",
    "\n",
    "print(RING(state, data=data))\n",
    "\n",
    "kna = torch.tensor(+0.01, dtype=torch.float64)\n",
    "knb = torch.tensor(-0.01, dtype=torch.float64)\n",
    "\n",
    "data['LA']['QF']['kn'] = kna\n",
    "data['LB']['QF']['kn'] = knb\n",
    "\n",
    "print(RING(state, data=data))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "aae17708-cf03-4326-abf3-a8a921b01341",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 400x400 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Modulation\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "dkf = 1.0E-3*torch.randn(2**10, dtype=torch.float64)\n",
    "dkd = 1.0E-3*torch.randn(2**10, dtype=torch.float64)\n",
    "\n",
    "qx = torch.linspace(0.0, 0.01, 8, dtype=torch.float64)\n",
    "px = torch.zeros_like(qx)\n",
    "qy = torch.zeros_like(qx)\n",
    "py = torch.zeros_like(qx)\n",
    "\n",
    "state = torch.stack([qx, px, qy, py]).T\n",
    "orbit = []\n",
    "\n",
    "data = FODO.table()\n",
    "\n",
    "for i in range(2**10):\n",
    "    data['QF']['kn'] = dkf[i]\n",
    "    data['QD']['kn'] = dkd[i]\n",
    "    state = torch.vmap(lambda state: FODO(state, data=data))(state)\n",
    "    orbit.append(state)\n",
    "\n",
    "qx, px, *_ = torch.stack(orbit).swapaxes(0, -1)\n",
    "\n",
    "plt.figure(figsize=(4, 4))\n",
    "plt.scatter(qx.cpu().numpy(), px.cpu().numpy(), s=1, color='black')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "0aa4bfef-875b-4316-90cc-5da11fcf852b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.02090725772744483, 0.0005430498651489654, -0.004962609791574424, 0.0014062973408549748]\n",
      "[0.02090725772744481, 0.0005430498651489672, -0.004962609791574424, 0.0014062973408549748]\n"
     ]
    }
   ],
   "source": [
    "# Nested alignment (test without bending)\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.25)\n",
    "QD = Quadrupole('QD', 0.5, -0.20)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Drift('BM', 3.50)\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, dp=0.0, exact=False, output=False, matrix = False)\n",
    "\n",
    "state = torch.tensor([+0.01, 0.0, -0.01, 0.0], dtype=torch.float64)\n",
    "\n",
    "dx = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "dx_qf = torch.tensor(0.01, dtype=torch.float64)\n",
    "dx_qd = torch.tensor(0.01, dtype=torch.float64)\n",
    "\n",
    "# 2x quadrupoles\n",
    "\n",
    "data = FODO.table()\n",
    "data['dx'] = 0*dx\n",
    "data['QF']['dx'] = 2*dx_qf\n",
    "data['QD']['dx'] = 2*dx_qd\n",
    "\n",
    "print(FODO(state, data=data, alignment=True).tolist())\n",
    "\n",
    "# 1x quadrupoles and 1x fodo\n",
    "\n",
    "data['dx'] = 1*dx\n",
    "data['QF']['dx'] = 1*dx_qf\n",
    "data['QD']['dx'] = 1*dx_qd\n",
    "\n",
    "print(FODO(state, data=data, alignment=True).tolist())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "9c931b81-529c-4140-974a-443b155015d4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor([[-0.4395, 15.4433,  0.0000,  0.0000],\n",
      "        [-0.0522, -0.4395,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  0.4963,  5.3596],\n",
      "        [ 0.0000,  0.0000, -0.1406,  0.4963]], dtype=torch.float64)\n",
      "\n",
      "tensor([[-0.4395, 15.4433,  0.0000,  0.0000],\n",
      "        [-0.0522, -0.4395,  0.0000,  0.0000],\n",
      "        [ 0.0000,  0.0000,  0.4963,  5.3596],\n",
      "        [ 0.0000,  0.0000, -0.1406,  0.4963]], dtype=torch.float64)\n",
      "\n"
     ]
    },
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 800x400 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Matrix output and twiss parameters\n",
    "\n",
    "from twiss import twiss\n",
    "from twiss import propagate\n",
    "from twiss import wolski_to_cs\n",
    "\n",
    "QF = Quadrupole('QF', 0.5, +0.25)\n",
    "QD = Quadrupole('QD', 0.5, -0.20)\n",
    "SF = Sextupole('SF', 0.25)\n",
    "SD = Sextupole('SD', 0.25)\n",
    "DR = Drift('DR', 0.25)\n",
    "BM = Dipole('BM', 3.50, torch.pi/8.0)\n",
    "\n",
    "FODO = Line('FODO', [QF, DR, SF, DR, BM, DR, SD, DR, QD, QD, DR, SD, DR, BM, DR, SF, DR, QF], propagate=True, matrix=True)\n",
    "FODO.ns = 0.01\n",
    "\n",
    "state = torch.tensor([0.0, 0.0, 0.0, 0.0], dtype=torch.float64)\n",
    "\n",
    "print(torch.func.jacrev(FODO)(state))\n",
    "print()\n",
    "\n",
    "out, *ms = FODO.container_matrix\n",
    "for m in ms:\n",
    "   out = m @ out\n",
    "print(out)\n",
    "print()\n",
    "\n",
    "*_, w = twiss(out)\n",
    "ws = [w]\n",
    "\n",
    "for m in FODO.container_matrix:\n",
    "    w = propagate(w, m)\n",
    "    ws.append(w)\n",
    "\n",
    "ws = torch.stack(ws)\n",
    "\n",
    "_, bx, _, by = torch.vmap(wolski_to_cs)(ws).T\n",
    "\n",
    "s = torch.linspace(0.0, 12.0, len(bx), dtype=torch.float64)\n",
    "\n",
    "plt.figure(figsize=(8, 4))\n",
    "plt.scatter(s.cpu().numpy(), bx.cpu().numpy(), s=1, color='blue')\n",
    "plt.scatter(s.cpu().numpy(), by.cpu().numpy(), s=1, color='red')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f49b651-b89b-45e7-b198-19ea182d4bab",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [
    "myt0_gMIOq7b",
    "5d97819c"
   ],
   "name": "03_frequency.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.1"
  },
  "latex_envs": {
   "LaTeX_envs_menu_present": true,
   "autoclose": false,
   "autocomplete": true,
   "bibliofile": "biblio.bib",
   "cite_by": "apalike",
   "current_citInitial": 1,
   "eqLabelWithNumbers": true,
   "eqNumInitial": 1,
   "hotkeys": {
    "equation": "Ctrl-E",
    "itemize": "Ctrl-I"
   },
   "labels_anchors": false,
   "latex_user_defs": false,
   "report_style_numbering": false,
   "user_envs_cfg": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
